>>DHTML时代，网景和微软的技术分歧很大，浏览器互不兼容，W3C为了统一局面，
开发了DOM，这就是文档对象模型；

>>文档类型
常见的文档类型有HTML和XML，HTML侧重于显示，而XML侧重于保存数据;
文档类型还有由XML扩展出的SVG和MathVG；

>>常用节点的nodeType, nodeName, nodeValue
以简单的HTML文档为例：
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>nodeType, nodeName, nodeValue</title>
</head>
<body>
	<!--This is a comment-->
	<div id="container">This is a text</div>
</body>
</html>
取各常用节点对象：
var divNode = document.getElementById('container');
var attrNode = divNode.attributes[0];
var textNode = divNode.childNodes[0];
var commentNode = document.body.childNodes[1];
var doctypeNode = document.doctype;
var frag = document.createDocumentFragment();
以上常用节点的nodeType, nodeName, nodeValue值总结如下：
1)Element: 1 | DIV | null;
2)Attr: 2 | id | container;
3)Text: 3 | #text | This is a text;
4)Comment: 8 | #comment | This is a comment;
5)Document: 9 | #document | null;
6)DocumentType: 10 | html | null;
7)DocumentFragment: 11 | #document-fragment | null;
注：
1，Document是文档的根节点，它不出现在文档树中，它有两个子节点，即
DocumentType节点和html节点，而html节点是文档树的根元素节点；
2，DocumentFragment不会出现在文档树中，它相当于占位符，当被插入到文档树时，
本身不会被插入，只插入它下面的所有子元素节点，如：
var frag = document.createDocumentFragment();
for(var i = 0; i < 10; i++){
	var li = document.createElement('li');
	li.innerHTML = 'text ' + i;
	frag.appendChild(li);
}
document.getElementById('container').appendChild(frag);

>>取某个节点下的所有元素节点
var elems = node.getElementsByTagName('*');

>>DOMReady
1, window.onload = function(){
	//...
}
这种方式不仅包含DOMReady，还包含了其他资源的加载，速度最慢；
2, document.addEventListener('DOMContentLoaded', function(){
	//...
});
DOMReady完毕就立即执行，无须等待其他资源的加载，速度最快；
3, $(document).ready(function(){
	//...
});
jquery封装的DOMReady，与第二种方式一样，速度很快；

>>判断节点和文档类型的实现
1, 是否为元素节点
function isElement(elem){
	return !!elem && elem instanceof Node && elem.nodeType == 1;
}
2, 文档是否为HTML
function isHTML(doc){
	return doc.createElement('div').nodeName === 
		doc.createElement('DIV').nodeName;
}
注：在HTML中，元素的nodeName属性返回的元素名都是大写，根据这一点来判断；
属性法容易被攻破，这是通过功能法来判断的；
这个函数需要传入文档节点参数即document来判断；
3, 文档是否为XML
function isXML(doc){
	return doc.createElement('div').nodeName !== 
		doc.createElement('DIV').nodeName;
}
4, 元素是否为HTML的元素
function isHTMLElement(elem){
	if(isElement(elem)){
		return isHTML(elem.ownerDocument);
	}
	return false;
}
注：该方法结合了上面实现的方法，elem.ownerDocument返回当前文档对象，即
elem.ownerDocument === document; //true
5, 元素是否为XML的元素
function isXMLElement(elem){
	if(isElement(elem)){
		return isXML(elem.ownerDocument);
	}
	return false;
}	

>>节点间的包含关系
node1.contains(node2):
var div = document.createElementById('container');
document.contains(div); //true
document.body.contains(div.childNodes[0]); //true
document.doctype.contains(div); //false

>>事件处理
1, 事件冒泡
事件由最具体的元素接收，然后逐级往上传播；
大多浏览器都支持事件冒泡；
2, 添加事件的方式
1)内嵌到HTML元素
<input type="button" id="btn" value="按钮" onclick="showMsg()">
2)DOM0级事件处理程序
var btn = document.getElementById('btn');
btn.onclick = showMsg; //绑定事件
btn.onclick = null; //清空事件
3)DOM2级事件处理程序
btn.addEventListener('click', showMsg, false); //第三个参数默认为false表示冒泡阶段捕获事件
btn.removeEventListener('click', showMsg); //删除绑定的事件
注：通过addEventListener添加的事件，只能通过removeEventListener来删除；
DOM2级事件处理程序的优点是可以为一个事件添加多个事件处理程序;
3, 事件对象
btn.onclick = function(e){
	console.log(e);
};
事件对象的常用属性和方法有
type, target, stopPropagation(), preventDefault();

