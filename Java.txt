>>jvm, jre和jdk
1，java程序的执行分为两个过程: 
编译(源程序.java->字节码文件.class)和解释执行(jvm)，jvm依赖于具体的平台，是实现java跨平台的基础；
2，jre = jvm + 标准类库,
jdk = jre + 开发工具集;
3，jdk中的两个组件javac(编译器)和java(虚拟机);
javac.exe和java.exe包含在bin目录下，安装jdk后需要把该目录添加到环境变量中，如在环境变量的path中添加
D:\Java\jdk1.8.0_261\bin;
4, 命令行运行java程序:
javac Hello.java
java Hello


>>eclipse
1, 打开eclipse时会提示设置工作目录，如D:\Java\workspace, 工作目录可通过File->Switch Workspace进行切换;
2, 新建工程test后，源文件放在D:\Java\workspace\test\src目录下，编译生成的字节码文件放在D:\Java\workspace\test\bin目录下;
3, 可通过Window->Preferences进行个性化设置，通过Window->Show View设置当前打开哪些子窗口；
4, test工程右键->Resource->encoding设置程序的编码，有时导入源码中出现中文乱码可通过这种方式解决;
也可通过Window->Preferences->encoding进行编码的设置;
5, 调试默认快捷键
F6-单步调试, F8-直接跳到下一个断点, F5-进入函数, F7-跳出函数;


>>基本语法
1, 标识符可包含字母、数字、_和$，不能以数字开头，区分大小写，不能为关键字和保留字;
2, 目前java有50个关键字，2个保留字(goto、const);
3, 项目名首字母小写，类名首字母大写，变量名和方法名首字母小写，都遵循驼峰命名法;
4, 变量的三个要素: 变量类型、变量名、变量值;
5, 变量的分类:
按数据类型分: 基本类型、引用类型；
按作用范围分: 类级变量、实例级变量、方法级变量(局部变量)、块级变量;
6, 编码
ascii码: 用1个字节表示字母数字及常用符号;
标准ascii码: 7位，表示128个字符;
扩展ascii码: 8位，表示256个字符;
unicode码: 用两个字节表示全世界所有的字符;
char c = '\u005d';
String s = "A\u00d2\u02a8B";
7, 字符集
utf-8: 英文用1个字节，中文用3个字节;
gbk: 英文用1个字节，中文用2个字节;
utf-16be: 所有字符都用2个字节;
8，常量用final修饰，常量的命名全部用大写，多个单词之间用_分隔，这与变量不同，如
int minValue = -100;
final int MIN_VALUE = -100;
9, 运算符
算术运算符、赋值运算符、关系运算符、逻辑运算符、条件运算符、位运算符;
10, &&与&都是逻辑与运算符，前者是短路逻辑，||与|类似;
11, 局部变量在使用前一定要初始化，否则会报错;
12, 包
包的作用: 管理java的类，以及防止类的命名冲突;
包的命名采用: 域名倒序.项目.模块.功能, 如 pacakge com.imooc.animal;
加载某个包里的所有类: import com.imooc.animal.*;
加载某个包里的特定类: import com.imooc.animal.Cat;
注: import 包名.* 只能导入指定包名下所有直接允许访问的类, 无法导入其子包中的类;


>>数据类型
1, 分类
1)基本类型
	数值型
		整数类型: byte(1), short(2), int(4), long(8);
		浮点类型: float(4), double(8);
	字符型: char(2);
	布尔型: boolean(1);
2)引用类型
类(class)、接口(interface)、数组;
2，long类型字面量后要加L，float类型字面量后要加f, 如
long a = 123L;
float b = 1.23f;
3, 二进制加前导0b，八进制加前导0，十六进制加前导0x, 如
int a = 12;
int b = 0b1011;
int c = 012;
int d = 0x12;
4, 类型转换
1)自动转换(隐式转换)
小类型可以自动转换为大类型，不会丢失精度, 如
long a = 100;
double b = 1.23f; 
char c = 65;
2)强制转换(显式转换)
大类型转换为小类型，需要经过强制转换店，如
int a = (int)100L;
float b = (float)1.23;
char c = (char)65536;
注: char用2个字节表示，范围为0~65535, 超过这个表示范围需要使用强制转换;
5, 不同基本类型的数值比较，只要值相等，==就返回true;
10L == 10.0; //true
'a' == 97; //true


>>数组
1，数组的定义
//一维数组
int[] a = new int[10];
int[] b = {1, 2, 3, 4, 5};
int[] c = new int[]{1, 2, 3, 4, 5};
//二维数组
int[][] a = new int[3][4]; 
int[][] b = new int[3][];  //必须指定第一维的长度
int[][] c = {{1}, {2, 3}, {4, 5, 6}}; //第二维的长度可以不同
注: 与局部变量不同，数组中的元素都有默认初始值;
2, 增强型for循环
int[] a = {1, 2, 3, 5, 8};
for(int item: a){
	//...
}
3, 双重循环的写法(如冒泡排序)
外层循环表示次数，内层循环表示每次遍历;
for(int i = 0; i < a.length-1; i++){ //a.length-1次
	for(int j = 0; j < a.length-1-i; j++){ //沉底
		//...
	}
	for(int j = a.length-1; j > i; j--){ //冒泡
		//...
	}
}
4, 数组的排序
Arrays.sort(a);


>>方法
1, 给主方法main传递参数
1)命令行中
javac Hello.java
java Hello zhao 30
2)Eclipse中
Run->Run Configurations->Arguments中填入参数;
2, 按值传参
方法是按值传参的，如果是基本类型数据则不会改变，而引用类型数据里的字段值会改变;
数组名是指向数组第一个元素的引用，所以传递数组，会改变数组元素的值;
3, 方法重载
方法的参数个数或参数的类型不同, 称为方法重载，如
int sum(int a, int b);
float sum(float a, float b, float c);
int sum(int[] a);
4, 可变参数
1)int sum(int... a){
	//a是实参组成的数组
}
实参可以是可变参数，也可以是数组; 
当有多个形参时，可变参数必须放在最后;
2)含可变参数的方法可以与具体参数的方法重载，优先调用具体参数的方法，如
int sum(int... a){}
int sum(int a, int b){}
当调用sum(1, 2)时，优先调用第二个方法;


>>面向对象
1, 面向对象的三大特征: 
封装, 继承, 多态;
2, 类和对象的基本语法
1)与局部变量不同，类的属性会有默认初始值;
2)单一职责原则: 一个类只完成一个功能，即高内聚，低耦合;
3)对象实例的引用, 输出的值形如 com.imooc.animal.Cat@4926097b;
4)如果没有定义构造函数，系统会提供一个默认的无参构造函数，如果显式定义了构造函数，则不会提供默认构造函数;
5)构造函数只能在构造函数之间相互调用且必须出现在第一行，不允许在别的地方显式调用;
public Cat(){
	//...
}
public Cat(String name){
	this();
	this.name = name;
}
public Cat(String name, int age){
	this(name);
	this.age = age;
}
6)内存的划分: 栈、堆、常量池;
栈中存放一些局部变量, 如基本数据类型变量、对象的引用等, 当局部变量作用范围结束时, 栈内信息自动释放;
堆中存放动态数据, 如new出来的对象, 当无实例引用指向堆中数据时，垃圾回收机制才会释放堆空间;
如 Cat one = new Cat(); 分为两部分:
对象声明 Cat one, 在栈空间;
对象实例化 new Cat(), 在堆空间;
7)封装
隐藏对象的信息，提供访问的接口;
封装的实现有三步:
修改属性的可见性为private；
创建公开的getter/setter方法用于属性的读写;
在getter/setter方法中对属性的合法性进行判断;
8)static
静态成员，又叫类成员，包括静态属性和静态方法, 是属于类的，只在类加载时初始化一次，存续时间较长;
静态成员可以通过类名.静态成员或对象.静态成员这两种方式访问，推荐用前者;
静态方法里面只能访问静态成员，而非静态方法既可以访问非静态成员，也可以访问静态成员;
注: java中没有静态局部变量;
注: static方法只能被子类继承，不能被子类重写;
9)代码块
静态代码块: 
只在类加载时执行一次，不能在静态代码块中直接访问非静态成员;
构造代码块:
每次实例化对象时都会执行，在构造方法之前调用;
普通代码块:
在方法体内用{}括起来的一段代码块;
注: java有块作用域，在代码块中定义的变量，外部无法访问;
10)类的组成要素及初始化顺序
静态属性、静态代码块、静态方法、实例属性、构造代码块、构造方法、实例方法, 初始化顺序编号如下: 
public class Cat{
	private String name = "小猫";  //3
	public static int price = 100;  //1
	static{  //2
		System.out.println("静态代码块...."):
	}
	{  //4
		System.out.println("构造代码块....");
	}
	public Cat(){  //5
		System.out.println("构造方法....");
	}
	public String getName(){
		return name;
	}
	public void setName(String name){
		this.name = name;
	}
	public void changePrice(int price){
		Cat.price = price;
	}
}
11)访问修饰符 
(默认): 本包(√);
protected: 本包(√), 跨包子类(√);
按可见性由大到小排列: public > protected > (默认) > private;
12)final
final作用于类, 表示类不能被继承;
final作用于方法，表示方法不能被重写;
final作用于属性，表示常量;
3, 继承
1)java只支持类的单继承，但可以实现多个接口，接口之间也可以多继承;
2)方法重写
子类方法的参数数量和类型要与父类一致, 如果不一致就属于方法重载;
子类方法访问修饰符的可见性必须大于等于父类方法;
子类方法的返回值要么与父类相同，要么是父类方法返回值的子类;
子类方法抛出的异常类型要么与父类相同，要么是父类方法抛出的异常类型的子类;
3)super
子类中调用父类的方法;
super(name, age); //调用父类的构造方法, 必须出现在第一行
super.name; //调用父类的属性
super.eat(); //调用父类的方法
4)子类的构造方法如果没有显式调用父类的构造方法，则默认调用父类的无参构造方法;
因为无参构造方法会被子类默认调用，所以一般情况下定义类时记得加上无参构造方法;
5)继承的初始化顺序
父类的静态属性初始化->父类的静态代码块->
子类的静态属性初始化->子类的静态代码块->
父类的实例属性初始化->父类的构造代码块->父类的构造方法->
子类的实例属性初始化->子类的构造代码块->子类的构造方法;
6)程序编译出错不一定导致运行出错，如果程序运行时不执行出错代码，则也能运行正常;
class Animal{
	private String name;
	public Animal(String name){ this.name = name; }
}
class Cat extends Animal{
	private int age;
	public Cat(){} //此处编译出错
	public Cat(Sting name, int age){ super(name); this.age = age; }
}
public class Test{
	Cat cat = new Cat("花花", 5); 
}
由于父类没有定义无参构造方法，所以编译出错，但并不影响运行结果;
4, 多态
1)不同对象对同一消息做出不同的反应;
多态要满足三个条件: 满足继承关系; 要有重写; 父类引用指向子类对象;
多态 = 向上转型 + 动态绑定;
2)向上转型
也叫隐式转型、自动转型，将子类转换为父类;
Animal one = new Cat();
3)向下转型
也叫显式转换、强制转换, 向下转型是为了重新获得因为向上转型而丢失的子类特性, 通常结合instanceof一起使用;
((Cat)one).run();
注: 子类实例向上转型后，就不能再调用子类特有的方法了，必须再向下转型后才能调用;
4)instanceof
Animal one = new Cat();
one instanceof Animal; //true
one instanceof Cat; //true
one instanceof Dog; //false
5)多态的应用举例
public class Master{
	public void feed(Animal obj){
		obj.eat();
		if(obj instanceof Cat){
			((Cat)obj).run();
		}else if(obj instanceof Dog){
			((Dog)obj).sleep();
		}
	}
	public Animal select(int type){
		if(type == 1){
			return new Cat();
		}else{
			return new Dog();
		}
	}
}
5, 抽象类
1)抽象类不能直接实例化; 子类需要重写抽象父类的抽象方法，否则子类也是抽象类;
public abstract class Animal{
	public abstract void eat();
}
2)abstract不能与final、static、private一起使用;
6, 接口
1)继承一个类的同时可以实现多个接口
public class FourthPhone extends ThirdPhone implements IPhoto, INet{
	//...
}
ThirdPhone phone1 = new FourthPhone();
phone1.message(); //从父类继承的方法;
IPhoto phone2 = new FourthPhone();
phone2.photo(); //从接口IPhoto实现的方法;
INet phone3 = new FourthPhone();
phone3.network(); //从接口INet实现的方法
2)实现类需要实现接口里的所有抽象方法, 否则实现类就是抽象类;
interface IAnimal{
	void run();
	void eat();
}
abstract class Pet implements IAnimal{ //未实现接口的全部方法，所以定义为抽象类
	@Override 
	public void run(){
		System.out.println("Pet can run...");
	}
}
class Cat extends Pet{ //继承抽象类，实现抽象方法
	@Override
	public void eat(){
		System.out.println("Cat can eat...");
	}
}
3)接口中的方法默认是 public abstract, 接口中的常量默认是 public static final;
interface IAnimal{
	String NATION = "China";
	void eat();
}
4)接口中的组成要素
抽象方法、常量、默认方法、静态方法;
interface IAnimal{
	String NATION = "China"; //常量, 默认是 public static final
	void eat(); //抽象方法, 默认是 public abstract
	public default void run(){ //默认方法
		//...
	}
	public static void sleep(){ //静态方法
		//...
	}
}
class Cat implements IAnimal{
	@Override
	public void eat(){ //必须实现抽象方法
		//...
	}
	@Override
	public void run(){ //是否重写默认方法可选
		IAnimal.super.run();
		//...
	}
}
注: 重写默认方法时不用加default, 实现类中调用接口的默认方法用 接口名.super.方法名 的格式;
静态方法不能被重写, 只能通过 接口名.方法 的格式调用接口的静态方法;
5)当接口和父类中含有同名方法或同名常量/变量时
如果只实现两个接口，则必须重新定义该同名方法;
如果继承父类的同时实现两个接口，则优先调用父类的同名方法;
与父类的方法优先不同，父类的变量与接口的常量如果同名，则地位相同，必须显示指定调用哪一个，如
super.name, IPhoto.name, INet.name, 或者在子类中重新定义该变量;
6)接口的继承
public interface IHuman extends ITalk, IWork{}
7)接口的继承与类的继承两者的区别
类只能单继承, 而接口可以多继承;
类可以继承静态方法, 但不能重写, 接口不能继承静态方法;
8)接口与抽象类
抽象类是对类的抽象，是一种模板设计;
接口是对行为的抽象，是一种行为规范;
7, 内部类
成员内部类、静态内部类、方法内部类、匿名内部类;
1)成员内部类
public class Person{
	int age;
	public Heart getHeart(){ //获取内部类
		return new Heart();
	}
	class Heart{ //内部类
		return age + "岁的心脏在跳动"; //等价于 Person.this.age
	}
}
获取成员内部类的几种方式:
方式1: new 外部类.new 内部类
Person.Heart h = new Person().new Heart();
方式2: 外部类对象.new 内部类
Person p = new Person();
Person.Heart h = p.new Heart();
方式3: 外部类对象.获取方法
p.getHeart();
注: 内部类可以直接访问外部类的属性和方法, 或者通过 外部类.this.成员 的方式来访问外部类的成员;
编译后生成的两个文件: Person.class 和 Person$Heart.class;
2)静态内部类
在内部类前加static修饰符就成为静态内部类;
获取静态内部类: Person.Heart h = new Person.Heart();
调用静态内部类里的静态成员: Person.Heart.静态成员;
静态内部类里访问外部静态成员: Person.静态成员;
静态内部类里访问外部实例成员: new Person().实例成员;
编译后生成的文件同成员内部类;
3)方法内部类
public class Car{
	public void run(){
		class Engine{
			public void run(){
				//...
			}
		}
		Engine engine = new Engine();
		return engine.run();
	}
}
编译后生成的两个文件: Car.class 和 Car$1Engine.class;
4)匿名内部类
没有类名, 通常用来实现一个抽象类或者接口;
public abstract class Transport{
	public abstract void run();
}
Transport car = new Transport(){
	public void run(){
		System.out.println("汽车会跑");
	}
};
Transport airplane = new Transport(){
	public void run(){
		System.out.println("飞机会飞");
	}
};
编译后生成的字节码文件: Transport.class, Transport$1.class, Transport$2.class;
5)应用场景
成员内部类: 
当两个类A和B彼此之间需要相互访问，且B只在A的某种特定应用中才需要，可以将B设置为A的成员内部类;
静态内部类:
当类A需要使用类B，而B并不需要直接访问外部类A的成员，可以将B设置为A的静态内部类;
方法内部类:
类只在方法内使用，相当于一次性产品，使用场景较少;
匿名内部类:
多用于作为方法参数或返回值;

>>枚举
enum Week{MONDAN, TUESDAY, WEDNESDAY, THURDAY, FRIDAY, SATURDAY, SUNDAY}
枚举的访问: Week.MONDAY;
Week wk = Week.MONDAN;
枚举可以定义在类的内部、类的外部，也可以定义在单独的类中，但不能定义在方法中;


>>Object类
java.lang.Object是所有类的父类, Object类中有几个方法经常需要被重写, 如hashCode(), equals(), toString();
equals()默认比较的是两个对象的地址是否相同;
判断两个对象是否相同，首先比较hashCode, 再通过equals()方法比较，如果hashCode不同则两个对象不相同;
toString()默认返回的对象引用的描述，如 com.imooc.animal.Cat@4926097b;
public class Animal{
	private String name;
	private int age;
	public Animal(){}
	public Animal(String name, int age){ this.name = name; this.age = age; }
	@Override
	public int hashCode(){
		return this.name.hashCode();
	}
	@Override
	public boolean equals(Object obj){
		if(obj == null) return false;
		if(obj == this) return true;
		if(getClass() != obj.getClass()) return false;
		Animal temp = (Animal)obj;
		if(name.equals(temp.name) && age==temp.age) return true;
		return false;
	}
	@Override
	public String toString(){
		return "Animal[name=" + name + ", age=" + age + "]";
	}
}


>>System类
System.in; //系统输入
System.out; //系统输出
System.exit(n); //程序终止, n表示状态
System.gc(); //垃圾回收
System.currentTimeMillis(); //返回从1970年到现在的毫秒数，常用于程序计时


>>Scanner类
1, 实例化如从控制台输入
Scanner sc = new Scanner(System.in);
2, 常用输入方法
sc.next(); //输入字符串，以空格结束
sc.nextLine(); //输入字符串，以换行符结束
sc.nextInt()/nextFloat()/nextDouble();


>>包装类
1, 基本数据类型对应的包装类
byte-Byte, short-Short, int-Integer, long-Long,
float-Float, double-Double, 
char-Character, 
boolean-Boolean;
其中, Byte, Short, Integer, Long, Short, Double都继承自Number;
2, 装箱 / 拆箱
//装箱: 基本类型->包装类
int i = 6;
Integer o1 = i; //自动装箱, 底层实现为 Integer.valueOf(i)
Integer o2 = new Integer(i); //手动装箱
Integer o3 = Integer.valueOf(i); //手动装箱
//拆箱: 包装类->基本类型
int i1 = o1; //自动拆箱, 底层实现为 o1.intValue()
int i2 = o1.intValue(); //手动拆箱
3, 基本类型与字符串之间的转换
//基本类型->字符串:
int i = 12;
String s1 = "" + i; //1
String s2 = Integer.toString(i); //2
String s3 = String.valueOf(i); //3
//字符串->基本类型
String s = "12";
int i1 = Integer.parseInt(s); //1
int i2 = Integer.valueOf(s); //
4, 包装类的比较
java在几种包装类中提供了缓存设计，会对一定范围内的数据做缓存，优先从缓存中取数据，超出范围才创建新对象;
Byte、Short、Integer、Long缓存[-128, 127]区间的数据;
Character缓存[0, 127]区间的数据;
Boolean缓存true和false;
Float和Double不支持缓存;
Integer i1 = 65;
Integer i2 = 65;
i1 == 65; //true
i1 == 'A'; //true
i1.equals(65); //true
i1.equals(65.0f); //false
i1.equals('A'); //false
Integer i3 = 200;
Integer i4 = 200;
i3 == i4; //false
Float f1 = 100.0f;
Float f2 = 100.0f; 
f1 == f2; //false
注: equals()方法首先比较类型是否相同，如果类型不同，则直接返回false;

>>字符串
1, String
1)创建
String s1 = "hello";
String s2 = new String("hello");
char[] ch = {'h', 'e', 'l' ,'l', 'o'};
String s3 = new String(ch);
String s3 = new String(ch, 1, 3); //从位置1开始的3个元素
byte[] b = {104, 101, 108, 108, 111};
String s4 = new String(b);
String s4 = new String(b, 1, 3); 
String s4 = new String(b, "utf-8"); //使用字节数组时可以指定字符集
2)常用方法
s.length(); 
s.charAt(2);
s.indexOf('o')/s.IndexOf("lo")/s.indexOf('o', 2); //可传入字符或者字符串，没找到则返回-1
s.lastIndexOf('o')/s.lastIndexOf("lo")/s.lastIndexOf('o', 2);
s.substring(3, 6)/s.substring(3); //参数为开始位置和结束位置的下一位置，省略则表示一直取到末尾
s.trim();
s.toLowerCase()/s.tuUpperCase();
s.split(" "); //按指定分隔符切割成字符串数组
s.getBytes()/s.getBytes("gbk"); //字节数组
3)字符串的比较
String s1 = "hello", s2 = "hello", s3 = new String("hello"), s4 = new String("hello");
s1 == s2; //true, 常量池
s3 == s4; //false
s1+"hi" == s2+"hi"; //false
s3.equals(s4); //true
字符串的相等性比较一定要用s1.equals(s2);
4)字符串的不可变性
2, StringBuilder / StringBuffer
1)String不可修改，而StringBuilder可以动态修改, 适用于字符串被频繁操作的场景;
StringBuffer是线程安全的, 但StringBuilder的效率更高;
2)StringBuilder与String的转换
StringBuilder sb = new String("hello");
String s = sb.toString();
3)常用方法
StringBuilder除了拥有部分String类的方法，如length(), charAt(), indexOf()/lastIndexOf(), substring()等，还有: 
sb.capacity(); //容量
sb.append("hi"); //在末尾添加
sb.insert(2, "hi"); //在中间插入
sb.delete(2, 5); //删除, 参数为起始位置和结束位置的下一位置
sb.replace(2, 5, "hi"); //替换
sb.reverse(); //反转


>>集合
1, 集合框架的层次:
两大接口: Collection和Map, Collection有三个子接口: List、Queue、Set; 
注: 集合中只能存储引用数据类型的元素, 可以存储不同类型的数据，除非加上泛型进行限定;
集合适合于无法预测元素的数量、经常对数据进行增删、不允许数据重复、存储具有一对一关系的数据等场景;
2, List:
1)list是有序且可重复的列表;
List的实现类ArrayList和LinkedList, LinkedList同时实现了Queue;
ArrayList底层是数组，查询速度快, LinkedList底层是双向链表，增加和删除速度快;
2)ArrayList的常用方法
List<String> list = new ArrayList<>();
List<String> list = new ArrayList<>(list2/set2); //根据已有的列表或集合来初始化
list.add("java"); //末尾增
list.add(1, "java"); //中间增
list.get(1); //查
list.set(1, "c++"); //改
list.remove(1); //按位置删
list.remove("c++"); //按元素删
list.removeAll(list2/set2); //批量删
list.contains("c++");
list.size();
list.isEmpty();
list.clear(); 
3)遍历ArrayList的三种方式
//通过下标
for(int i = 0; i < list.size(); i++){
	list.get(i);
}
//增强型for循环
for(String item: list){
	//...
}
//迭代器
Iterator<String> it = list.iterator();
while(it.hasNext()){
	it.next();
}
3, Set:
1)set是无序且不可重复的集合;
Set的实现类HashSet和TreeSet, Map的实现类HashMap和TreeMap;
HashSet是基于哈希表实现的，TreeSet是基于二叉树实现的，用于集合元素需要排序的场景;
HashSet的底层是HashMap;
2)HashSet的常用方法
Set<String> set = new HashSet<>();
Set<String> set = new HashSet<>(list2/set2); //根据已有的列表或集合来初始化
set.add("java"); //增
set.remove("java"); //删
set.removeAll(list2/set2); //批量删
set.contains("java");
set.size(); 
set.isEmpty();
set.clear();
3)遍历HashSet的两种方式
增强型for循环和迭代器
4)TreeSet的使用
TreeSet是一个有序的集合, 它支持自然排序和根据实现Comparable或Comparator接口进行排序;
TreeSet<String> set = new TreeSet<>();
TreeSet<Person> set = new TreeSet<>(new PersonComparator()); //通过定义单独的比较器进行排序
set.first(); //第一个元素
set.last(); //最后一个元素
4, Map
1)Map中的数据是以键值对的形式存储的, key-value是Entry类型的对象实例;
Map的实现类HashMap和TreeMap, TreeMap是基于红黑树，用于按键排序的场景;
Map中key的值不可重复，但value的值可以重复;
2)HashMap的常用方法
Map<String, Integer> map = new HashMap<>();
map.put("zhao", 30); //增, 改
map.get("zhao"); //查
map.remove("zhao"); //删
map.containsKey("zhao"); //是否包含指定键
map.containsValue(30); //是否包含指定值
map.size();
map.isEmpty();
map.clear();
3)遍历HashMap的三种方式
//只遍历值
Collection<V> values = map.values();
//通过键的集合遍历
Set<K> keySet = map.keySet();
//通过key-value的集合遍历
Set<Entry<K, V>> entrySet = map.entrySet();
for(Entry<K, V> item: entrySet){
	System.out.println(item.getKey() + ": " + item.getValue()); //调用Entry的方法
}
5, 集合排序
1)由于Set和Map是无序的，所以集合排序只针对List;
数组排序用Arrays.sort(a), 集合排序用Collections.sort(a);
对于自定义类型的排序，需要借助Comparable接口或Comparator接口;
2)自定义类实现Comparable接口
public class Cat implements Comparable<Cat>{
	//...
	@Override
	public int compareTo(Cat o){
		return name.compareTo(o.name);
	}
}
Collections.sort(list); //Arrays类似
3)定义单独的比较器实现Comparator接口
public class AgeComparator implements Comparator<Cat>{
	@Override
	public int compare(Cat o1, Cat o2){
		return o1.age - o2.age;
	}
}
Collections.sort(list, new AgeComparator()); //将比较器的实例对象作为sort()的第二个参数


>>异常处理
1, 异常类的层次
1)Throwable是所有异常类的父类，包括Error和Exception两大子类，常用方法；getMessage()、printStackTrace();
2)Error: 严重错误，应用程序处理不了，常见的有: VirtualMachineError, OutOfMemoryError, ThreadDeath等;
3)Exception: 应用程序能处理的异常，分为检查异常(Checked)和非检查异常(Unchecked);
非检查异常包括RuntimeException以及它的相关子类，常见的有: NullPointerException, ArrayIndexOutOfBoundsException, 
ArithmeticException, ClassCastException, InputMismatchException, NumberFormatException, FileNotFoundException等;
其余异常都是检查异常，编译器要求必须进行处理，常见的有: IOException, SQLException等;
2, 异常处理的5个关键字:
处理异常: try, catch, finally; 抛出异常: throw; 声明异常: throws;
3, 终止finally执行的方法
System.exit(1);
4, throws
public static int test() throws ArithmeticException, InputMismatchException{
	//...
}
当调用test()方法时，可以直接用try/catch来处理异常，也可以由方法调用者继续声明异常类型;
当声明的是非检查异常时，调用时不处理异常编译器不会报错;
5, throw
当在方法内主动throw一个异常时，如果内部不进行处理，可由方法throws该异常，throws的异常必须与抛出的异常相同或者是其父类;
6, 自定义异常
class MyException extends Exception{
	public MyException(){
		super("年龄必须大于18岁");
	}
}
该异常类属于检查异常，编译器必须处理该异常; 如果继承自RuntimeException则为非检查异常;
7, 输出异常信息
e / e.toString(): 异常类型和描述信息，如 java.lang.ArithmeticException: /by zero;
e.getMessage(): 描述信息，如 /by zero;
e.printStackTrace(): 打印异常产生的堆栈信息，包括异常类型、描述信息和出错位置等;
8, 异常链
当前抛出的异常中包含上一层异常的信息;
try{
	test();
}catch(Exception e){
	Exception ex = new Exception("新异常");
	ex.initCause(e);
	throw ex;
	//或直接写成一句: throw new Exception("新异常", e);
}


>>泛型
1, 泛型的作用
提高程序的类型安全、消除强制类型转换;
2, 泛型类
public class NumGeneric<T>{
	private T num;
	//...
}
public class KeyValueGeneric<K, V>{
	//...
}
NumGeneric<Integer> intNum = new NumGeneric<>();
KeyValueGeneric<String, Double> kvObj = new KeyValueGeneric<>();
注: 集合中声明的类型必须与传递的实际类型保持一致，如下这种是错误的
List<Number> list = new ArrayList<Integer>(); //❌
3, 泛型方法
方法的参数或返回值都可以指定泛型;
public <T> void f1(T t){ }
public <T extends Animal> void f2(T t){ }
public <T super Animal> void f3(T t){ }
public void f4(List<?> pets){ } //通配符
public void f5(List<? extends Animal> pets){ }
public void f6(List<? super Animal> pets){ }
4, 继承泛型类
1)子类明确泛型类的参数类型
public interface GenericInterface<T>{ 
	//...
}
public class Demo1 implements GenericInterface<Integer>{
	//...
}
2)子类不明确泛型类的参数类型
public class Demo2<T> implements GenericInterface<T>{
	//...
}


>>注解Annotation
1, 用来对包、类、属性、方法、局部变量、方法参数等元素进行说明和注释的标记;
2, 按照运行机制，分为源码注解、编译时注解、运行时注解;
源码注解: 只在源码中保留，编译时丢弃，如@Override;
编译时注解: 编译时期保留，在JVM加载class文件时丢弃，如@NotNull;
运行时注解: 程序运行时还起作用，甚至会影响程序运行逻辑;
3, 按照来源，分为来自JDK的注解、来自第三方的注解、自定义的注解;
4, 元注解
用来对注解进行说明的注解;


>>设计模式
1, 单例模式
实现:
将构造方法设置为私有; 在类中创建静态私有属性用来保存唯一的实例对象; 提供一个公有的静态方法用于获取静态私有对象;
1)饿汉式: 在类加载时就创建实例, 是线程安全的;
public class Singleton{
	private static Singleton obj = new Singleton();
	private Singleton(){}
	public static Singleton getInstance(){
		return obj;
	}
}
2)懒汉式: 在调用时才创建实例, 存在线程风险;
public class Singleton{
	private static Singleton obj = null;
	private Singleton(){}
	public static Singleton getInstance(){
		if(obj == null){
			obj = new Singleton();
		}
		return obj;
	}
}


>>多线程
1, 进程(process)与线程(thread)
进程是操作系统分配资源的最小单位，线程是程度执行与调度的最小单位，
一个进程一般包含多个线程;
2, Thread类
1)构造方法
Thread();
Thread(String name);
Thread(Runnable target);
Thread(Runnable target, String name);
2)常用方法
run(); //线程执行体, 需要被重写
start(); //启动线程
sleep(long m); //让自己休眠, Thread.sleep(), 使当前线程休眠m毫秒，属于静态方法，并且需要进行异常处理
join()/join(m); //别的线程抢先执行, 调用join()的线程抢占执行, 需要进行异常处理
wait()/wait(m); //让自己等待，需要处理异常
notify(); //唤醒某个正在等待的线程
notifyAll(); //常用, 唤醒所有正在等待的线程
注: 在A线程中调用B.join()方法，只能保证B插队在A之前，而B会和其他线程并发执行;
A: B.join(m)的意思是，A等待B执行m毫秒后再执行;
3, 创建线程的三种方式
1)继承Thread类
class MyThread extends Thread{
	@Override
	public void run(){ //... }
}
MyThread t = new MyThread("java");
t.start();
2)实现Runnable接口
class MyThread implements Runnable{
	private int i = 10;
	@Override
	public void run(){
		while(i > 0){
			System.out.println(Thread.currentThread().getName() + "-" + i);
			i--;
		}
	}
}
MyThread m = new MyThread();
Thread t1 = new Thread(m, "java");
Thread t2 = new Thread(m, "c++");
t1.start();
t2.start();
注: 此时两个线程共享变量i;
Thread.currentThread()返回当前线程;
3)实现Callable接口
此方式的优点是具有返回值，且可以声明并抛出异常;
4, 线程的状态和生命周期
1)五种状态
新建(NEW)、可运行/就绪(RUNNABLE)、正在运行(RUNNING)、阻塞(BLOCKED)、终止(TERMINATED);
2)生命周期
线程的生命周期，就是线程在这五种状态之间的转换过程;
新建: new Thread();
可运行: start();
可运行->正在运行: 获得CPU使用权;
正在运行->可运行: CPU时间片用完/yield();
正在运行->阻塞: join()/wait()/sleep()/IO请求;
阻塞->可运行: 等待调用join()的线程执行完毕/notify()或notifyAll()/sleep时间超时/IO请求完成;
正在运行->终止: 线程执行完毕/异常终止/stop();
5, 线程的优先级
1)优先级分为10个级别, 由低到高用数字1-10表示, 默认为5;
2)常用方法
t.getPriority(); //获取优先级
t.setPriority(n); //设置优先级
注: 优先级高并不能保证一定会优先执行，因为会受到操作系统调度的影响;
6, 线程同步
1)synchronized可以保证共享对象在同一时刻只能被一个线程访问;
2)synchronized关键字可以用在如下地方:
//方法
public synchronized void saveAccount(){}
//语句块
synchronized(obj){}
3)案例: 银行账户存取款线程同步问题
class Bank{ //银行账户类
	private String account;
	private int balance;
	//构造方法、getter/setter、toString方法省略
	public synchronized void save(){ //存钱方法, 用第一种方式同步
		int balance = getBalance();
		balance += 100;
		Thread.sleep(1000); //休眠，省略异常处理
		setBalance(balance);
		System.out.println("存钱后账户余额为: " + balance);
	}
	public void withdraw(){ //取钱方法, 用第二种方式同步
		synchronized(this){
			int balance = getBalance();
			balance -= 200;
			Thread.sleep(1000); //休眠，省略异常处理
			setBalance(balance);
			System.out.println("取钱后账户余额为: " + balance);
		}
	}
}
class SaveAccount implements Runnable{ //存款线程
	Bank bank;
	public SaveAccount(Bank bank){ this.bank = bank; }
	@Override
	public void run(){
		bank.save();
	}
}
class WithdrawAccount implements Runnable{	//取款线程
	Bank bank;
	public WithdrawAccount(Bank bank){ this.bank = bank; }
	@Override
	public void run(){
		bank.withdraw();
	}
}
public class Test{
	public static void main(String[] args){
		Bank bank = new Bank("1001", 1000);
		Thread t1 = new Thread(new SaveAccount(bank));
		Thread t2 = new Thread(new WithdrawAccount(bank));
		t1.start();
		t2.start();
		try{
			t1.join();
			t2.join();
		}catch(InterruptedException e){
			e.printStackTrace();
		}
		System.out.println("账户余额为: " + bank.getBalance());
	}
}
7, 线程间通信
1)通过wait()和notifyAll()/notify()来实现进程间通信;
2)案例: 生产者消费者线程通信
class Box{ //商品容器类, 容器里只放一件商品
	private int n; //商品的序号
	private boolean flag = false; //false表示无商品，true表示有商品
	public synchronized int get(){ //消费
		if(!flag){ //容器空则等待
			try{
				wait();
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
		System.out.println("消费: " + n);
		this.flag = false;
		notifyAll(); //唤醒等待的其他进程(如生产者进程)
		return n;
	}
	public synchronized void set(int n){ //生产
		if(flag){ //容器满则等待
			try{
				wait();
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
		System.out.println("生产: " + n);
		this.n = n;
		this.flag = true;
		notifyAll(); //唤醒等待的其他进程(如消费者进程)
	}
}
class Producer implements Runnable{ //生产者进程
	Box box;
	public Producer(Box box){ this.box = box; }
	@Override
	public void run(){
		int i = 1;
		while(true){
			box.set(i++);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
class Consumer implements Runnable{ //消费者进程
	Box box;
	public Consumer(Box box) {
		this.box = box;
	}
	@Override
	public void run() {
		while(true) {
			box.get();
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
public class Test{
	public static void main(String[] args){
		Box box = new Box();
		Thread t1 = new Thread(new Producer(box));
		Thread t2 = new Thread(new Consumer(box));
		t1.start();
		t2.start();
	}
}


>>输入输出流
1, File类
1)常用方法
File f = new File("E:/demo/test.txt");
File f = new File("E:/demo", "test.txt");
f.exists();
f.isDirectory();
f.isFile();
f.mkdir()/f.mkdirs(); //创建单级目录/多级目录
f.createNewFile(); //创建文件, 需要处理IOException异常
f.delete(); //删除目录或文件
f.getPath(); //返回路径, 与创建File时传入的参数相同
f.getAbsolutePath(); //返回绝对路径
f.getParent(); //返回父级目录
f.getName(); //返回文件名/目录名
f.length(); //文件大小，以字节为单位
2)绝对路径与相对路径
从盘符开始的路径为绝对路径, 从当前路径开始的路径为相对路径;
java文件所在的目录即为当前路径, eclipse较为特殊，当前路径为当前工程的目录;
2, 字节流(InputStream/OutputStream)
1)文件输入流 FileInputStream
FileInputStream fis = new FileInputStream(f); //需要处理FileNotFoundException异常
FileInputStream fis = new FileInputStream("demo/test.txt");
byte[] b;
fis.read(); //读入一个字节, 返回读取的字节值, -1表示到达文件末尾
fis.read(b); //从输入流中读数据存放到b中, 返回一共读取了多少个字节, 返回-1也表示文件末尾
fis.read(b, offset, len); //从数组b的offset位置开始存放，最多放len个字节
fis.close(); //关闭输入流
注: read()与read(b)的返回值是不同的;
举例: 按字节读取文件内容
int n = 0;
while((n=fis.read()) != -1){
	System.out.print((char)n);
}
或
byte[] b = new byte[100];
fis.read(b);
System.out.println(new String(b));
2)文件输出流 FileOutputStream
FileOutputStream fos = new FileOutputStream(f);
FileOutputStream fos = new FileOutputStream("demo/test.txt", true); //第二个参数true表示追加，false表示覆盖
fos.write(n/'a'); //将指定字节写到文件
fos.write(b); //将字节数组b的内容写到文件
fos.write(b, offset, len); //将字节数组从offset位置开始的len个字节写到文件
fos.close(); //关闭输出流
注: 字节流一般用于处理二进制文件如图片, 文本文件更应该用字符流来处理;
举例: 复制图片文件
FileInputStream fis = new FileInputStream("bing.jpg");
FileOutputStream fos = new FileOutputStream("bing2.jpg");
int n = 0;
byte[] b = new byte[1000]; //大小随便取
while((n=fis.read(b)) != -1){ //边读边写
	fos.write(b, 0, n); //保证复制后图片与原图片大小一致
}
fis.close();
fos.close();
3)缓冲输入输出流 BufferedInputStream/BufferedOutputStream
文件输入输出流是与硬盘交互数据，速度较慢，而缓冲输入输出流是从内存读取数据，速度很快;
过程: CPU-内存缓冲区-其他输入输出流(如硬盘文件);
构造缓冲输入输出流的参数是输入输出流的子类, 如
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("test.txt"));
bos.write(b);
缓冲输入输出流的常用方法与文件输入输出流相同;
注: 缓冲输出流, 当缓冲区未满则不会自动写数据，必须调用bos.flush()或bos.close()才会写数据;
3, 字符流 (Reader/Writer)
1)字节字符转换流 InputStreamReader/OutputStreamWriter
举例:
InputStreamReader isr = new InputStreamReader(new FileInputStream("test.txt")); //流的连接
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("test2.txt"));
//第一种方式: 一个一个读
int n = 0;
while((n = isr.read()) != -1){
	System.out.print((char)n);
}
//第二种方式: 读入到字符数组，并将文件拷贝
char[] c = new char[10];
while((n = isr.read(c)) != -1){
	String s = new String(c, 0, n); //一定要保持精确
	System.out.print(s);
	osw.write(s);
	osw.flush();
}
注: OutputStreamWriter输出时记得flush()刷新并close()关闭;
2)文件字符输入输出流 FileReader/FileWriter
FileReader fr = new FileReader("test.txt");
FileWriter fw = new FileWriter("test.txt");
常用方法同文件字节流，把byte[]数组换成char[]数组;
3)缓冲字符输入输出流 BufferedReader/BufferedWriter
BufferedReader br = new BufferedReader(fr);
BufferedWriter bw = new BufferedWriter(fw);
常用方法与缓冲字节流类似;
BufferedReader提供了readLine()方法一次可以读取一行字符串, 
String s = null;
while((s = br.readLine()) != null){
	//todo s
}
4, 对象的序列化
1)序列化与反序列化, 就是java对象和字节序列之间转换的过程;
步骤: 创建一个类继承Serializable接口->创建对象->将对象写入文件(或网络传输)/从文件读取对象;
对象读写涉及两个类: ObjectInputStream/ObjectOutputStream;
2)举例
class Cat implements Serializable{....}
Cat cat1 = new Cat("zhao", 30);
FileInputStream fis = new FileInputStream("bing.jpg");
FileOutputStream fos = new FileOutputStream("bing2.jpg");
ObjectInputStream ois = new ObjectInputStream(fis);
ObjectOutputStream oos = new ObjectOutputStream(fos);
oos.writeObject(cat1); //把对象序列化到文件
oos.writeObject(null); //作为结束标记
oos.flush();
Cat cat = (Cat)ois.readObject(); //从文件反序列化到对象







