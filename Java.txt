>>jvm, jre和jdk
1，java程序的执行分为两个过程: 
编译(源程序.java->字节码文件.class)和解释执行(jvm)，jvm依赖于具体的平台，是实现java跨平台的基础；
2，jre = jvm + 标准类库,
jdk = jre + 开发工具集;
3，jdk中的两个组件javac(编译器)和java(虚拟机);
javac.exe和java.exe包含在bin目录下，安装jdk后需要把该目录添加到环境变量中，如在环境变量的path中添加
D:\Java\jdk1.8.0_261\bin;
4, 命令行运行java程序:
javac Hello.java
java Hello


>>eclipse for J2EE
1, 安装eclipse后要添加安装的jre，方法: Window->Preferences->jre，选择对应版本即可;
2, 打开eclipse时会提示设置工作目录，如E:\Java\workspace, 工作目录可通过File->Switch Workspace进行切换;
3, 新建工程test后，源文件放在E:\Java\workspace\test\src目录下，编译生成的字节码文件放在E:\Java\workspace\test\bin目录下;
4, 可通过Window->Preferences进行个性化设置，通过Window->Show View设置当前打开哪些子窗口；
5, test工程右键->Resource->encoding设置程序的编码，有时导入源码中出现中文乱码可通过这种方式解决;
也可通过Window->Preferences->encoding进行编码的设置;
6, 调试默认快捷键
F6-单步调试, F8-直接跳到下一个断点, F5-进入函数, F7-跳出函数;
7, 按 alt+/ 可出现智能提示;
8, 将tomcat整合到eclipse中，具体方法百度, 注意要设置Server path为tomcat的安装目录, Deploy path为tomcat下的webapps目录;


>>idea
1, 普通java工程
1)创建java工程
New -> Project -> Java -> 输入工程名;
2)java工程的目录结构
Test
	src //源代码目录
	out //编译后的文件存放目录
	lib //第三方jar包存放目录
3)将普通java工程打成jar包
File -> Project Structure -> Artifacts -> + -> JAR(Empty) -> 填写包名如demo 
	-> 点击demo.jar -> Create Manifest(选择工程目录) -> 双击右侧编译后的工程选入左侧 
	-> 设置Main Class(入口类)
	-> Build菜单 -> Build Artifacts;
然后可以看到 out/artifacts/demo/demo.jar, 打包完成;
运行jar包的方法: 进入jar包所在的目录, cmd进入控制台, 在控制台输入: java -jar demo.jar, 就可以成功运行;
2, java web工程
1)创建java web工程
New -> Project -> Java Enterprise -> 勾选Web Application -> 输入工程名 -> 新建完成;
点击 Edit Configurations 进入配置页面，在Server页面更改On frame deactivation选择热部署,
在Deployment页面修改Application context为 "/demo";
2)java web工程的目录结构
Test
	src //源代码目录
	out //编译后的文件存放目录
	lib //第三方jar包存放目录
	web //web目录
		WEB-INF	
			web.xml
		index.jsp
3)将web工程打成war包
File -> Project Structure -> Artifacts -> + -> Web Application:Archive(Empty) -> 填写包名如demo
	-> 点击demo.war -> 双击右侧编译后的工程和web资源文件将其选入左侧
	-> Build菜单 -> Build Artifacts;
然后就可以看到 out/artifacts/demo/demo.war, 打包完成;
运行war包的方法: 将war包复制到tomcat的webapps目录下, 点击bin/startup.bat启动tomcat, 就可以在浏览器中进行访问;
3, 引入jar包
新建lib目录, 将需要的jar包放在lib目录下, 然后通过将jar包引入到工程依赖，方法为: 
File -> Project Structure -> Modules -> Dependencies -> + -> JARS, 将jar包引入;


>>外网的jar包网页打不开的解决方案
通过阿里云的文件仓库下载: maven.aliyun.com
注: apache的核心maven仓库: search.maven.org


>>基本语法
1, 标识符可包含字母、数字、_和$，不能以数字开头，区分大小写，不能为关键字和保留字;
2, 目前java有50个关键字，2个保留字(goto、const);
3, 项目名首字母小写，类名首字母大写，变量名和方法名首字母小写，都遵循驼峰命名法;
4, 变量的三个要素: 变量类型、变量名、变量值;
5, 变量的分类:
按数据类型分: 基本类型、引用类型；
按作用范围分: 类级变量、实例级变量、方法级变量(局部变量)、块级变量;
6, 编码
ascii码: 用1个字节表示字母数字及常用符号;
标准ascii码: 7位，表示128个字符;
扩展ascii码: 8位，表示256个字符;
unicode码: 用两个字节表示全世界所有的字符;
char c = '\u005d';
String s = "A\u00d2\u02a8B";
7, 字符集
utf-8: 英文用1个字节，中文用3个字节;
gbk: 英文用1个字节，中文用2个字节;
utf-16be: 所有字符都用2个字节;
8，常量用final修饰，常量的命名全部用大写，多个单词之间用_分隔，这与变量不同，如
int minValue = -100;
final int MIN_VALUE = -100;
9, 运算符
算术运算符、赋值运算符、关系运算符、逻辑运算符、条件运算符、位运算符;
10, &&与&都是逻辑与运算符，前者是短路逻辑，||与|类似;
11, 局部变量在使用前一定要初始化，否则会报错;
12, 包
包的作用: 管理java的类，以及防止类的命名冲突;
包的命名采用: 域名倒序.项目.模块.功能, 如 pacakge com.imooc.animal;
加载某个包里的所有类: import com.imooc.animal.*;
加载某个包里的特定类: import com.imooc.animal.Cat;
注: import 包名.* 只能导入指定包名下所有直接允许访问的类, 无法导入其子包中的类;


>>数据类型
1, 分类
1)基本类型
	数值型
		整数类型: byte(1), short(2), int(4), long(8);
		浮点类型: float(4), double(8);
	字符型: char(2);
	布尔型: boolean(1);
2)引用类型
类(class)、接口(interface)、数组;
2，long类型字面量后要加L，float类型字面量后要加f, 如
long a = 123L;
float b = 1.23f;
3, 二进制加前导0b，八进制加前导0，十六进制加前导0x, 如
int a = 12;
int b = 0b1011;
int c = 012;
int d = 0x12;
4, 类型转换
1)自动转换(隐式转换)
小类型可以自动转换为大类型，不会丢失精度, 如
long a = 100;
double b = 1.23f; 
char c = 65;
2)强制转换(显式转换)
大类型转换为小类型，需要经过强制转换店，如
int a = (int)100L;
float b = (float)1.23;
char c = (char)65536;
注: char用2个字节表示，范围为0~65535, 超过这个表示范围需要使用强制转换;
5, 不同基本类型的数值比较，只要值相等，==就返回true;
10L == 10.0; //true
'a' == 97; //true


>>数组
1，数组的定义
//一维数组
int[] a = new int[10];
int[] b = {1, 2, 3, 4, 5};
int[] c = new int[]{1, 2, 3, 4, 5};
//二维数组
int[][] a = new int[3][4]; 
int[][] b = new int[3][];  //必须指定第一维的长度
int[][] c = {{1}, {2, 3}, {4, 5, 6}}; //第二维的长度可以不同
注: 与局部变量不同，数组中的元素都有默认初始值;
2, 增强型for循环
int[] a = {1, 2, 3, 5, 8};
for(int item: a){
	//...
}
注: 如果数组a为null，此时增强for循环会抛出NullPointerException空指针异常;
3, 双重循环的写法(如冒泡排序)
外层循环表示次数，内层循环表示每次遍历;
for(int i = 0; i < a.length-1; i++){ //a.length-1次
	for(int j = 0; j < a.length-1-i; j++){ //沉底
		//...
	}
	for(int j = a.length-1; j > i; j--){ //冒泡
		//...
	}
}
4, 数组的排序
Arrays.sort(a);


>>方法
1, 给主方法main传递参数
1)命令行中
javac Hello.java
java Hello zhao 30
2)Eclipse中
Run->Run Configurations->Arguments中填入参数;
2, 按值传参
方法是按值传参的，如果是基本类型数据则不会改变，而引用类型数据里的字段值会改变;
数组名是指向数组第一个元素的引用，所以传递数组，会改变数组元素的值;
3, 方法重载
方法的参数个数或参数的类型不同, 称为方法重载，如
int sum(int a, int b);
float sum(float a, float b, float c);
int sum(int[] a);
4, 可变参数
1)int sum(int... a){
	//a是实参组成的数组
}
实参可以是可变参数，也可以是数组; 
当有多个形参时，可变参数必须放在最后;
2)含可变参数的方法可以与具体参数的方法重载，优先调用具体参数的方法，如
int sum(int... a){}
int sum(int a, int b){}
当调用sum(1, 2)时，优先调用第二个方法;


>>面向对象
1, 面向对象的三大特征: 
封装, 继承, 多态;
2, 类和对象的基本语法
1)与局部变量不同，类的属性会有默认初始值;
2)单一职责原则: 一个类只完成一个功能，即高内聚，低耦合;
3)对象实例的引用, 输出的值形如 com.imooc.animal.Cat@4926097b;
4)如果没有定义构造函数，系统会提供一个默认的无参构造函数，如果显式定义了构造函数，则不会提供默认构造函数;
5)构造函数只能在构造函数之间相互调用且必须出现在第一行，不允许在别的地方显式调用;
public Cat(){
	//...
}
public Cat(String name){
	this();
	this.name = name;
}
public Cat(String name, int age){
	this(name);
	this.age = age;
}
6)内存的划分: 栈、堆、常量池;
栈中存放一些局部变量, 如基本数据类型变量、对象的引用等, 当局部变量作用范围结束时, 栈内信息自动释放;
堆中存放动态数据, 如new出来的对象, 当无实例引用指向堆中数据时，垃圾回收机制才会释放堆空间;
如 Cat one = new Cat(); 分为两部分:
对象声明 Cat one, 在栈空间;
对象实例化 new Cat(), 在堆空间;
7)封装
隐藏对象的信息，提供访问的接口;
封装的实现有三步:
修改属性的可见性为private；
创建公开的getter/setter方法用于属性的读写;
在getter/setter方法中对属性的合法性进行判断;
8)static
静态成员，又叫类成员，包括静态属性和静态方法, 是属于类的，只在类加载时初始化一次，存续时间较长;
静态成员可以通过类名.静态成员或对象.静态成员这两种方式访问，推荐用前者;
静态方法里面只能访问静态成员，而非静态方法既可以访问非静态成员，也可以访问静态成员;
注: java中没有静态局部变量;
注: static方法只能被子类继承，不能被子类重写;
9)代码块
静态代码块: 
只在类加载时执行一次，不能在静态代码块中直接访问非静态成员;
构造代码块:
每次实例化对象时都会执行，在构造方法之前调用;
普通代码块:
在方法体内用{}括起来的一段代码块;
注: java有块作用域，在代码块中定义的变量，外部无法访问;
10)类的组成要素及初始化顺序
静态属性、静态代码块、静态方法、实例属性、构造代码块、构造方法、实例方法, 初始化顺序编号如下: 
public class Cat{
	private String name = "小猫";  //3
	public static int price = 100;  //1
	static{  //2
		System.out.println("静态代码块...."):
	}
	{  //4
		System.out.println("构造代码块....");
	}
	public Cat(){  //5
		System.out.println("构造方法....");
	}
	public String getName(){
		return name;
	}
	public void setName(String name){
		this.name = name;
	}
	public void changePrice(int price){
		Cat.price = price;
	}
}
11)访问修饰符 
(默认): 本包(√);
protected: 本包(√), 跨包子类(√);
按可见性由大到小排列: public > protected > (默认) > private;
12)final
final作用于类, 表示类不能被继承;
final作用于方法，表示方法不能被重写;
final作用于属性，表示常量;
3, 继承
1)java只支持类的单继承，但可以实现多个接口，接口之间也可以多继承;
2)方法重写
子类方法的参数数量和类型要与父类一致, 如果不一致就属于方法重载;
子类方法访问修饰符的可见性必须大于等于父类方法;
子类方法的返回值要么与父类相同，要么是父类方法返回值的子类;
子类方法抛出的异常类型要么与父类相同，要么是父类方法抛出的异常类型的子类;
3)super
子类中调用父类的方法;
super(name, age); //调用父类的构造方法, 必须出现在第一行
super.name; //调用父类的属性
super.eat(); //调用父类的方法
4)子类的构造方法如果没有显式调用父类的构造方法，则默认调用父类的无参构造方法;
因为无参构造方法会被子类默认调用，所以一般情况下定义类时记得加上无参构造方法;
5)继承的初始化顺序
父类的静态属性初始化->父类的静态代码块->
子类的静态属性初始化->子类的静态代码块->
父类的实例属性初始化->父类的构造代码块->父类的构造方法->
子类的实例属性初始化->子类的构造代码块->子类的构造方法;
6)程序编译出错不一定导致运行出错，如果程序运行时不执行出错代码，则也能运行正常;
class Animal{
	private String name;
	public Animal(String name){ this.name = name; }
}
class Cat extends Animal{
	private int age;
	public Cat(){} //此处编译出错
	public Cat(Sting name, int age){ super(name); this.age = age; }
}
public class Test{
	Cat cat = new Cat("花花", 5); 
}
由于父类没有定义无参构造方法，所以编译出错，但并不影响运行结果;
4, 多态
1)不同对象对同一消息做出不同的反应;
多态要满足三个条件: 满足继承关系; 要有重写; 父类引用指向子类对象;
多态 = 向上转型 + 动态绑定;
2)向上转型
也叫隐式转型、自动转型，将子类转换为父类;
Animal one = new Cat();
3)向下转型
也叫显式转换、强制转换, 向下转型是为了重新获得因为向上转型而丢失的子类特性, 通常结合instanceof一起使用;
((Cat)one).run();
注: 子类实例向上转型后，就不能再调用子类特有的方法了，必须再向下转型后才能调用;
4)instanceof
Animal one = new Cat();
one instanceof Animal; //true
one instanceof Cat; //true
one instanceof Dog; //false
5)多态的应用举例
public class Master{
	public void feed(Animal obj){
		obj.eat();
		if(obj instanceof Cat){
			((Cat)obj).run();
		}else if(obj instanceof Dog){
			((Dog)obj).sleep();
		}
	}
	public Animal select(int type){
		if(type == 1){
			return new Cat();
		}else{
			return new Dog();
		}
	}
}
5, 抽象类
1)抽象类不能直接实例化; 子类需要重写抽象父类的抽象方法，否则子类也是抽象类;
public abstract class Animal{
	public abstract void eat();
}
2)abstract不能与final、static、private一起使用;
6, 接口
1)继承一个类的同时可以实现多个接口
public class FourthPhone extends ThirdPhone implements IPhoto, INet{
	//...
}
ThirdPhone phone1 = new FourthPhone();
phone1.message(); //从父类继承的方法;
IPhoto phone2 = new FourthPhone();
phone2.photo(); //从接口IPhoto实现的方法;
INet phone3 = new FourthPhone();
phone3.network(); //从接口INet实现的方法
2)实现类需要实现接口里的所有抽象方法, 否则实现类就是抽象类;
interface IAnimal{
	void run();
	void eat();
}
abstract class Pet implements IAnimal{ //未实现接口的全部方法，所以定义为抽象类
	@Override 
	public void run(){
		System.out.println("Pet can run...");
	}
}
class Cat extends Pet{ //继承抽象类，实现抽象方法
	@Override
	public void eat(){
		System.out.println("Cat can eat...");
	}
}
3)接口中的方法默认是 public abstract, 接口中的常量默认是 public static final;
interface IAnimal{
	String NATION = "China";
	void eat();
}
4)接口中的组成要素
抽象方法、常量、默认方法、静态方法;
interface IAnimal{
	String NATION = "China"; //常量, 默认是 public static final
	void eat(); //抽象方法, 默认是 public abstract
	public default void run(){ //默认方法
		//...
	}
	public static void sleep(){ //静态方法
		//...
	}
}
class Cat implements IAnimal{
	@Override
	public void eat(){ //必须实现抽象方法
		//...
	}
	@Override
	public void run(){ //是否重写默认方法可选
		IAnimal.super.run();
		//...
	}
}
注: 重写默认方法时不用加default, 实现类中调用接口的默认方法用 接口名.super.方法名 的格式;
静态方法不能被重写, 只能通过 接口名.方法 的格式调用接口的静态方法;
5)当接口和父类中含有同名方法或同名常量/变量时
如果只实现两个接口，则必须重新定义该同名方法;
如果继承父类的同时实现两个接口，则优先调用父类的同名方法;
与父类的方法优先不同，父类的变量与接口的常量如果同名，则地位相同，必须显式指定调用哪一个，如
super.name, IPhoto.name, INet.name, 或者在子类中重新定义该变量;
6)接口的继承
public interface IHuman extends ITalk, IWork{}
7)接口的继承与类的继承两者的区别
类只能单继承, 而接口可以多继承;
类可以继承静态方法, 但不能重写, 接口不能继承静态方法;
8)接口与抽象类
抽象类是对类的抽象，是一种模板设计;
接口是对行为的抽象，是一种行为规范;
7, 内部类
成员内部类、静态内部类、方法内部类、匿名内部类;
1)成员内部类
public class Person{
	int age;
	public Heart getHeart(){ //获取内部类
		return new Heart();
	}
	class Heart{ //内部类
		public void fn(){
			return age + "岁的心脏在跳动"; //等价于 Person.this.age
		}
	}
}
获取成员内部类的几种方式:
方式1: new 外部类.new 内部类
Person.Heart h = new Person().new Heart();
方式2: 外部类对象.new 内部类
Person p = new Person();
Person.Heart h = p.new Heart();
方式3: 外部类对象.获取方法
p.getHeart();
注: 内部类可以直接访问外部类的属性和方法, 或者通过 外部类.this.成员 的方式来访问外部类的成员;
编译后生成的两个文件: Person.class 和 Person$Heart.class;
2)静态内部类
在内部类前加static修饰符就成为静态内部类;
获取静态内部类: Person.Heart h = new Person.Heart();
调用静态内部类里的静态成员: Person.Heart.静态成员;
静态内部类里访问外部静态成员: Person.静态成员;
静态内部类里访问外部实例成员: new Person().实例成员;
编译后生成的文件同成员内部类;
3)方法内部类
public class Car{
	public void run(){
		class Engine{
			public void run(){
				//...
			}
		}
		Engine engine = new Engine();
		return engine.run();
	}
}
编译后生成的两个文件: Car.class 和 Car$1Engine.class;
4)匿名内部类
没有类名, 通常用来实现一个抽象类或者接口;
public abstract class Transport{
	public abstract void run();
}
Transport car = new Transport(){
	public void run(){
		System.out.println("汽车会跑");
	}
};
Transport airplane = new Transport(){
	public void run(){
		System.out.println("飞机会飞");
	}
};
编译后生成的字节码文件: Transport.class, Transport$1.class, Transport$2.class;
5)应用场景
成员内部类: 
当两个类A和B彼此之间需要相互访问，且B只在A的某种特定应用中才需要，可以将B设置为A的成员内部类;
静态内部类:
当类A需要使用类B，而B并不需要直接访问外部类A的成员，可以将B设置为A的静态内部类;
方法内部类:
类只在方法内使用，相当于一次性产品，使用场景较少;
匿名内部类:
多用于作为方法参数或返回值;


>>JavaBean
符合下列规范的类，就是一个JavaBean;
1)具有一个公有的无参构造函数;
2)所有属性都是private;
3)具有公有的getter/setter方法对私有属性进行读写;
4)这个类是可序列化的;


>>枚举
enum Week{MONDAN, TUESDAY, WEDNESDAY, THURDAY, FRIDAY, SATURDAY, SUNDAY}
枚举的访问: Week.MONDAY;
Week wk = Week.MONDAN;
枚举可以定义在类的内部、类的外部，也可以定义在单独的类中，但不能定义在方法中;


>>Object类
java.lang.Object是所有类的父类, Object类中有几个方法经常需要被重写, 如hashCode(), equals(), toString();
equals()默认比较的是两个对象的地址是否相同;
判断两个对象是否相同，首先比较hashCode, 再通过equals()方法比较，如果hashCode不同则两个对象不相同;
toString()默认返回的对象引用的描述，如 com.imooc.animal.Cat@4926097b;
public class Animal{
	private String name;
	private int age;
	public Animal(){}
	public Animal(String name, int age){ this.name = name; this.age = age; }
	@Override
	public int hashCode(){
		return this.name.hashCode();
	}
	@Override
	public boolean equals(Object obj){
		if(obj == null) return false;
		if(obj == this) return true;
		if(getClass() != obj.getClass()) return false;
		Animal temp = (Animal)obj;
		if(name.equals(temp.name) && age==temp.age) return true;
		return false;
	}
	@Override
	public String toString(){
		return "Animal[name=" + name + ", age=" + age + "]";
	}
}


>>System类
System.in; //系统输入
System.out; //系统输出
System.exit(n); //程序终止, n表示状态
System.gc(); //垃圾回收
System.currentTimeMillis(); //返回从1970年到现在的毫秒数，常用于程序计时


>>Scanner类
1, 实例化如从控制台输入
Scanner sc = new Scanner(System.in);
2, 常用输入方法
sc.next(); //输入字符串，以空格结束
sc.nextLine(); //输入字符串，以换行符结束
sc.nextInt()/nextFloat()/nextDouble();


>>包装类
1, 基本数据类型对应的包装类
byte-Byte, short-Short, int-Integer, long-Long,
float-Float, double-Double, 
char-Character, 
boolean-Boolean;
其中, Byte, Short, Integer, Long, Short, Double都继承自Number;
2, 装箱 / 拆箱
//装箱: 基本类型->包装类
int i = 6;
Integer o1 = i; //自动装箱, 底层实现为 Integer.valueOf(i)
Integer o2 = new Integer(i); //手动装箱
Integer o3 = Integer.valueOf(i); //手动装箱
//拆箱: 包装类->基本类型
int i1 = o1; //自动拆箱, 底层实现为 o1.intValue()
int i2 = o1.intValue(); //手动拆箱
3, 基本类型与字符串之间的转换
//基本类型->字符串:
int i = 12;
String s1 = "" + i; //1
String s2 = Integer.toString(i); //2
String s3 = String.valueOf(i); //3
//字符串->基本类型
String s = "12";
int i1 = Integer.parseInt(s); //1
int i2 = Integer.valueOf(s); //
4, 包装类的比较
java在几种包装类中提供了缓存设计，会对一定范围内的数据做缓存，优先从缓存中取数据，超出范围才创建新对象;
Byte、Short、Integer、Long缓存[-128, 127]区间的数据;
Character缓存[0, 127]区间的数据;
Boolean缓存true和false;
Float和Double不支持缓存;
Integer i1 = 65;
Integer i2 = 65;
i1 == 65; //true
i1 == 'A'; //true
i1.equals(65); //true
i1.equals(65.0f); //false
i1.equals('A'); //false
Integer i3 = 200;
Integer i4 = 200;
i3 == i4; //false
Float f1 = 100.0f;
Float f2 = 100.0f; 
f1 == f2; //false
注: equals()方法首先比较类型是否相同，如果类型不同，则直接返回false;

>>字符串
1, String
1)创建
String s1 = "hello";
String s2 = new String("hello");
char[] ch = {'h', 'e', 'l' ,'l', 'o'};
String s3 = new String(ch);
String s3 = new String(ch, 1, 3); //从位置1开始的3个元素
byte[] b = {104, 101, 108, 108, 111};
String s4 = new String(b);
String s4 = new String(b, 1, 3); 
String s4 = new String(b, "utf-8"); //使用字节数组时可以指定字符集
2)常用方法
s.length(); 
s.charAt(2);
s.indexOf('o')/s.IndexOf("lo")/s.indexOf('o', 2); //可传入字符或者字符串，没找到则返回-1
s.lastIndexOf('o')/s.lastIndexOf("lo")/s.lastIndexOf('o', 2);
s.substring(3, 6)/s.substring(3); //参数为开始位置和结束位置的下一位置，省略则表示一直取到末尾
s.trim();
s.toLowerCase()/s.tuUpperCase();
s.split(" "); //按指定分隔符切割成字符串数组
s.getBytes()/s.getBytes("gbk"); //字节数组
3)字符串的比较
String s1 = "hello", s2 = "hello", s3 = new String("hello"), s4 = new String("hello");
s1 == s2; //true, 常量池
s3 == s4; //false
s1+"hi" == s2+"hi"; //false
s3.equals(s4); //true
字符串的相等性比较一定要用s1.equals(s2);
4)字符串的不可变性
2, StringBuilder / StringBuffer
1)String不可修改，而StringBuilder可以动态修改, 适用于字符串被频繁操作的场景;
StringBuffer是线程安全的, 但StringBuilder的效率更高;
2)StringBuilder与String的转换
StringBuilder sb = new StringBuilder("hello");
String s = sb.toString();
3)常用方法
StringBuilder除了拥有部分String类的方法，如length(), charAt(), indexOf()/lastIndexOf(), substring()等，还有: 
sb.capacity(); //容量
sb.append("hi"); //在末尾添加
sb.insert(2, "hi"); //在中间插入
sb.delete(2, 5); //删除, 参数为起始位置和结束位置的下一位置
sb.replace(2, 5, "hi"); //替换
sb.reverse(); //反转


>>日期时间
String、java.util.Date、java.sql.Date之间的转换:
s(String), udDate(java.util.Date), sdDate(java.sql.Date);
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
1, s->udDate
udDate = sdf.parse(s);
2, udDate->s
s = sdf.format(udDate);
3, sdDate->udDate
udDate = sdDate;
4, udDate->sdDate
long timestamp = udDate.getTime();
sdDate = new java.sql.Date(timestamp);
注: java.sql.Date是java.util.Date的子类，子类到父类可以自动转换，而从父类到子类不能自动转换;
注: 从键盘输入的字符串格式保存到数据库中的日期，需要通过两部: 
String->java.util.Date->java.sql.Date;


>>集合
1, 集合框架的层次:
两大接口: Collection和Map, Collection有三个子接口: List、Queue、Set; 
注: 集合中只能存储引用数据类型的元素, 可以存储不同类型的数据，除非加上泛型进行限定;
集合适合于无法预测元素的数量、经常对数据进行增删、不允许数据重复、存储具有一对一关系的数据等场景;
2, List:
1)list是有序且可重复的列表;
List的实现类ArrayList和LinkedList, LinkedList同时实现了Queue;
ArrayList底层是数组，查询速度快, LinkedList底层是双向链表，增加和删除速度快;
2)ArrayList的常用方法
List<String> list = new ArrayList<>();
List<String> list = new ArrayList<>(list2/set2); //根据已有的列表或集合来初始化
List<String> list = Arrays.asList("zhao", "qian", "sun"); //快速初始化
list.add("java"); //末尾增
list.add(1, "java"); //中间增
list.get(1); //查
list.set(1, "c++"); //改
list.remove(1); //按位置删
list.remove("c++"); //按元素删
list.removeAll(list2/set2); //批量删
list.contains("c++");
list.size();
list.isEmpty();
list.clear(); 
3)遍历ArrayList的三种方式
//通过下标
for(int i = 0; i < list.size(); i++){
	list.get(i);
}
//增强型for循环
for(String item: list){
	//...
}
//迭代器
Iterator<String> it = list.iterator();
while(it.hasNext()){
	it.next();
}
3, Set:
1)set是无序且不可重复的集合;
Set的实现类HashSet和TreeSet, Map的实现类HashMap和TreeMap;
HashSet是基于哈希表实现的，TreeSet是基于二叉树实现的，用于集合元素需要排序的场景;
HashSet的底层是HashMap;
2)HashSet的常用方法
Set<String> set = new HashSet<>();
Set<String> set = new HashSet<>(list2/set2); //根据已有的列表或集合来初始化
set.add("java"); //增
set.remove("java"); //删
set.removeAll(list2/set2); //批量删
set.contains("java");
set.size(); 
set.isEmpty();
set.clear();
3)遍历HashSet的两种方式
增强型for循环和迭代器
4)TreeSet的使用
TreeSet是一个有序的集合, 它支持自然排序和根据实现Comparable或Comparator接口进行排序;
TreeSet<String> set = new TreeSet<>();
TreeSet<Person> set = new TreeSet<>(new PersonComparator()); //通过定义单独的比较器进行排序
set.first(); //第一个元素
set.last(); //最后一个元素
4, Map
1)Map中的数据是以键值对的形式存储的, key-value是Entry类型的对象实例;
Map的实现类HashMap和TreeMap, TreeMap是基于红黑树，用于按键排序的场景;
Map中key的值不可重复，但value的值可以重复;
2)HashMap的常用方法
Map<String, Integer> map = new HashMap<>();
map.put("zhao", 30); //增, 改
map.get("zhao"); //查
map.remove("zhao"); //删
map.containsKey("zhao"); //是否包含指定键
map.containsValue(30); //是否包含指定值
map.size();
map.isEmpty();
map.clear();
3)遍历HashMap的三种方式
//只遍历值
Collection<V> values = map.values();
//通过键的集合遍历
Set<K> keySet = map.keySet();
//通过key-value的集合遍历
Set<Entry<K, V>> entrySet = map.entrySet();
for(Entry<K, V> item: entrySet){
	System.out.println(item.getKey() + ": " + item.getValue()); //调用Entry的方法
}
5, 集合排序
1)由于Set和Map是无序的，所以集合排序只针对List;
数组排序用Arrays.sort(a), 集合排序用Collections.sort(a);
对于自定义类型的排序，需要借助Comparable接口或Comparator接口;
2)自定义类实现Comparable接口
public class Cat implements Comparable<Cat>{
	//...
	@Override
	public int compareTo(Cat o){
		return name.compareTo(o.name);
	}
}
Collections.sort(list); //Arrays类似
3)定义单独的比较器实现Comparator接口
public class AgeComparator implements Comparator<Cat>{
	@Override
	public int compare(Cat o1, Cat o2){
		return o1.age - o2.age;
	}
}
Collections.sort(list, new AgeComparator()); //将比较器的实例对象作为sort()的第二个参数


>>异常处理
1, 异常类的层次
1)Throwable是所有异常类的父类，包括Error和Exception两大子类，常用方法；getMessage()、printStackTrace();
2)Error: 严重错误，应用程序处理不了，常见的有: VirtualMachineError, OutOfMemoryError, ThreadDeath等;
3)Exception: 应用程序能处理的异常，分为检查异常(Checked)和非检查异常(Unchecked);
非检查异常包括RuntimeException以及它的相关子类，常见的有: NullPointerException, ArrayIndexOutOfBoundsException, 
ArithmeticException, ClassCastException, InputMismatchException, NumberFormatException, FileNotFoundException等;
其余异常都是检查异常，编译器要求必须进行处理，常见的有: IOException, SQLException等;
2, 异常处理的5个关键字:
处理异常: try, catch, finally; 抛出异常: throw; 声明异常: throws;
3, 终止finally执行的方法
System.exit(1);
4, throws
public static int test() throws ArithmeticException, InputMismatchException{
	//...
}
当调用test()方法时，可以直接用try/catch来处理异常，也可以由方法调用者继续声明异常类型;
当声明的是非检查异常时，调用时不处理异常编译器不会报错;
5, throw
当在方法内主动throw一个异常时，如果内部不进行处理，可由方法throws该异常，throws的异常必须与抛出的异常相同或者是其父类;
6, 自定义异常
class MyException extends Exception{
	public MyException(){
		super("年龄必须大于18岁");
	}
}
该异常类属于检查异常，编译器必须处理该异常; 如果继承自RuntimeException则为非检查异常;
7, 输出异常信息
e / e.toString(): 异常类型和描述信息，如 java.lang.ArithmeticException: /by zero;
e.getMessage(): 描述信息，如 /by zero;
e.printStackTrace(): 打印异常产生的堆栈信息，包括异常类型、描述信息和出错位置等;
8, 异常链
当前抛出的异常中包含上一层异常的信息;
try{
	test();
}catch(Exception e){
	Exception ex = new Exception("新异常");
	ex.initCause(e);
	throw ex;
	//或直接写成一句: throw new Exception("新异常", e);
}


>>泛型
1, 泛型的作用
提高程序的类型安全、消除强制类型转换;
2, 泛型类
public class NumGeneric<T>{
	private T num;
	//...
}
public class KeyValueGeneric<K, V>{
	//...
}
NumGeneric<Integer> intNum = new NumGeneric<>();
KeyValueGeneric<String, Double> kvObj = new KeyValueGeneric<>();
注: 集合中声明的类型必须与传递的实际类型保持一致，如下这种是错误的
List<Number> list = new ArrayList<Integer>(); //❌
3, 泛型方法
方法的参数或返回值都可以指定泛型;
public <T> void f1(T t){ }
public <T extends Animal> void f2(T t){ }
public <T super Animal> void f3(T t){ }
public void f4(List<?> pets){ } //通配符
public void f5(List<? extends Animal> pets){ }
public void f6(List<? super Animal> pets){ }
4, 继承泛型类
1)子类明确泛型类的参数类型
public interface GenericInterface<T>{ 
	//...
}
public class Demo1 implements GenericInterface<Integer>{
	//...
}
2)子类不明确泛型类的参数类型
public class Demo2<T> implements GenericInterface<T>{
	//...
}


>>注解Annotation
1, 用来对包、类、属性、方法、局部变量、方法参数等元素进行说明和注释的标记;
2, 按照运行机制，分为源码注解、编译时注解、运行时注解;
源码注解: 只在源码中保留，编译时丢弃，如@Override;
编译时注解: 编译时期保留，在JVM加载class文件时丢弃，如@NotNull;
运行时注解: 程序运行时还起作用，甚至会影响程序运行逻辑;
3, 按照来源，分为来自JDK的注解、来自第三方的注解、自定义的注解;
4, 元注解
用来对注解进行说明的注解;


>>设计模式
1, 单例模式
实现:
将构造方法设置为私有; 在类中创建静态私有属性用来保存唯一的实例对象; 提供一个公有的静态方法用于获取静态私有对象;
1)饿汉式: 在类加载时就创建实例, 是线程安全的;
public class Singleton{
	private static Singleton obj = new Singleton();
	private Singleton(){}
	public static Singleton getInstance(){
		return obj;
	}
}
2)懒汉式: 在调用时才创建实例, 存在线程风险;
public class Singleton{
	private static Singleton obj = null;
	private Singleton(){}
	public static Singleton getInstance(){
		if(obj == null){
			obj = new Singleton();
		}
		return obj;
	}
}
2, 工厂模式
工厂模式用于隐藏创建对象的细节, 使我们只需面向接口编程, 无需关心具体类的实现细节;
在客户类和具体实现类之间增加了抽象接口和工厂类：
客户类 -> 工厂类 -> 抽象接口 -> 具体实现类;
//客户类
public class Demo{
	public static void main(String[] args){
		Human human = HumanFactory.getInstance("中国");
		human.speak();
	}
}
//工厂类: HumanFactory.java
public class HumanFactory{
	public static Human getInstance(String area){
		if(area.equals("中国")){
			return new Chinese();
		}else if(area.equals("英国")){
			return new English();
		}else{
			return null;
		}
	}
}
//抽象接口: Human.java
public interface Human{
	void speak();
}
//具体实现类1: Chinese.java
public class Chinese implements Human{
	@Override
	public void speak(){
		System.out.println("你好，世界");
	}
}
//具体实现类2: English.java
public class English implements Human{
	@Override
	public void speak(){
		System.out.println("Hello, world");
	}
}
3, 代理模式


>>反射(reflect)
反射是在运行时动态访问类与对象的技术; 大多数框架都是基于反射实现参数配置、动态注入等特性;
1, Class类
对类和接口的抽象, 通过Class对象来获取特定类的结构信息;
Class empClass = Class.forName("com.imooc.reflect.Employee"); //将指定的类加载到JVM
Dog emp = (Employee)empClass.newInstance(); //调用默认构造函数
Constructor constructor = empClass.getConstructor(); //获得指定的public构造方法
Method method = empClass.getMethod(); //获得指定的public方法
Field field = empClass.getField();  //获得指定的public属性
2, Constructor构造方法类
//参数: new Class[]{String.class, int.class} 或 String.class, int.class
Constructor constructor = objClass.getConstructor(new Class[]{String.class, int.class});
//参数: new Object[]{"zhao", 3} 或 "zhao", 3
Employee emp = (Employee)constructor.newInstance(new Object[]{"zhao", 30});
注: 使用泛型Constructor<Employee>，可以避免强制类型转换;
3, Method方法类
//第一个参数是方法名, 后面是方法参数的类型列表
Method moveMethod = objClass.getMethod("move", String.class, float.class);
//invoke()方法调用，第一个参数是实例对象, 后面是参数列表
moveMethod.invoke(emp, "研发部", 10000);
4, Field成员变量类
//参数为属性名
Field enameField = empClass.getField("ename");
//get()方法需要传入实例对象作为参数
String ename = (String)enameField.get(emp);
//set()方法需要传入实例对象和属性值
enameField.set(emp, "张三");
5, getDeclared系列方法
getDeclaredConstructor(s)|Method(s)|Field(s), 获取单个或所有的构造函数|方法|属性;
举例, 获取所有属性的值, 如果属性为public, 则直接通过Field的get()方法获取,
如果属性为protected/private, 则通过对应的getter方法获取:
Field[] fields = empClass.getDeclaredFields();
for(Field field : fields){
	String fieldName = field.getName();
	if(field.getModifiers() == 1){ //public
		System.out.println(fieldName + ": " + field.get(emp));
	}else{ //protected/private
		String methodName = "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
		Method method = empClass.getMethod(methodName);
		System.out.println(fieldName + ": + + method.invoke(emp));
	}
}
6, 反射在项目中的应用
将类名保存在配置文件中, 然后在程序中读取配置文件动态加载类, 方法如下:
1)在src目录下新建配置文件 config.properties;
//config.properties
language=com.imooc.i18n.English
2)程序中读取配置文件并加载类
//Demo.java main()
Properties properties = new Properties();
String configPath = Demo.class.getResource("/config.properties").getPath();
configPath = new URLDecoder().decode(configPath, "utf-8");
properties.load(configPath);
String language = properties.getProperty("language");
I18N i18n = (I18N)Class.forName(language).newInstance();


>>Lambda表达式
1, Lambda表达式
1)Lambda表达式是用简洁的方式来实现函数式接口; 
函数式接口: 有且仅有一个抽象方法的接口;
public interface Operator{
	float cal(int a, int b);
}
//使用匿名内部类实现接口
Operator add = new Operator(){
	@Override
	public float cal(int a, int b){
		return a + b;
	}
};
add.cal(8, 6);
//使用Lambda表达式实现接口
Operator subtract = (a, b) -> a - b;
subtract(8, 6);
2)Lambda表达式的形式
(int a, int b) -> {return a + b;}
(a, b) -> a + b
a -> a * a  //只有一个参数时才可以省略()
() -> {...}
2, 函数式接口
java内置了一些函数式接口, 位于java.util.function;
1)Predicate<T>
boolean test(T t);  //用于测试传入的数据是否满足判断要求
举例: 
public static void filter(List<Integer> list, Predicate<Integer> predicate){
	for(Integer num : list){
		if(predicate.test(num){
			System.out.print(num);
		}
	}
}
filter(list, n -> n % 2 == 0); 
filter(list, n -> n > 5);
2)Consumer<T>
void accept(T t);  //对传入的数据进行处理, 无返回值
3)Function<T, R>
R apply(T t);  //对传入的数据进行处理并返回处理后的数据
注: 函数式接口在定义时可以加上注解: @FunctionalInterface, 用于通知编译器对函数式接口进行检查;
使用Lambda基于函数式接口进行编程, 就叫函数式编程;
3, Stream流
Stream流式处理是建立在Lambda基础上的多数据处理, 一般用于对集合的快速处理, 
可对集合进行迭代、去重、筛选、排序、聚合等一系列操作;
1)Stream流的创建方式
//基于数组创建: Stream.of()
String[] arr = {"java", "python", "c++", "php"};
Stream<String> stream = Stream.of(arr);
//基于集合创建: .stream()
List<Integer> list = Arrays.asList(1, 2, 3, 5, 8);
Stream<Integer> stream = list.stream();
2)Stream流的常用方法
stream.forEach(n -> System.out.println(n));  //遍历流中每个数据
stream.filter(n -> n%2==0);  //过滤流中数据
stream.map(s -> s.toUpperCase());  //对流中每个数据进行转换处理
stream.limit(5);  //得到流中前几条数据
stream.sorted((a,b) -> b-a);  //将流中数据排序
stream.count();  //统计流中数据的个数
stream.distinct();  //去除流中重复数据
stream.sum();  //对流中的数据求和, 要求数据必须是整型
stream.mapToInt(s -> Integer.parseInt(s));  //将流中的数据转换成整型
List<String> newList = stream.collect(Collectors.toList());  //将流中数据包装成列表
Set<String> newSet = stream.collect(Collections.toSet());  //将流中数据包装成集合
注: 可以对流进行链式处理, 如将列表中所有奇数从大到小排序且不允许重复:
List<Integer> list = stream.distinct().filter(n -> n%2==1)
	.sorted((a,b) -> b-a).collect(Collectors.toList());


>>输入输出流
1, File类
1)常用方法
File f = new File("E:/demo/test.txt");
File f = new File("E:/demo", "test.txt");
f.exists();
f.isDirectory();
f.isFile();
f.mkdir()/f.mkdirs(); //创建单级目录/多级目录
f.createNewFile(); //创建文件, 需要处理IOException异常
f.delete(); //删除目录或文件
f.getPath(); //返回路径, 与创建File时传入的参数相同
f.getAbsolutePath(); //返回绝对路径
f.getParent(); //返回父级目录
f.getName(); //返回文件名/目录名
f.length(); //文件大小，以字节为单位
2)绝对路径与相对路径
从盘符开始的路径为绝对路径, 从当前路径开始的路径为相对路径;
java文件所在的目录即为当前路径, eclipse较为特殊，当前路径为当前工程的目录;
2, 字节流(InputStream/OutputStream)
1)文件输入流 FileInputStream
FileInputStream fis = new FileInputStream(f); //需要处理FileNotFoundException异常
FileInputStream fis = new FileInputStream("demo/test.txt");
byte[] b;
fis.read(); //读入一个字节, 返回读取的字节值, -1表示到达文件末尾
fis.read(b); //从输入流中读数据存放到b中, 返回一共读取了多少个字节, 返回-1也表示文件末尾
fis.read(b, offset, len); //从数组b的offset位置开始存放，最多放len个字节
fis.close(); //关闭输入流
注: read()与read(b)的返回值是不同的;
举例: 按字节读取文件内容
int n = 0;
while((n=fis.read()) != -1){
	System.out.print((char)n);
}
或
byte[] b = new byte[100];
fis.read(b);
System.out.println(new String(b));
2)文件输出流 FileOutputStream
FileOutputStream fos = new FileOutputStream(f);
FileOutputStream fos = new FileOutputStream("demo/test.txt", true); //第二个参数true表示追加，false表示覆盖
fos.write(n/'a'); //将指定字节写到文件
fos.write(b); //将字节数组b的内容写到文件
fos.write(b, offset, len); //将字节数组从offset位置开始的len个字节写到文件
fos.close(); //关闭输出流
注: 字节流一般用于处理二进制文件如图片, 文本文件更应该用字符流来处理;
举例: 复制图片文件
FileInputStream fis = new FileInputStream("bing.jpg");
FileOutputStream fos = new FileOutputStream("bing2.jpg");
int n = 0;
byte[] b = new byte[1000]; //大小随便取
while((n=fis.read(b)) != -1){ //边读边写
	fos.write(b, 0, n); //保证复制后图片与原图片大小一致
}
fis.close();
fos.close();
3)缓冲输入输出流 BufferedInputStream/BufferedOutputStream
文件输入输出流是与硬盘交互数据，速度较慢，而缓冲输入输出流是从内存读取数据，速度很快;
过程: CPU-内存缓冲区-其他输入输出流(如硬盘文件);
构造缓冲输入输出流的参数是输入输出流的子类, 如
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("test.txt"));
bos.write(b);
缓冲输入输出流的常用方法与文件输入输出流相同;
注: 缓冲输出流, 当缓冲区未满则不会自动写数据，必须调用bos.flush()或bos.close()才会写数据;
3, 字符流 (Reader/Writer)
1)文件字符输入输出流 FileReader/FileWriter
FileReader fr = new FileReader("test.txt");
FileWriter fw = new FileWriter("test.txt");
常用方法同文件字节流，把byte[]数组换成char[]数组;
2)缓冲字符输入输出流 BufferedReader/BufferedWriter
BufferedReader br = new BufferedReader(fr);
BufferedWriter bw = new BufferedWriter(fw);
常用方法与缓冲字节流类似;
BufferedReader提供了readLine()方法一次可以读取一行字符串, 
String s = null;
while((s = br.readLine()) != null){
	//todo s
}
4, 对象的序列化
1)序列化与反序列化, 就是java对象和字节序列之间转换的过程;
步骤: 创建一个类继承Serializable接口->创建对象->将对象写入文件(或网络传输)/从文件读取对象;
对象读写涉及两个类: ObjectInputStream/ObjectOutputStream;
2)举例
class Cat implements Serializable{....}
Cat cat1 = new Cat("zhao", 30);
FileInputStream fis = new FileInputStream("bing.jpg");
FileOutputStream fos = new FileOutputStream("bing2.jpg");
ObjectInputStream ois = new ObjectInputStream(fis);
ObjectOutputStream oos = new ObjectOutputStream(fos);
oos.writeObject(cat1); //把对象序列化到文件
oos.writeObject(null); //作为结束标记
oos.flush();
Cat cat = (Cat)ois.readObject(); //从文件反序列化到对象


>>单元测试
1, 单元测试是指对软件中的最小可测试单元进行检查和验证;
2, Java中使用JUnit4来进行单元测试;
1)在maven工程中引入JUnit4依赖;
2)待测试代码
main
	java
		com.imooc.junit
			Calculator
//Calculator.java
public classs Calculator {
	public int multiply(int a, int b){
		return a * b;
	}
	public float divide(int a, int b){
		if(b == 0){
			throw new ArithmeticException("divide by zero");
		}
		return a / b;
	}
}
3)测试用例-手动创建
test
	java 
		com.imooc.junit
			CalculatorTest    //命名规范: 在原来类名后增加Test
public class CalculatorTest{
	private Calculator cal = new Calculator();
	@Test   //测试用例注解
	public void multiply(){
		int rs = cal.multiply(2, 1);
		System.out.println(rs);
	}
	public void divide(){
		int rs = cal.divide(2, 0);
		System.out.println(rs);
	}
}
4)测试用例-自动创建
点击Calculator类, 点击 Code -> Generator -> Test 进入测试用例自动创建页面, 
会自动在test目录下创建测试用例;



>>XML(可扩展标记语言)
1, XML文档结构
1)XML与HTML
XML没有预定义标签，HTML存在大量预定义标签;
XML用于保存与传输数据，HTML用于显示信息;
2)XML的用途
程序的配置描述文件、保存程序产生的数据、网络间的数据传输;
3)第一行必须是xml声明，有且只有一个根节点
4)举例 
//hr.xml
<?xml version="1.0" encoding="UTF-8" ?>  //xml声明
<!DOCTYPE hr SYSTEM "hr.dtd">  //可选, 引入dtd文件, hr-根节点, SYSTEM-本地
<hr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="hr.xsd">  //可选, 引入xml schema文件, 直接在根节点上添加
<hr>  //根节点
	<employee no="1001">
		<name>张三</name>
		<age>32</age>
		<salary>8000</salary>
		<department>
			<dname>研发部</dname>
			<address>XX大厦-B103</address>
		</department>
	</employee>
	<employee no="1002">
		.....
	</employee>
</hr>
2, XML语义约束
规定XML文档中允许出现哪些元素以及元素的数量, 语义约束有两种定义方式: 
DTD和XML schema;
1)DTD(文档类型定义)
//hr.dtd
<?xml version="1.0" encoding="UTF-8" ?>
<!ELEMENT hr (employee+)>  	//节点, hr节点下必须出现1~n次employee节点
<!ELEMENT employee (name, age, salary, department)>  //employee节点下必须包含这四个子节点，且按顺序出现
<!ATTLIST employee no CDATA "">  //节点的属性, no-属性名, CDATA-类型, ""-默认值
<!ELEMENT name (#PCDATA)>  //文本节点
<!ELEMENT age (#PCDATA)>
<!ELEMENT salary (#PCDATA)>
<!ELEMENT department (dname, address)>
<!ELEMENT dname (#PCDATA)>
<!ELEMENT address (#PCDATA)>
注: employee后加+, *, ?分别表示出现1~n次, 0~n次, 0~1次, 不加表示1次;
2)XML schema
XML schema 是W3C标准, 提供了数据类型、格式限定、数据范围等更多特性, 目前应用广泛;
//hr.xsd
<?xml version="1.0" encoding="UTF-8" ?>
<schema xmlns="http://www.w3.org/2001/XMLSchema">
	<element name="hr">
		<complexType>
			<sequence>
				<element name="employee" minOccurs="1" maxOccurs="999">
					<complexType>
						<sequence>
							<element name="name" type="string"></element>
							<element name="age" type="int"></element>
							<element name="salary" type="float"></element>
							<element name="department">
								<complexType>
									<sequence>
										<element name="dname" type="string"></element>
										<element name="address" type="string"></element>
									</sequence>
								</complexType>
							</element>
						</sequence>
						<attribute name="no" type="string" use="required"></attribute>
					</complexType>
				</element>
			</sequence>
		</complexType>
	</element>
</schema>
3, XML文档解析
1)DOM4j
需要引入dom4j.jar包, DOM4j中的核心类SAXReader将XML文档解析成DOM树; 
//遍历hr.xml中的员工信息
String file = "E:/Java/workspace/test/src/hr.xml";
SAXReader reader = new SAXReader();
Document document = reader.read(file);  //将XML文档解析成DOM树
Element root = document.getRootElement();  //获取XML文档的根节点
List<Element> employees = root.elements("employee");  //获取所有的employee节点
for(Element v: employees){
	String s = "no: " + v.attribute("no").getText() +  //取属性的值
		", name: " + v.element("name").getText();  //取子节点的值
	System.out.println(s);
}
//新增一条员工信息
Element emp = root.addElement("employee"); 
emp.addAttribute("no", "1001");  //新增属性
emp.addElement("name", "王五");  //新增元素节点
Writer writer = new OutputStreamWriter(new FileOutputStream(file), "UTF-8");
document.write(writer);  //写入文档
writer.close();  //关闭输出流
2)DOM4j + XPath表达式
XPath是XML文档中用来查询数据的语言, 查询高效, 解析XML文档优先使用XPath;
需要引入Jaxen.jar包, DOM4j底层依赖Jaxen实现XPath查询;
/hr/employee  //根节点hr下的employee子节点
/hr//employee  //根节点hr下的所有employee后代节点
//employee[1]  //根据位置筛选, 第一个employee节点
//employee[salary<3000]/name  //根据子节点筛选, 工资小于3000的employee节点的name节点
//employee[@no=3304]  //根据属性筛选, no属性等于3304的employee节点
//employee[3]|employee[8]  //第3个和第8个employee节点
//举例
public void xpath(String exp){
	String file = "E:/Java/workspace/test/src/hr.xml";
	SAXReader reader = new SAXReader();
	Document document = reader.read(file);
	List<Node> nodes = document.selectNodes(exp);  //核心方法
	for(Node node: nodes){
		Element elem = (Element)node;
		//todo with elem
	}
}
new Demo().xpath("//employee[position()<5]");


>>Servlet
1, 软件结构发展史
单机桌面应用 -> C/S架构 -> B/S架构;
2, J2EE与tomcat
J2EE是一组技术规范与标准, 具体实现由软件厂商决定;
tomcat是免费开源的web应用服务器程序, 是J2EE中的Servlet与JSP两个模块标准的实现;
tomcat的默认端口号是8080;
3, Servlet创建
Servlet是服务器端程序，用于动态生成web内容;
//继承HttpServlet类, 重写service()方法
public class MyServlet extends HttpServlet{
	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response){
		//...
	}
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response){
		//...
	}
	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response){
		//...
	}
}
注: service()默认会根据请求的类型将请求分发给doGet()或doPost()进行处理;
//配置web.xml
<servlet>
	<servlet-name>MyServlet</servlet-name>
	<servlet-class>com.imooc.servlet.MyServlet</servlet-class>
</servlet>
<servlet-mapping>
	<servlet-name>MyServlet</servlet-name>
	<url-pattern>/info</url-pattern>
</servlet-mapping>
//也可通过注解形式来配置
@WebServlet("/info")
注: 实际项目中比较常用的方式是将servlet映射设置为index.html;
注: 配置形式与注解形式的区别:
1)注解形式比配置形式简洁;
2)注解形式只对当前类有效，而配置形式对整个工程有效;
3)修改配置文件需要重启服务器, 修改注解形式需要重新编译程序, 后者更麻烦;
//url访问格式
http://IP地址(或域名):端口/工程名/url-pattern, 如
http://localhost:8080/test/employee/2;
注: 1)修改默认端口号为80的方法:
修改tomcat的配置文件server.xml: <Connector connectionTimeout="20000" port="80" protocol="HTTP/1.1" redirectPort="8443"/>
2)url访问省略工程名的两种设置方法:
一是在新建工程时将 context root 设置为 /;
二是修改tomcat的配置文件server.xml: <Context docBase="E:\Java\apache-tomcat-8.5.70\webapps\myServlet" path="/" .../></Host>
4, java web工程结构
1)eclipse中工作目录可以任意定义, 发布目录必须设置为tomcat/webapps, 工程test发布后自动存放到tomcat/webapps/test, 
eclipse中对文件的修改会自动同步到发布内容;
2)工程结构
tomcat/webapps              //tomcat应用根目录
	test                    //工程
		META-INF           
			MENIFEST.MF
		WEB-INF             //web应用的安全目录
			classes        //编译后的class文件
			lib            //第三方jar包
			web.xml        //核心部署配置文件
		index.html         //前端网页
5, tomcat/lib 与 test/WEB-INF/lib
tomcat/lib目录存放的jar包对所有工程都有效;
test/WEB-INF/lib目录存放的jar包仅对当前test工程有效;
6, Servlet生命周期
Servlet生命周期也就是Servlet的执行过程, 分为以下几个步骤: 
1)装载-web.xml
tomcat加载时解析web.xml, 装载与url绑定的Servlet类;
2)创建-构造函数
第一次访问Servlet对应的url时，调用构造函数创建Servlet;
3)初始化-init()
在init()中对Servlet进行初始化操作;
4)提供服务-service()
通过service()提供服务, 如果调用了super.service(request, response), 则会继续将请求转发给doGet()或doPost()进行处理;
5)销毁-destroy()
tomcat重启或关闭时, 调用destroy()销毁Servlet;
注: Servlet是单例模式, 在tomcat的全局环境中, Servlet实例对象只创建一次;
7, 启动时加载Servlet
1)启动时加载常用于系统的预处理，如创建数据库、导入数据、统计分析等;
2)步骤
//在自定义的Servlet类中重写init()方法, 在方法体内进行预处理的操作
@Override
public void init(){
	//....
}
//web.xml中使用<load-on-startup>0~9999</load-on-startup>来设置自动加载，数字越小越优先
<servlet>
	<servlet-name>Create</servlet-name>
	<servlet-class>com.imooc.servlet.CreateServlet</servlet-class>
	<load-on-startup>0</load-on-startup>
</servlet>
注: 配置形式设置自动加载不用设置servlet-mapping;
//或使用注解形式
@WebServlet(urlPatterns="/unused", loadOnStartup=0)
注: 注解形式设置自动加载必须加上urlPatterns, 写上一个用不到的属性值;
8, url-pattern中通配符*的使用(模糊匹配)
@WebServlet("/employee/*"), 可用来获取每个员工的编号,
String url = request.getRequestURL().toString();
String id = url.substring(url.lastIndexOf("/") + 1);
9, Cookie与Session
1)Cookie
Cookie是浏览器保存在本地的文本内容，会作为request的请求头发送到服务器;
一般在第一次登录时设置Cookie,设置后作为response的响应头发送回浏览器;
如果不设置Cookie的有效期, 则默认在关闭浏览器时Cookie失效;
//设置Cookie
Cookie ck = new Cookie("username", "admin");
ck.setMaxAge(n);  //设置Cookie的有效期为n秒
response.addCookie(ck);
//获取Cookie
Cookie[] cks = request.getCookies();
for(Cookie ck: cks){
	ck.getName();  //cookie名
	ck.getValue();  //cookie值
}
//Cookie的缺点
安全性差、每次发送Cookie会占用带宽;
2)Session(用户会话)
Session保存在服务器, 默认保存30分钟，30分钟后自动销毁;
Session是服务器的一块内存区域，有唯一的SessionID与之对应;
该SessionID会在Session第一次创建时发送给浏览器作为Cookie保存，后面浏览器发送请求都会携带该SessionID;
SessionID作为Cookie保存在浏览器，如果重新打开浏览器窗口，SessionID就会改变，之前的Session值就取不到了;
调用request.getSession(), 如果是新的请求(即没有携带SessionID), 服务器会创建一块新的Session, 并将SessionID
传回浏览器, 如果不是新的请求，则服务器会取与携带的SessionID对应的Session;
//设置Session
HttpSession session = request.getSession();
session.setAttribute("username", "admin");
//获取Session
HttpSession session = request.getSession();
String username = (String)session.getAttribute("username");
//使当前Session失效
session.invalidate();
注: getSession(boolean)与getSession()的区别:
getSession(true)与getSession()等价, 如果当前请求没有对应的Session则创建新Session;
getSession(false)如果当前请求没有对应的Session则返回null;
10, ServletContext(Servlet上下文对象)
1)是Web应用全局对象, 一个Web应用只会创建一个ServletContext对象, 只要tomcat不关闭，这个对象就一直存在;
//设置ServletContext
ServletContext context = request.getServletContext();
context.setAttribute("username", "zhao");
//获取ServletContext
ServletContext context = request.getServletContext();
String username = (String)context.getAttribute("username");
2)可以通过全局参数来配置ServletContext
//配置文件web.xml
<context-param>
	<param-name>title</param-name>
	<param-value>imooc page</param-value>
</context-param>
//获取全局参数
ServletContext context = request.getServletContext();
String title = context.getInitParameter("title");
11, Java Web最常用的三大作用域对象
1)HttpServletRequest request -请求对象
2)HttpSession session -用户会话对象
3)ServletContext context -web应用全局对象
注: 这三个对象的作用域和生命周期依次递增;
为了避免资源浪费, 能用小作用域对象解决的问题，就尽量不要用大作用域对象;
12, web.xml的常用配置
1)配置默认页面
<welcome-file-list>
	<welcome-file>index.html</welcome-file>
	<welcome-file>index.jsp</welcome-file>
</welcome-file-list>
2)配置Servlet
3)配置过滤器
4)配置监听器
5)配置全局参数
13, 自定义404, 500状态码的默认页面
1)新建错误目录及页面
WebContent
	META-INF
	WEB-INF
		lib
		web.xml
	error
		404.html
		500.jsp
	index.html
//500.jsp
<%@ page contentType="text/html;charset=utf-8" isErrorPage="true" %>
<body>
	<p>服务器内部错误, 错误信息如下: </p>
	<%
		out.println(exception.getClass().getSimpleName() + ": " + exception.getMessage());
	%>
</body>
注: exception对象只能用在错误页面中, 需要在页面的page指令下增加"isErrorPage"属性;
2)配置web.xml
<error-page>
	<error-code>404</error-code>
	<location>/error/404.html</location>
</error-page>
<error-page>
	<error-code>500</error-code>
	<location>/error/500.jsp</location>
</error-page>
14, Java Web应用的打包与发布
java类可以导出成jar包，而Java Web应用可以到处成war包进行发布，发布路径为 tomcat/webapps/test.war;
当点击startup.bat启动tomcat时，会自动对war包进行解压缩，然后就可以在浏览器中进行访问;
eclipse中将工程导出为war包的步骤:
File -> Export -> Web -> WAR file -> E:/Java/tomcat/webapps/test.war;


>>JSP
1, Java服务器页面, jsp的底层就是Servlet, jsp的执行过程如下: 
index.jsp --(转译)-> index_jsp.java(Servlet源码)
		  --(编译)-> index_jsp.class(字节码)
		  --(执行)-> html页面;
为了使jsp页面支持中文，需要在jsp页面的第一行写一条处理指令: 
<%@ page contentType="text/html;charset=utf-8" %>
2, jsp的基本语法
//代码块
<% out.print("hello"); %>
//声明构造块
<%! List<String> list = new ArrayList<>(); %>
<%! public int add(int a, int b){
		return a + b;
	} %>
//输出指令--等价于 out.print()
<%= list.get(1) %> 
<%= add(4, 5) %>
//处理指令
<%@ page contentType="text/html;charset=utf-8" import="java.util.*, java.io.*" %> //定义当前jsp页面全局设置
<%@ include file="include/header.jsp" %>  //引入其他jsp页面
<%@ taglib uri="..." prefix="..." %>  //引入jsp标签库
3, 九大内置对象
jsp内置对象是对Servlet使用的简化;
1)request   	 //请求对象-HttpServletRequest
2)response   	 //响应对象-HttpServletResponse
3)session    	 //用户会话-HttpSession  		 =request.getSession()
4)application    //应用全局对象-ServletContext   =request.getServletContext()
5)out         	 //输出对象-PrintWriter     	 =response.getWriter()
6)page			 //当前页面对象  				 =this
7)pageContext	 //页面上下文对象-PageContext
8)config	     //应用配置对象-ServletConfig
9)exception      //异常对象-Throwable
4, EL表达式与JSTL
1)EL表达式(Expression Language)
EL表达式通过内置一些对象，来简化JSP的输出;
JSP默认支持EL表达式, 无需下载第三方jar包;
//EL中的作用域对象
pageScope  			--从当前页面取值
requestScope 		--从request取值
sessionScope 		--从session取值
applicationScope 	--从application取值
//EL表达式的写法
${[作用域对象.]属性名}
如果省略作用域对象, 则按作用域范围从小到大依次尝试获取, 如果没有找到该属性, 则返回空字符串;
${sessionScope.title} 
${requestScope.student}  //如果属性为对象, 默认执行对象的toString()方法
${student.age}  //省略作用域对象，输出属性的字段
${student.age+10}
//获取url的参数
EL表达式内置了param对象用于获取url的参数, ${param.参数名}
2)JSTL(JSP标准标签库)
使用JSTL需要下载引用第三方jar包, 主要使用其中的核心标签库(core)和格式化输出标签库(fmt);
引入JSTL核心库: <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
引入JSTL输出标签库库: <%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
//core-单分支判断
<c:if test="${score >= 60}">
	<h1>恭喜，你通过测试</h1>
</c:if>
//core-多分支判断
<c:choose>
	<c:when test="${grade == 'A'}"><h1>优秀</h1></c:when>
	<c:when test="${grade == 'B'}"><h1>良好</h1></c:when>
	<c:otherwise><h1>不合格</h1></c:otherwise>
</c:choose>
//core-遍历集合
<c:forEach items="${persons}" var="p" varStatus="idx">
	<h2>序号: ${idx.index+1}, 姓名: ${p.name}, 年龄: ${p.age}</h2>
</c:forEach>
//fmt-日期
request.setAttribute("date", new Date());
<fmt:formatDate value="${date}" pattern="YYYY-MM-dd HH:mm:ss sss" />
//fmt-数字
request.setAttribute("number", 12345.678);
<fmt:formatNumber value="${number}" pattern="0,000.00" /}


>>请求与响应
1, http是无状态协议，也就是服务端不保留连接的相关信息；
2, request格式
请求行 + 请求头 + 请求体:
请求行: POST /test/login HTTP/1.1
请求头: request header
请求体: request body  //header和body之间必须有一空行
注: get请求没有请求体;
前端页面请求后端url需要加上工程名, 如 /test/login;
3, response格式
响应行 + 响应头 + 响应体: 
响应行: HTTP/1.1 200 OK
响应头: response header
响应体: response body
4, http响应状态码
1XX: 收到请求，正在处理;
2XX: 成功，如 200 OK；
3XX：重定向，表示请求没有成功，需要采取进一步的动作；
4XX：客户端错误，表示客户端提交的请求有错误，如 404 NOT Found;
5XX：服务器错误，如 500;
5, get与post请求方式的区别
get将数据附加在url里显式发送, 而post将数据放在请求体里隐式发送;
get安全性差, 常用于向服务器的查询操作, 而post安全性高, 常用于对服务器的写操作;
get将数据附加到url，所以长度是有限制的，而post对数据长度没有限制;
get数据能保留在浏览器历史中, 可收藏为书签, 而post不可以;
6, 请求参数的接收与响应的发送
1)接收单个参数
String username = request.getParameter("username");
2)接收多个同名参数, 如复选框
String[] likes = request.getParameterValues("likes");
3)发送响应
response.getWriter().println(s);
4)获取url与uri
String url = request.getRequestURL().toString(); //http://localhost:8080/test/info
String uri = request.getRequestURI(); ///test/info
7, 获取请求头与设置响应头
1)获取请求头
String userAgent = request.getHeader("User-Agent");
2)设置响应头
response.setHeader(name, value);
response.setContentType("text/xml;charset=utf-8");
8, ContentType的作用
ContentType决定浏览器采用何种方式对响应体进行处理, 常用的有: 
text/plain(html, xml);  //纯文本格式, html格式, xml格式
application/xml(json, pdf, octet-stream, x-www-form-urlencoded, x-msdownload);  //xml数据格式, json数据格式, pdf格式, 二进制流数据如文件下载, 表单格式, 资源下载
image/gif(jpeg, png)  //图片格式
9, 中文乱码问题
1)请求的乱码, 放在第一行
request.setCharacterEncoding("utf-8");
2)响应的乱码
response.setContentType("text/html;charset=utf-8");
10, 请求转发与响应重定向
页面的跳转有两种方式: 请求转发与响应重定向;
1)请求转发
request.getRequestDispatcher("/info").forward(request, response);  //转发给另一个Servlet
request.getRequestDispatcher("/success.jsp").forward(request, response);  //转发给jsp页面
2)响应重定向
response.sendRedirect("/test/info");
3)两者的区别
前者是在Servlet内部完成，浏览器只发送一次请求，所以地址栏的url不变, 
而后者是重新发送一次请求，所以地址栏的url会改变;
两者的参数不同，后者需要加上工程名，如 /test/info;
响应重定向第一次响应带回的信息: Status Code: 302, Location: /test/info;
11, 请求可以创建自定义属性
request.setAttribute("username", "zhao");  //设置
request.getAttribute("username");  //获取
可通过请求转发，将一个Servlet中的信息通过request携带到另一个Servlet或jsp页面;
由于响应重定向是两次不同的请求，所以不能这么做;


>>JSON
1, JSON即JavaScript对象表示法，独立于具体语言，是一种轻量级的数据交换格式;
JSON语法简单，用于数据交换；而XML解析复杂，常用于数据存储;
2, JSON本身是对象，但在应用中，前台与后台交换的是JSON串, 如
'{"name": "zhao", "age": 30}';
3, js中操作json的函数
//把js对象转换成json串
JSON.stringify()
//把json串解析成js对象；
JSON.parse()
4, FastJson
FastJson是阿里巴巴开发的jar包, 用于将JavaBean与JSON字符串相互转换;
1)对象与json串的转换
//对象转换成json串
String s = JSON.toJSONString(employee);  //{"name": "zhao", "age": 26}
默认情况下, Date字段会被转换成时间戳, 可以在Employee类的字段前添加注解来对输出进行格式化: 
@JSONField(name="hiredate", format="yyyy-MM-dd")
private Date hdate;
@JSONField(serialize=false) //不对dname序列化
private String dname;
//json串转换成对象
Employee employee = JSON.parseObject(s, Employee.class);
2)集合与json串的转换
List<Student> list = new ArrayList<>();
//集合转换成json串
String s = JSON.toJSONString(list);  //[{"name": "zhao", "age": 20}, {"name": "qian", "age": 30}, ...]
//json串转换成集合
List<Student> list2 = JSON.parseArray(s, Student.class);
3)前后台通过ajax进行交互的案例
//index.html
$.ajax({
	url: "/test/info",  //必须加上工程名
	type: "get",
	data: {},
	dataType: "json",
	success: function(data){
		for(var i = 0; i < data.length; i++){
			//data[i]
		}
	},
	error: function(xhr){
		console.log(xhr.status + ": " + xhr.statusText);
	}
});
//InfoServlet.java
List<Student> list = new ArrayList<>();
list.add(new Student("zhao", 30));
list.add(new Student("qian", 20));
response.getWriter().println(JSON.toJSONString(list));


>>正则表达式
1, 基本语法
1)元字符
.  任意字符(回车和换行符除外)
^  匹配开头
$  匹配结尾
|  或
\  转义
() 匹配子组
[] 字符类
量词:
?  出现0次或1次
*  出现0次或多次
+  出现1次或多次
{n} 出现n次
{n,m} 出现n到m次
{n,} 出现至少n次
注：范围量词{n,m}中间不能有空格，否则无效;
2)转义字符
\n 换行
\r 回车
\f 换页
\t 水平制表
\v 垂直制表
3)字符类
[a-zA-Z0-9]
\d 数字类 [0-9]
\D 非数字类 [^0-9]
\w 单词字符 [a-zA-Z0-9_]
\W 非单词字符 [^a-zA-Z0-9_]
\s 空白符 [\t\n\x0B\f\r]
\S 非空白符 [^\t\n\x0B\f\r]
\b 单词边界
\B 非单词边界
注: 对字符类取反，^必须放在[]里第一个位置，否则无效;
2, \b, \B, ^, $ 举例(js)
'This is a boy.'.replace(/is/g, 'X'); //'ThX X a boy.'
'This is a boy.'.replace(/\bis\b/g, 'X'); //'This X a boy.'
'This is a boy.'.replace(/\Bis\b/g, 'X'); 'ThX is a boy.'
'@123@abc@'.replace(/@./g, 'X'); //'X23Xbc@'
'@123@abc@'.replace(/^@./g, 'X'); //'X23@abc@'
'@123@abc@'.replace(/.@/g, 'X'); //'@12XabX'
'@123@abc@'.replace(/.@$/g, 'X'); //'@123@abX'
3, 单个中文的匹配
[\u4e00-\u9fa5]
4, 贪婪模式与非贪婪模式
量词匹配默认使用贪婪模式，采用尽可能多的匹配;
在量词后加?则使用非贪婪模式;
'12345678'.replace(/\d{3,6}/, 'X'); //'X78'
'12345678'.replace(/\d{3,6}?/, 'X'); //'X45678'
'12345678'.replace(/\d{3,6}/g, 'X'); //'X78'
'12345678'.replace(/\d{3,6}?/g, 'X'); //'XX78'
'123-12345678'.match(/\d+?-\d+?/)  //'123-1'
5, 前瞻后顾
不仅考虑自身的匹配，还要考虑前面或者后面的字，语法：
exp(?=assert) //后面符合断言
exp(?!assert) //后面不符合断言
例如：
'a2*34vv'.replace(/\w(?=\d)/g, 'X'); //'X2*X4vv'
'a2*34vv'.replace(/\w(?!\d)/g, 'X'); //'aX*3XXX'
6, 常用的正则表达式
1)非空
/.+/   
2)保留两位小数的浮点数
/^[-\+]?\d+\.\d{2}$/
3)中国大陆的手机号
/^1[34578]\d{9}$/
4)email地址
/^\w+(\.\w+)*@\w+(\.\w+)*$/
5)url地址
/^(https?://)?(\w+\.)+[a-zA-Z]+$/
7, js中正则表达式
1)定义正则表达式
var reg = /\bis\b/g; //字面量
var reg = new RegExp('\\bis\\b', 'g'); //构造函数
注：\b是匹配单词边界;
常用的修饰符(修饰符可省略)：
g: 全文搜索;
i: 忽略大小写;
m: 多行匹配;
2)正则对象的属性
global: 是否全文搜索，默认为false;
ignoreCase: 是否区分大小写，默认为false;
multiline: 是否多行搜索，默认为false；
source: 正则表达式的文本字符串;
lastIndex: 当前匹配的下一个位置索引，仅对全文搜索有效;
3)正则对象的方法
reg.test(s)
是否存在的匹配，返回true或false;
/\w\d/.test('a1b2c3d4'); //true
reg.exec(s)
模式匹配，如果没有匹配的文本则返回null，否则返回一个结果数组；
非全文搜索的多次匹配结果都一样：
var reg = /(\w)\d/, s = 'a1b2c3';
var r = reg.exec(s);
r; //['a1', 'a', index: 0]
全文搜索每次匹配后reg的lastIndex都会变化，会导致结果不一样：
var reg = /(\w)\d/g, s = 'a1b2c3';
var r1 = reg.exec(s); //['a1', 'a', index: 0]
var r2 = reg.exec(s); //['b2', 'b', index: 2]
var r3 = reg.exec(s); //['c3', 'c', index: 4]
var r4 = reg.exec(s); //null
var r5 = reg.exec(s); //同r1
reg.lastIndex; //2
注：lastIndex同样会影响修饰符为g的全文搜索的test()结果：
var reg = /\w\d/g, s = 'a1b2';
reg.test(s); //true
reg.test(s); //true
reg.test(s); //false
可以通过每次构造一个新正则对象来消除结果的不一致性：
/\w\d/g.test('a1b2'); //true(all the time)
4)字符串对象的方法
s.search(reg)
查找参数指定的子串的位置，返回匹配到的下标，不存在则返回-1;
接收的参数可以是字符串，也可以是正则表达式；
search()方法不执行全局搜索，它将忽略g，并且总是从字符串的开头进行查找：
'aaa123bbb'.search(/\w\d/); //2
s.match(reg)
查找匹配的结果数组;
这个方法reg是否为全局搜索对结果的影响很大，
reg非全局返回第一次匹配的结果，包括分组，
reg全局则返回所有匹配的结果，但不包括分组信息;
注意这个方法与reg.exec(s)返回结果的区别；
var s = 'a1b2c3d4', reg = /(\w)\d/;
var r = s.match(reg);
r; //['a1', 'a', index: 0]
var s = 'a1b2c3d4', reg = /(\w)\d/g;
var r = s.match(reg);
r; //['a1', 'b2', 'c3', 'd4']
s.replace(reg, rep)
对字符串进行正则替换;
第一个参数可以是字符串，也可以是正则表达式;
第二个参数可以是替换字符串，也可以是回调函数，自定义替换结果;
'a1b1c1'.replace('1', 'X'); //'aXb1c1'
'a1b1c1'.replace(/1/g, 'X'); //'aXbXcX'
'a1b2c3d4'.replace(/\d/g, function(match, index, origin){
	return parseInt(match)+1;
}); //'a2b3c4d5'
注：replace()方法传入字符串只能替换第一个匹配
s.split(reg)
将字符串按指定参数分割成数组；
'a,b,c,d'.split(','); //['a', 'b', 'c', 'd']
'a1b2c3d4'.split(/\d/); //['a', 'b', 'c', 'd', '']
8, java中正则表达式
//创建正则表达式对象
Pattern p = Pattern.compile("***"); //参数不需要起止符//
//匹配正则表达式
Matcher m = p.matcher(s);
//查找匹配结果
while(m.find()){
	m.group(0); //原始匹配
	m.group(1)/m.group(2); //子组
}


>>过滤器
1, 过滤器的作用
Filter对URL进行统一的过滤和拦截，通常用于应用程序层面的全局处理;
多个过滤器形成过滤链, 请求依次通过过滤链, 响应再以相反的顺序通过过滤链;
2, 开发过滤器的步骤
1)实现Filter接口
2)重写doFilter()方法
public class MyFilter implements Filter{
	@Override
	public void init(){ //... }
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain){
		//todo
		chain.doFilter(request, response);  
	}
	@Override
	public void destroy(FilterConfig config){ //... }
3)在web.xml中对过滤器进行配置说明拦截url的范围
<filter>
  <filter-name>myFilter</filter-name>
  <filter-class>com.imooc.filter.MyFilter</filter-class>
</filter>
<filter-mapping>
  <filter-name>myFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
或采用注解形式: @WebFilter(filterName="MyFilter", urlPatterns="/*")
注意事项: 
1)HttpServletRequest/HttpServletResponse是ServletRequest/ServletResponse的子接口;
2)调用chain.doFilter()将请求向后传递;
chain.doFilter()之前的语句处理请求，chain.doFilter()之后的语句处理响应;
如果不调用chain.doFilter()方法, 请求到达该过滤器后就不再往后传递，直接原地返回;
3)如果要同时拦截多个url，可以通过添加多个<filter-mapping>，其<filter-name>相同; 或采用注解形式如
@WebFilter(filterName="MyFilter", urlPatterns="/servlet/*")  //指定单个url
@WebFilter(filterName="MyFilter", urlPatterns={"/", "/servlet/*", "*.jsp"}) //指定多个url
3, 过滤器的生命周期
初始化-Filter.init(): tomcat启动时;
提供服务-Filter.doFilter(): 每次来请求时;
销毁-Filter.destroy(): tomcat关闭或重启;
注: Filter也跟Servlet一样，使用单例多线程模式提供服务;
4, 过滤链
请求->过滤器1->过滤器2->servlet->产生响应->过滤器2->过滤器1->客户端；
每一个过滤器应具有单独的职能, 过滤器的执行顺序以<filter-mapping>为准;
如果多个过滤器都按照注解形式配置, 执行的先后顺序是根据过滤器类名的字母顺序决定, 不推荐;
5, 使用场景
1)请求和响应的字符集设置
2)用户身份的校验;
3)多端设备自动适配
新建工程时将 context root 设置为 /;
目录
WebContent
	desktop
		index.html
	mobile
		index.html
	WEB-INFO
		web.xml
//MyFilter.java
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain){
	HttpServletRequest req = (HttpServletRequest)request;
	HttpServletResponse resp = (HttpServletResponse)response;
	String uri = req.getRequestURI();
	if(uri.startsWith("/desktop") || uri.startsWith("/mobile")){  //将请求向后传递
		chain.doFilter(request, response);
	}else{
		String userAgent = req.getHeader("user-agent").toLowerCase();
		String targetURI = "";
		if(userAgent.indexOf("android") > -1 || userAgent.indexOf("iphone") > -1){
			targetURI = "/mobile" + uri;
		}else{
			targetURI = "/desktop" + uri;
		}
		resp.sendRedirect(targetURI);  //将请求返回，进行响应重定向
	}
}


>>监听器
1, Listener用于对Web应用中三大作用域对象的创建与销毁、以及这些对象的属性的增删改操作进行监听;
三种监听对象: ServletContext(application), HttpSession(session), ServletRequest(request);
2, 六种常用监听接口
内置对象监听接口(监听对象的创建与销毁):
ServletContextListener;
HttpSessionListener;
ServletRequestListner;
属性监听接口(监听属性的增删改操作):
ServletContextAttributeListener;
HttpSessionAttributeListener;
ServletRequestAttributeListner;
3, 开发监听器的步骤
1)实现XxxListener接口，实现接口中对应的方法;
public class MyListener implements HttpSessionListener, HttpSessionAttributeListener{
	@Override
	public void sessionCreated(HttpSessionEvent se){
		System.out.println("HttpSession创建, SessionId: " + se.getSession().getId());
	}
	@Override
	public void sessionDestroy(HttpSessionEvent se){
		System.out.println("HttpSession销毁");
	}
	@Override
	public void attributeAdded(HttpSessionBindingEvent event){
		System.out.println("新增session属性: " + event.getName() + "->" + event.getValue());
	}
	@Override
	public void attributeRemoved(HttpSessionBindingEvent event) { ... }
	@Override
	public void attributeReplaced(HttpSessionBindingEvent event) { ... }
}
2)在web.xml中配置<listener>使监听器生效;
<Listener>
	<listener-class>com.imooc.listener.MyListener</listener-class>
</Listener>
或注解形式: @WebListener
4, 应用场景
1)流量分析统计
创建一个监听器实现ServletContextListener接口和ServletRequestListener接口, 在contextInitialized()中初始化数据, 
在requestInitialized()中动态更新访问时间和访问量, 然后定义一个Servlet用来获取这些数据, 将json串发送到前台, 
前台通过ajax与Servlet交互取得json数据, 最后通过Echarts图表来展示数据;
2)静态数据预加载
创建一个监听器实现ServletContextListener接口, 在contextInitialized()中将一些静态数据存放到ServletContext中, 
然后程序的其他地方可以随时使用这些数据;


>>FreeMarker模板引擎
1, 模板引擎
模板+数据, 经过模板引擎的解析, 得到展现结果, 主流模板引擎: JSP, FreeMarker, Beetl;
freemarker文件以.ftl为后缀;
2, JSP与FreeMarker的区别
JSP是官方标准，执行方式是编译型，执行效率高，开发效率低，扩展能力弱，数据提取用JSTL+EL;
FreeMarker不是官方标准，需要引入freemarker.jar包，执行方式为解释型，执行效率低，开发效率高，扩展能力强，数据提取用内置标签;
注: 引用freemarker时, eclipse会提示安装ftl编辑器, 用于智能提示, 不装也可以;
3, 使用freemarker
目录结构
src
	demo.java
	sample.ftl
1)Demo.java: main()
//加载模板
Configuration config = new Configuration(Configuration.VERSION_2_3_28);  //创建核心配置对象
config.setClassForTemplateLoading(Demo.class, "");  //设置加载的目录
Template t = config.getTemplate("sample.ftl");  //得到模板对象
//创建数据
Map<String, Object> data = new HashMap<>();
data.put("site", "百度");
data.put("url", "http://www.baidu.com");
//产生输出
t.process(data, new OutputStreamWriter(System.out));
2)sample.ftl(模板文件)
${site}-${url}
4, freemarker的基本语法
1)ftl取值
${属性名}  //直接取值
${属性名!默认值}  //使用默认值，如${author!"张三"}
${属性名?string}  //格式化输出，如
	${date?string("yyyy-MM-dd HH:mm:ss SSS")},
	${number?string("0.00")},
	${leader.name}
string用于三目运算符:
${(words?index_of("o") != -1)?string("是", "不是")}
2)条件判断
//单分支-if
data.put("state", 1);
<#if state == 1>状态；正在使用
<#elseif state == 2>状态：闲置
<#else>状态：无效状态
</#if>
??代表判断对象是否为空，如果为空则不输出，如
<#if computer.user??>
用户：${computer.user}
</#if>
注: 在标签外引用变量用${}，在标签内直接使用变量名;
//多分支-switch
<#switch state>
	<#case 1>正在使用<#break>
	<#case 2>闲置<#break>
	<#default>无效状态
</#switch>
3)循环
//循环-List
<#list datas as v>
	${v_index}-${v}
</#list>
注: 迭代变量_index代表索引;
//循环-Map
按key迭代: 
<#list datas?keys as k>
	${k}:${datas[k]}
</#list>
按value迭代:
<#list dates?values as v>
	${v}
</#list>
4)freemarker的内建函数
${words?length}  //长度
${words?index_of("o")}  //第一次出现的索引
${words?replace("o", "*")}  //全部替换
${words?upper_case/lower_case}  //大小写转换
${n?round/floor/ceiling} //四舍五入/向下取整/向上取整
${list?size}  //集合元素的个数
${list?first/last}  //集合的第一个元素/最后一个元素
${list?reverse}  //集合反转
${list?sort}  //集合排序
${list?sort_by("age")}  //集合元素按年龄排序
如 
<#list list?sort_by("age") as c>
	${c.name}-${c.age}
</#list>
5, freemarker与servlet整合
1)新建Dynamic Web工程, 引入freemarker.jar包, 在WebContent目录下新建ftl文件夹,
以后的ftl文件都放在ftl文件夹下;
freemarker中对web提供支持的核心类是FreemarkerServlet, 使用时需要配置该Servlet;
2)配置web.xml
<servlet>
	<servlet-name>freemarker</servlet-name>
	<servlet-class>freemarker.ext.servlet.FreemarkerServlet</servlet-class>
	<init-param> //配置ftl文件目录
		<param-name>TemplatePath</param-name>
		<param-value>/ftl</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>freemarker</servlet-name>
	<url-pattern>*.ftl</url-pattern> 
</servlet-mapping>
3)写servlet与ftl文件
//ListServlet.java
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	List<Employee> list = new ArrayList<>();
	list.add(new Employee("张三", 32, new Date()));
	list.add(new Employee("李四", 38, new Date()));
	request.setAttribute("emps", list);
	request.getRequestDispatcher("employee.ftl").forward(request, response);
}
//employee.ftl
<body>
	<h1>员工信息如下</h1>
	<#list emps as v>
		序号: ${v_index + 1}
		姓名: ${v.ename}
		年龄: ${v.eage}
		入职时间: ${v.date?string("yyyy-MM-dd")}
		<br>
	</#list>
</body>


>>JDBC
1, JDBC基于驱动程序实现与数据库的连接, JDBC是一套接口标准，具体的数据库提供不同的驱动程序来实现JDBC;
2, JDBC的开发流程
1)加载并注册JDBC驱动
下载mysql驱动的jar包, 并引入到工程;
String dbDriver = "com.mysql.cj.jdbc.Driver";  //JDBC驱动类
Class.forName(dbDriver);  //注册驱动类
2)创建数据库连接
String dbURL = "jdbc:mysql://localhost:3306/imooc?useSSL=false&useUnicode=true&characterEncoding=utf-8&
	serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true";  //连接字符串
String dbUsername = "root";  //数据库用户名
String dbPassword = "123456";  //数据库密码
Connection conn = DriverManager.getConnection(dbURL, dbUsername, dbPassword);
注: 不同的数据库系统的连接字符串格式是不同的;
有一种常见的连接异常是由于服务器的防火墙把3306的端口给屏蔽了;
3)创建Statement对象
Statement stmt = conn.createStatement();
String sql = "select * from employee where dname = '" + dname + "'";
ResultSet rs = stmt.executeQuery(sql);
注: 这种查询会发生SQL注入攻击风险，应该用PreparedStatement预编译SQL来代替;
4)遍历查询结果
while(rs.next()){
	int eno = rs.getInt("eno");
	String ename = rs.getString("ename");
	float salary  = rs.getFloat("salary");
}
5)关闭连接
if(conn != null && !conn.isClosed()){
	conn.close();
}
注: 关闭连接的代码应该放在finally块中;
3, SQL注入攻击
1)当输入的dname为: ' or 1=1 or 1='时, 原来的查询就成为:
select * from employee where dname = '' or 1=1 or 1=''; 会查询出所有数据;
使用预编译SQL, 会对输入数据中的特殊字符如'进行转义, 避免SQL注入攻击;
2)PreparedStatement预编译SQL
String sql = "select * from employee where dname = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, dname);
ResultSet rs = pstmt.executeQuery(); //查询操作返回结果集
当输入dname为: ' or 1=1 or 1='时, 预编译后的SQL查询就成为:
select * from employee where dname = '\' or 1=1 or 1=\'';
注: 增删改的写操作统一使用: int cnt = pstmt.executeUpdate(); 返回影响的数据行数;
注: PreparedStatement是Statement的子接口;
3)预编译对SQL语句的解析只有一次，所以效率更高;
4, 事务操作
mysql默认使用自动提交, 使用事务时应先关闭自动提交(又叫开启手动提交);
事务使用commit()进行提交, rollback()进行回滚;
try{
	conn.setAutoCommit(false);
	//... 多条SQL操作
	conn.commit();
}catch(Exception e){
	e.printStackTrace();
	conn.rollback();
}
5, 日期的处理
1)应用程序中的日期类是java.util.Date, 而jdbc中的日期类是java.sql.Date, 后者是前者的子类;
2)java.sql.Date->java.util.Date可以直接转换，如从数据库中提取数据:
java.sql.Date sdDate = rs.getDate("hiredate");
employee.setHiredate(sdDate);
3)java.util.Date->java.sql.Date不能直接转换，需要通过时间戳:
long timestamp = udDate.getTime();
java.sql.Date sdDate = new java.sql.Date(timestamp);
pstmt.setDate(5, sdDate);
6, 连接池
管理与分配数据库的连接, 应用程序->连接池->数据库, 常用的连接池有Druid和C3P0;
1)Druid
首先需要下载druid-1.*.*.jar包, 并引入到test工程;
在test/src目录下新建一个文件druid-config.properties,
test 
	src
		com
		druid-config.properties   //新建的属性文件, 与最外层的包同级
	out		//发布后生成的目录
		production
			test
				com
				druid-config.properties
//druid-config.properties
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/imooc?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
username=root
password=123456
initialSize=10  //可选, druid创建的初始连接数
maxActive=20 //可选, druid创建的最大连接数
然后在java文件中通过druid创建数据库连接需要经过以下三个步骤:
//DruidDemo.java
//加载属性文件
Properties properties = new Properties();
String propertyFile = DruidDemo.class.getResource("/druid-config.properties").getPath(); //通过本java文件寻找druid配置文件的路径
propertyFile = new URLDecoder().decode(propertyFile, "utf-8"); //空格与%20的解码
properties.load(new FileInputStream(propertyFile));
//获取DataSource数据源对象
//创建数据库连接
DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
Connection conn = dataSource.getConnection();
注: 对数据库服务器连接的监控可以通过Navicat的工具->服务器监控查看;
注: 通过Druid管理的连接, 调用conn.close()后连接并没有真正关闭，而是放回到连接池中;
2)C3P0
C3P0的操作与Druid类似, 不同的是C3P0是通过c3p0-config.xml文件来保存配置参数的;
7, Commons DbUtils
Apache对jdbc的操作进行封装的组件, 需要下载commons-dbutils-1.*.jar包并引入到工程;
Commons DbUtils中的核心类是QueryRunner，通过QueryRunner执行增查删改的操作;
Druid + Commons DbUtils 操作数据库如下:
1)查询操作
QueryRunner qr = new QueryRunner(dataSource);
List<Employee> list = qr.query("select * from employee limit ?, 10", 
	new BeanListHandler<>(Employee.class),
	new Object[]{5});  //直接将查询结果存储到实体对象的集合中
注: 不需要取连接对象, 由内部自动进行维护;
2)结合事务进行修改操作
Connection conn = null;
try{
	conn = dataSource.getConnection();
	conn.setAutoCommit(false);
	String s1 = "update employee set salary = salary + 1000 where eno = ?";
	String s2 = "update employee set salary = salary - 500 where eno = ?";
	QueryRunner qr = new QueryRunner();
	qr.update(conn, s1, new Object[]{1001});
	qr.update(conn, s2, new Object[]{1002});
	conn.commit();
}catch(Exception e){
	e.printStackTrace();
	conn.rollback();
}finally{
	conn.close();
}


>>maven
1, maven是项目管理工具, 对java项目进行构建与依赖管理, maven有以下的优点:
1)保证了在不同的IDE下项目的结构相同;
2)自动下载与管理jar包;
3)可扩展的插件机制;
2, maven的下载与安装
下载maven的zip文件, 解压后将其bin目录添加到环境变量, 在cmd中输入: mvn -v 查看其版本号;
3, maven与eclipse的整合
将刚下载的maven添加到eclipse中, 方法: 
Window -> Preferences -> Maven -> Installations -> Add, 选择maven文件夹即可;
4, maven项目标准结构
1)maven的坐标
GroupId: 机构或团体的英文, 采用"逆向域名"形式书写, 如 com.imooc;
ArtifactId: 项目名称, 说明其用途, 如 cms, oa等；
version: 版本号, 采用"版本+单词"的形式, 如 1.0.0.RELEASE;
2)工程结构
maven-first -------------------//maven工程
	src 
		main 
			java --------------//java源代码
			resources ---------//资源目录, 保存配置文件、静态图片等
		test 
			java --------------//测试类的源代码
			resources ---------//测试时使用的资源文件
	target 
		classes ---------------//编译产生的字节码文件(.class)
	pom.xml -------------------//项目对象模型(Preject Object Model)
5, 依赖管理
自动将jar包从远程仓库下载到本地仓库;
远程仓库: search.maven.org;
本地仓库: 本机存放jar包的目录;
//在pom.xml的<project>里添加
<dependencies>
	<dependency>
		<groupId>mysql</groupId>
		<artifictId>mysql-connector-java</artifictId>
		<version>5.1.47</version>
	</dependency>
</dependencies>
maven启动时会自动加载pom.xml文件;
点击保存后, 会在maven工程下生成一个 Maven Dependencies 目录, 用来存放jar包;
注: 从apache的maven中央仓库下载jar包速度太慢，可以配置从国内的阿里云maven仓库下载:
//在pom.xml的<project>里添加
<repositories>
	<repository>
		<id>aliyun</id>
		<name>阿里云</name>
		<url>https://maven.aliyun.com/repository/public</url>
	</repository>
</repositories>
注: 也可通过Maven的配置文件来修改中央仓库和本地仓库的地址;
6, 项目打包
maven项目打包是通过插件来实现的, maven输出jar包插件: maven-assembly-plugin;
普通java工程打包经过以下两个步骤:
1)在pom.xml的<project>里添加
<build>
	<!-- 配置插件 -->
	<plugins>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-assembly-plugin</artifactId>
			<version>2.5.5</version>
			<configuration>
				<archive>
					<manifest>
						<mainClass>com.imooc.maven.PinyinTestor</mainClass>
					</manifest>
				</archive>
				<descriptorRefs>
					<!-- all in one, 在打包时将所有引用的jar合并到输出的jar文件中 -->
					<descriptorRef>jar-with-dependencies</descriptorRef>
				</descriptorRefs>
			</configuration>
		</plugin>
	</plugins>
</build>
2)Run Configurations -> Maven Build -> New Configuration进入配置页面:
Name: build-jar;
Base directory: ${workspace_loc:/mtest}
Goals: assembly:assembly
然后点击Run, 就会在target目录下生成jar包;
7, Maven构建web工程
1)新建普通maven工程mtest, 在mtest/src/main目录下新建webapp目录, 用来存放web资源文件;
2)右击mtest -> Properties -> Maven -> Project Facets进入设置面板:
Project Facet: Dynamic Web Module(3.1);
Runtimes: Apache Tomcat v8.5;
Context root: mtest;
Content directory: src/main/webapp;
完成后的工程主要目录:
mtest
	src
		main
			java
			resources
			webapp	
				WEB-INF
					lib
					web.xml
				index.jsp
8, web项目打包
普通java工程打包经过以下两个步骤:
1)在pom.xml的<project>里添加
<packaging>war</packaging>
<build>
	<plugins>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-war-plugin</artifactId>
			<version>3.2.2</version>
		</plugin>
	</plugins>
</build>
2)Run Configurations -> Maven Build -> New Configuration进入配置页面:
Name: build-war;
Base directory: ${workspace_loc:/mtest}
Goals: package
然后点击Run, 就会在target目录下生成war包;
9, 修改本地仓库
本地仓库默认地址: ${user.home}/.m2/repository, 需要通过配置文件和IDE来修改本地仓库地址;
1)修改maven的配置文件: maven/conf/settings.xml;
//settings.xml
<localRepository>D:/maven-local-repository</localRepository>
2)修改eclipse中的maven本地仓库
Window -> Preferences -> Maven -> User Settings页面:
User Settings: E:\Java\apache-maven-3.8.4\conf\settings.xml;
Update Settings, Reindex;
10, IDEA操作maven
1)IDEA配置maven
刚启动IDEA时点击Configure -> Settings -> Build -> Build Tools -> Maven 配置页面:
Maven home directory: E:\Java\apache-maven-3.8.4;
User settings file: E:\Java\apache-maven-3.8.4\conf\settings.xml;
Local repository: D:\maven-local-repository;
2)创建工程
直接新建工程 -> Maven, 填写工程名、groupId、artifactId、version;
3)IDEA右侧点开Maven选项卡, 直接有Maven常用的命令, 非常方便对工程进行操作;
11, Maven常用命令
使用Maven的命令, 需要先将maven的bin目录添加到环境变量path中;
1)mvn archetype:generate  //创建maven工程
2)mvn compile  //编译源代码
3)mvn test  //执行测试用例
4)mvn clean  //清除产生的项目
5)mvn package  //项目打包
6)mvn install  //将打包后的项目jar包放到本地仓库
//cmd
>>f:
f:>mvn archetype:generate  
f:>cd mtest
f:\mtest>mvn compile
f:\mtest>mvn package


>>MyBatis
1, MyBatis开发流程
1)引入MyBatis依赖;
2)创建核心配置文件;
3)创建实体类(Entity);
4)创建Mapper映射文件;
5)初始化SqlSessionFactory;
6)利用SqlSession对象操作数据;
2, 引入MyBatis依赖
//pom.xml
<dependencies>
	<dependency> <!--MyBatis依赖-->
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis</artifactId>
		<version>3.5.1</version>
	</dependency>
	<dependency> <!--jdbc依赖-->
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<version>5.1.47</version>
	</dependency>
</dependencies>
3, MyBatis环境配置
//mybatis-config.xml, 该配置文件放在main/resources目录下
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="dev"> <!--默认指向的环境id-->
        <!--开发环境-->
        <environment id="dev">
            <!--采用JDBC方式对数据库事务进行commit/rollback-->
            <transactionManager type="jdbc"></transactionManager>
            <!--采用连接池方式管理数据库连接-->
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;characterEncoding=UTF-8"/>
                <property name="root" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
        <!--生产环境-->
        <environment id="prod">
            <transactionManager type="jdbc"></transactionManager>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://192.168.1.155:3306/babytun?useUnicode=true&amp;characterEncoding=UTF-8"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>
</configuration>
4, SqlSessionFactory 与 SqlSession
是MyBatis的核心对象, 用来加载配置文件从而初始化MyBatis框架, 并且创建SqlSession对象; SqlSessionFactory在应用中要全局唯一;
而对数据库表的具体操作由SqlSession对象来完成, SqlSession使用JDBC方式与数据库交互;
为了保证SqlSessionFactory全局唯一, 可以自定义个工具类, 如下:
public class MyBatisUtils {
	private static SqlSessionFactory sqlSessionFactory = null;
	static { //静态块保证了只在类加载时初始化SqlSessionFactory对象一次
		Reader reader = Resources.getResourceAsReader("mybatis-config.xml");
		sqlSessionFactory = new SqlSessionFactory().build(reader);
	}
	public static SqlSession openSession(){
		return sqlSessionFactory.openSession();
	}
	public static void closeSession(SqlSession sqlSession){
		if(sqlSession != null){
			sqlSession.close();
		}
	}
}
5, MyBatis数据查询
1)创建实体类(Entity)
新建com.imooc.mybatis.entity.Goods实体类, 对应 t_goods 数据表;
Goods类的属性GoodsId 与 t_goods数据表的goods_id字段对应;
要开启这种驼峰命名自动转换, 需要在 mybatis-config.xml 中添加配置:
//mybatis-config.xml
<settings>
	<setting name="mapUnderscoreToCamelCase" value="true" />
</setting>
2)创建Mapper XML, 编写SQL语句
在main/resources目录下新建mapper目录, 并在mapper目录下新建 goods.xml 配置文件;
//goods.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="goods">
	<!--无参查询-->
    <select id="selectAll" resultType="com.imooc.mybatis.entity.Goods">
        select * from t_goods order by goods_id desc limit 10
    </select>
	<!--单参数查询-->
	<select id="selectById" parameterType="Integer" resultType="com.imooc.mybatis.entity.Goods">
		select * from t_goods where goods_id = #{value}
	</select>
	<!--多参数查询, 参数类型指定为Map-->
	<select id="selectByPriceRange" parameter="java.util.Map" resultType="com.imooc.mybatis.entity.Goods">
		select * from t_goods where current_price between #{min} and #{max} limit #{limit}
	</select>
</mapper>
需要在mybatis-config.xml文件中声明该mapper:
//mybatis-config.xml
<mappers>
	<mapper resource="mappers/goods.xml"></mapper>
</mappers>
3)SqlSession执行SQL语句
SqlSession sqlSession = MyBatisUtils.openSession();
//无参查询
List<Goods> list = sqlSession.selectList("goods.selectAll"); //如果"selectAll"全局唯一, 那么可以省略命名空间goods
//单参数查询
Goods goods = sqlSession.selectOne("goods.selectById", 1001);
//多参数查询
Map map = new HashMap();
map.put("min", 500);
map.put("max", 1000);
map.put("limit", 10);
List<Goods> list = sqlSession.selectList("goods.selectByPriceRange", map);
MyBatisUtils.closeSession(sqlSession);
6, 数据写操作
事务: 客户端 -> 事务日志 ->(commit) ->数据库
数据的写入操作要使用commit()来进行提交;
1)插入<insert>
//goods.xml
<insert id="insert" parameterType="com.imooc.mybatis.entity.Goods">
	insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id)
		values (#{title}, #{subTitle}, #{originalCost}, #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId})
	<!--当插入成功后, 将新的主键id回添到java对象-->
	<selectKey resultType="Integer" keyProperty="goodsId" order="AFTER">
		select last_insert_id()
	</selectKey>
</insert>
注: 也可以使用 useGeneratedKeys 属性来代替 <selectKey>元素, 如下: 
<insert id="insert" parameterType="com.imooc.mybatis.entity.Goods"
	useGeneratedKeys="true" keyProperty="goodsId" keyColulmn="goods_id">
	insert into ***
</insert>
注: useGeneratedKeys属性与<selectKey>元素的区别:
前者隐式将主键id回舔到java对象, 但仅支持"自增主键"的数据库;
后者需要显示调用mysql的函数, 但支持所有关系型数据库;
//java
SqlSession sqlSession = null;
try{
	sqlSession = MyBatisUtils.openSession();
	Goods goods = new Goods();
	goods.setTitle("测试商品");
	int num = sqlSession.insert("goods.insert", goods);
	sqlSession.commit();
}catch(Exception e){
	e.printStackTrace();
	sqlSession.rollback();
}finally{
	MyBatisUtils.closeSession(sqlSession);
}
2)更新<update>
//goods.xml
<update id="update" parameterType="com.imooc.mybatis.entity.Goods">
	update t_goods set title=#{title}, category_id=#{categoryId} where goods_id=#{goodsId}
</update>
//java
Goods goods = sqlSession.selectOne("goods.selectById", 1206);  //先获取到指定id的商品
goods.setTitle("苹果");
goods.setCatetoryId(5);
sqlSession.update("goods.update", goods);
sqlSession.commit();
3)删除<delete>
//goods.xml
<delete id="delete" parameterType="Integer">
	delete from t_goods where goods_id=#{id}
</delete>
//java
sqlSession.delete("goods.delete", 1206);
sqlSession.commit();
7, 预防SQL注入攻击
1)MyBatis的两种传参方式
${}: 未经任何处理的文本替换;
#{}: 使用预编译传值, 可以预防SQL注入;
8, MyBatis动态SQL
动态SQL是指根据参数数据来动态组织SQL;
<select id="dynamicSQL" parameterType="java.util.Map" resultType="com.imooc.mybatis.entity.Goods">
	select * from t_goods
	<where>
		<if test="categoryId != null">
			and category_id = #{categoryId}
		</if>
		<if test="currentPrice != null">
			and current_price &lt; #{currentPrice}
		</if>
	</where>
</select>
注: 也可以将<where>标签换成 where 1=1, 保证后面紧跟的and不会导致语法错误;
9, MyBatis缓存
1, 一级缓存默认开启, 缓存范围为SqlSession会话, 二级缓存手动开启, 缓存范围为 mapper namespace;
缓存开启后, 默认所有查询操作均使用缓存, 写操作commit提交时会强制清空一二级缓存;
2, 开启二级缓存
//goods.xml
<mapper namespace="goods">
	<cache eviction="LRU" flushInterval="600000" size="512" readOnly="true" />
	<select .....>
</mapper>
cache标签中各个元素的作用:
1)eviction
缓存的清除策略, 当缓存对象数量达到上限或者到达缓存清除时间, 自动触发对应算法对缓存对象清除;
LRU: 最近最久未使用, 先移除, 默认
FIFO: 先进先出
SOFT: 软引用
WEAK: 弱引用
2)flushInterval
代表间隔多长时间清除缓存, 单位毫秒;
3)size
缓存对象或集合(1个集合算1个)的数量上限;
4)readOnly
设置为true表示每次从缓存中取出的是缓存对象本身, 这种执行效率较高;
3, useCache和flushCache属性
<select ... useCache="false"> 表示该查询不使用缓存;
<select/insert/update/delete ... flushCache="true">  表示执行完该SQL后(无需等到commit)马上强制清空缓存;
10, 多表关联查询
有两种使用方式:
1)使用Map保存关联查询结果
//goods.xml
<mapper namespace="goods">
	<!--参数类型用LinkedHashMap使查询结果与数据库的字段顺序保持一致-->
	<select id="selectGoodsMap" resultType="java.util.LinkedHashMap">
		select g.*, c.category_name from t_goods g left join t_category c on g.category_id = c.category_id;
	</select>
</mapper>
//java
List<Map> list = sqlSession.selectList("goods.selectGoodsMap");
2)使用ResultMap将查询结果映射为Java对象
//定义Java对象
public class GoodsDto{
	private Goods goods = new Goods();  //使用前面已经定义好的实体类
	private String categoryName;
	//省略constructor, getter, setter
}
//定义resultMap
<resultMap id="rmGoods" type="com.imooc.mybatis.dto.GoodsDTO">
	<!--设置主键字段与属性映射-->
	<id property="goods.goodsId" column="goods_id" />
	<!--设置非主键字段与属性映射-->
	<result property="goods.title" column="title" />
	<result property="categoryName" column="category_name" />
</resultMap>
<select id="selectGoodsDTO" resultMap="rmGoods">
	select g.*, c.category_name from t_goods g left join t_category c on g.category_id = c.category_id
</select>
//java
List<GoodsDTO> list = sqlSession.selectList("goods.selectGoodsDTO");
11, 多表级联查询
t_goods - t_goods_detail(一对多关系)
//Goods.java
public class Goods{
	private Integer goodsId;
	//其他t_goods表的属性
	List<GoodsDetail> goodsDetails;  //一个商品对应多个商品详情
}
//GoodsDetail.java
public class GoodsDetail{
	private Integer gdId;
	//其他t_goods_details表的属性
	private Goods goods;  //一个商品详情对应一个商品
}
1)OneToMany级联查询
//goods.xml
<resultMap id="rmGoodsDetail" type="com.imooc.mybatis.entity.Goods">
	<id property="goodsId" column="goods_id" />
	<collection property="goodsDetails" select="goodsDetail.selectByGoodsId" column="goods_id" />
</resultMap>
<select id="selectOneToMany" resultMap="rmGoodsDetail">
	select * from t_goods
</select>
2)ManyToOne级联查询
//goods_detail.xml
<resultMap id="rmDetailGoods" type="com.imooc.mybatis.entity.GoodsDetail">
	<id property="gdId" column="gd_id" />
	<result property="goods_id" column="goods_id" />
	<association property="goods" select="goods.selectById" column="goods_id" />
</resultMap>
<select id="selectManyToOne" resultMap="rmDetailGoods">
	select * from t_goods_detail
</select>
12, PageHelper分页插件
1)mavan引入PageHelper与jsplparser依赖
<!--pagehelper-->
<dependency>
	<groupId>com.github.pagehelper</groupId>
	<artifactId>pagehelper</artifactId>
	<version>5.1.10</version>
</dependency>
<!--jsqlparser-->
<dependency>
	<groupId>com.github.jsqlparser</groupId>
	<artifactId>jsqlparser</artifactId>
	<version>2.0</version>
</dependency>
2)mybatis-config.xml增加Plugin配置
<plugins>
	<!--启用PageHelper分页插件-->
	<plugin interceptor="com.github.pagehelper.PageInterceptor">
		<property name="helperdialect" value="mysql"/>
		<property name="reasonable" value="true"/>
	</plugin>
</plugins>
3)代码中使用PageHelper.startPage()自动分页
//goods.xml
<!--分页查询-->
<select id="selectPage" resultType="com.imooc.mybatis.entity.Goods">
	select * from t_goods where current_price &lt; 1000
</select>
//java
SqlSession sqlSession = MyBatisUtil.openSession();
PageHelper.startPage(2, 10);
Page<Goods> page= (Page) sqlSession.selectList("goods.selectPage");
System.out.println("总页数: " + page.getPages());
System.out.println("总记录数: " + page.getTotal());
System.out.println("开始行号: " + page.getStartRow());
System.out.println("结束行号: " + page.getEndRow());
System.out.println("当前页码: " + page.getPageNum());
List<Goods> data = page.getResult();  //当前页数据
for(Goods g : data) {
	System.out.println(g);
}
MyBatisUtil.closeSession(sqlSession);
13, MyBatis批处理
//goods.xml
<!--批处理插入-->
<insert id="batchInsert" parameterType="java.util.List">
	insert into t_goods(title, sub_title, ...) values 
	<forearh collection="list" item="item" index="index" separator=",">
		(#{item.title, item.subTitle, ...}
	</foreach>
</insert>
<!--批处理删除-->
<delete id="batchDelete" parameterType="java.util.List">
	delete from t_goods where goods_id in
	<foreach collection="list" item="item" index="index" open="(" close=")" separator=",">
		#{item}
	</foreach>
</delete>
//java
List<Goods> list = new ArrayList<>();
for(int i = 1; i <= 10000; i++){
	Goods goods = new Goods();
	goods.setTitle("测试商品" + i);
	//setter其他字段
	list.add(goods);
}
sqlSession.insert("goods.batchInsert", list);
sqlSession.commit();
注: 批量插入的局限:
1)无法获得插入数据的id;
2)批量生成的SQL太长, 可能会被服务器拒绝;
15, MyBatis注解开发
1)定义接口, 将SQL通过注解写在接口方法上
pacakge com.imooc.mybatis.dao;
public interface GoodsDAO{
	@Select("select * from t_goods where goods_id = #{id}")
	public Goods selectById(@Param("id") int id);
}
2)在mybatis-config.xml中增添mapper配置
<mappers>
	<mapper class="com.imooc.mybatis.dao.GoodsDAO" />
	<!--或配置整个dao包-->
	<pacakge name="com.imooc.mybatis.dao" />
</mappers>
3)java
GoodsDAO goodsDAO = sqlSession.getMapper(GoodsDAO.class);
Goods goods = goodsDAO.selectById(1001);


>>日志管理
1, 常用的日志组件有 log4j, logback等, 以logback为例:
//在pom.xml中引入logback依赖
<dependency>
	<groupId>ch.qos.logback</groupId>
	<artifactId>logback-classic</artifactId>
	<version>1.2.3</version>
</dependency>
//resources/logback.xml, 定义logback的配置
<configuration>
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.sss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    <!--
        日志输出级别(优先级高到低):
        error: 错误 - 系统的故障日志
        warn: 警告 - 存在风险或使用不当
        info: 一般性消息
        debug: 程序内部用于调试信息
        trace: 程序运行的跟踪信息
    -->
    <root level="debug">
        <appender-ref ref="console" />
    </root>
</configuration>
注: 开发阶段一般将level设置为debug, 而程序上线后应将level设置成info或更高级别;
2, 将日志记录到文件
//resources/logback.xml
<?xml version="1.0" encoding="UTF-8" ?>
<configuration>
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>[%thread] %d %level %logger{10} - %msg%n</pattern>
        </encoder>
    </appender>
    <appender name="log" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>F:/logs/history.%d.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>[%thread] %d %level %logger{10} - %msg%n</pattern>
        </encoder>
    </appender>
    <root level="debug">
        <appender-ref ref="console" />
    </root>
    <logger name="com.imooc.restful.interceptor.MyInterceptor" level="info" additivity="false">
		<appender-ref ref="log"/>
	</logger>
</configuration>
注: RollingFileAppender表示产生按天滚动的日志文件;
additivity属性为false表示只向文件而不向控制台输出;
//使用拦截器将用户的访问信息输出到文件
public class MyInterceptor implements HandlerInterceptor{
	private Logger logger = LoggerFactory.getLogger(MyInterceptor.class);
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        StringBuilder sb = new StringBuilder();
        sb.append(request.getRemoteAddr());
        sb.append(" | ");
        sb.append(request.getRequestURL());
        sb.append(" | ");
        sb.append(request.getHeader("user-agent"));
        sb.append(" | ");
        logger.info(sb.toString());  //输出info级别的日志
        return true;
    }
}


>>Spring IoC
1, Spring框架的核心是IoC和AOP; 
IoC(Inverse of Control)控制反转, 由IoC容器来创建与管理对象, 使用者从IoC容器获取对象;
DI(Dependency Injection)依赖注入是具体技术实现, 在java中利用反射来实现对象注入;
2, 管理bean对象的三种配置方式
1)基于XML配置bean
2)基于注解配置bean
3)基于java代码配置bean
3, 基于XML实现IoC
1)引入Spring依赖 - pom.xml
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.2.6.RELEASE</version>
</dependency>
2)xml配置bean对象 - resources/applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--利用构造函数实例化对象: 默认构造函数-->
    <bean id="apple1" class="com.imooc.spring.ioc.entity.Apple" />
	<!--利用构造函数实例化对象: 带参构造函数-->
	<bean id="apple2" class="com.imooc.spring.ioc.entity.Apple">
		<constructor-arg name="title" value="红富士" />
		<constructor-arg name="origin" value="欧洲" />
		<constructor-arg name="color" value="红色" />
	</bean>
	<!--利用setter给对象赋值(注入静态属性)(会首先调用默认构造函数)-->
	<bean id="sweetApple" class="com.imooc.spring.ioc.entity.Apple">
        <property name="title" value="红富士" />
        <property name="color"  value="红色" />
        <property name="origin" value="欧洲" />
    </bean>
	<!--利用工厂获取对象: 工厂的静态方法(实际中使用较少)-->
	<bean id="apple3" class="com.imooc.spring.ioc.factory.AppleFactory" factory-method="createSweetApple" />
	<!--利用工厂获取对象: 工厂的实例方法(实际中使用较少)-->
	<bean id="factory" class="com.imooc.spring.ioc.factory.AppleFactory" />
	<bean id="apple4" factory-bean="factory" factory-method="createSoftApple" />
	<!--注入对象: 利用构造函数-->
	<bean id="andy" class="com.imooc.spring.ioc.entity.Child">
		<constructor-arg name="name" value="安迪" />
		<constructor-arg name="apple" ref="sweetApple" />
	</bean>
	<!--注入对象: 利用setter-->
	<bean id="lily" class="com.imooc.spring.ioc.entity.Child">
        <property name="name" value="莉莉" />
        <property name="apple" ref="sweetApple" />
    </bean>
</beans>
注: <bean>标签里的id也可以写成name, id只支持一个标识, 而name可支持多个标识, 如 name="apple1 fruit1";
注: id和name都允许在不同配置文件中出现重复, 后加载的覆盖前加载的;
3)java: 从IoC容器获取bean
//加载单个配置文件
ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");  //ApplicationContext对象就表示IoC容器
Apple sweetApple = context.getBean("sweetApple", Apple.class);
//Apple sweetApple = (Apple)context.getBean("sweetApple");
//加载多个配置文件
String[] configLocations = new String[]{"classPath:applicationContext-1.xml", "classPath:applicationContext-2.xml"};
ApplicationContext context = new ClassPathXmlApplicationContext(configLocations);
4)路径表达式
classpath:config.xml  //加载classpath(即target/classes)下的指定文件
classpath:com/imooc/config.xml  //classpath下(不包含jar)的指定包中的文件
classpath*:com/imooc.config.xml  //classpath下(包含jar)的指定包中的文件
classpath:config-*.xml  //classpath下以config开头的文件
classpath:com/**/config.xml  //classPath下com包下包含任何子包里面的config.xml
file:c:/config.xml  //c盘根路径的config.xml
5)注入集合类型
//注入List/Set
<bean id="..." class="...">
	<property name="someList">
		<list>
			<value>具体值</value> <!--List元素为基本类型-->
			<ref bean="beanId"></ref> <!--List元素为对象-->
		</list>
	</property>
</bean>
注: 注入Set只需把list改成set;
//注入Map
<bean id="..." class="...">
	<property name="someMap">
		<map>
			<entry key="k1" value="v1" /> <!--value为基本类型-->
			<entry key="k2" value-ref="beanId" /> <!--value为对象: 引用外部bean-->
			<entry key="k3">
				<bean class="...">
					...
				</bean>
			</entry> <!--value为对象: 内部bean-->
		</map> 
	</property>
</bean>
//注入Properties
<bean id="..." class="...">
	<property name="someProperties">
		<props>
			<prop key="k1">v1</prop>
		</props>
	</property>
</bean>
注: properties的key和value都必须是字符串类型;
在java中获取property的值使用getProperty()函数: 
context.getBean("company", Company.class).getInfo().getProperty("address");
6)查看容器内对象
String[] beanNames = context.getBeanDefinitionNames();
for(String beanName: beanNames){
	//名称: beanName
	//内容: context.getBean(beanName)
	//类型: context.getBean(beanName).getClass().getName()
}
7)IoC容器的销毁
((ClassPathXmlApplicationContext)context).registerShutdownHook();
4, bean对象的作用域及生命周期
<bean id="..." class=".." scope="..." />
1)scope属性清单
singleton  //单例(默认值), 每个容器内全局唯一
prototype  //多例, 每次使用都会创建一个实例
request  //web环境下, 每一次独立请求存在唯一实例
session  //web环境下, 每一个session存在唯一实例
websocket  //每一次WebSocket连接存在唯一实例
2)单例与多例的区别
-----------------------------------------------------------
				singleton			prototype
对象数量	   	全局唯一			存在多个
实例化时机		IoC容器启动时		getBean()或对象注入时
线程安全问题	存在			不存在
执行效率		高					低
------------------------------------------------------------
注: 实际使用中dao、service及controller对象一般都默认为单例;
3)bean的生命周期
<bean id="..." class="..." init-method="init" destroy-method="destroy">
	//...
</bean>
生命周期:
(容器初始化解析XML) -> 对象实例化 -> (为对象注入属性) -> 调用init-method初始化方法 -> (容器初始化完毕) 
	-> 执行业务代码 -> (容器销毁) -> 调用destroy-method方法释放资源 -> (容器销毁完毕)
5, 基于注解实现IoC
注解是将配置信息写在源代码中, 适合轻量级的应用项目;
1)Spring中三类注解
组件类型注解: 声明当前类的功能;
自动装配注解: 根据属性特征自动注入对象;
元数据注解: 更细化的辅助IoC容器管理对象的注解;
2)组件类型注解
@Component: 通用注解, 该注解描述的类将被IoC容器管理并实例化;
@Controller: 语义注解, 说明当前类是MVC应用中的控制器类;
@Service: 语义注解, 说明当前类是Service业务服务类;
@Repository: 语义注解, 说明当前类用于业务持久层, 通常描述对应Dao类;
注: 四种组件类型注解直接放在类名上;
括号内为bean的id, id可省略, 默认为首字母小写的类名;
@Repository("userDao")
public class UserDao{
	//...
}
3)XML配置开启组件扫描
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">
        <!--在IoC容器初始化时自动扫描四种组件注解并完成实例化-->
        <context:component-scan base-package="com.imooc" />
</beans>
4)自动装配注解
按类型装配(不推荐): @Autowired, @Inject;
按名称装配: @Resource(优先按名称, 再按类型只能匹配);
注: 自动装配注解放在属性或setter方法上, 如果放在属性上, 则底层直接给属性赋值, 不再执行setter方法;
@Resource(name="userDao")  //name属性可省略
如果设置了name属性, 则按name在IoC容器中将bean注入;
如果未设置name属性, 则
以属性名作为bean name在IoC容器中匹配bean, 如有匹配则注入;
若按属性名未匹配, 则按类型匹配, 同@Autowired;
使用建议: 在使用@Resource对象时推荐设置name或保持属性名与bean名称一致;
5)元数据注解
为IoC容器管理bean对象提供辅助功能的注解;
@Primary  //按类型装配时出现多个相同类型对象, 拥有此注解对象优先被注入
@PostConstruct  //描述方法, init-method配置的注解版本
@PreDestroy  //描述方法, destroy-method配置的注解版本
@Scope  //设置对象的scope属性
@Value  //为属性注入静态数据
注: @Value的使用:
@Service
public class UserService{
	@Value("imooc.com")
	private String metaData;
}
实际项目中经常把数据写在配置文件中, 分为以下三步:
//添加配置文件: resources/config.properties
metaData=imooc.com
connection.driver=jdbc
connection.user=root
connection.password=123456
//在applicationContext.xml中添加配置用来加载config.properties
<context:property-placeholder location="classpath:config.properties" />
//java程序中使用注解@Value
@Value("${metaData}")
private String metaData;
@Value("${connection.password}")
private String password;
6, 基于Java Config实现IoC
1)优势
完全摆脱XML的束缚, 使用独立java类管理对象与依赖;
可对配置进行集中管理, 避免注解配置的分散化;
可以在编译时进行依赖检查;
2)java config核心注解
@Configuration  //描述类, 说明当前类是配置类, 完全替代xml
@Bean  //描述方法, 方法返回对象将被IoC容器管理, beanId默认为方法名;
@ImportResource  //描述类, 加载静态文件, 可使用@Value注解获取
@ComponentScan  //描述类, 同xml的<context:component-scan>标签
3)实例
//Config.java
@Configuration
@ComponentScan(basePackages="com.imooc")  //扫描其他的组件注解
public class Config {  //当前类是配置类, 用于替代applicationContext.xml
	@Bean
	public UserDao userDao(){  //利用方法创建对象, beanId=方法名
		UserDao userDao = new UserDao();
		return userDao;
	}
	@Bean
	@Scope("prototype")  //可与注解配置搭配使用, 如设置为多例
	@Primary
	public UserService userService(UserDao userDao){  //依赖注入, 先按name注入, name不存在则按类型注入
		UserService userService = new UserService();
		userService.setUserDao(userDao);
		return userService;
	}
}
//SpringApplication.java
ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
7, Spring Test测试模块
1)Spring Test可对JUnit进行整合, 通过Spring Test可在JUnit单元测试时自动初始化IoC容器;
2)整合过程
maven工程依赖spring-test;
利用@RunWith与@ContextConfiguration描述测试用例类;
3)实例
@RunWith(SpringJUnit4ClassRunner.class)  //将junit4的执行权交由Spring Test, 在测试用例执行前自动初始化IoC容器
@ContextConfiguration(locations = {"classpath:applicationContext.xml"})  //说明要加载的配置文件
public class SpringTestor {
	@Resource
	private UserService userService;
	@Test
	public void testUserService(){
		userService.createUser();
	}
}


>>Spring AOP
1, 基本概念
AOP(Aspect Oriented Programming)面向切面编程, 将通用的、与业务无关的功能抽象封装为切面类, 
切面可配置在目标方法的执行前或执行后运行, 做到即插即用;
2, aop的使用步骤
1)在pom.xml中引入ioc与aop依赖
<dependencies>
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
		<version>5.2.6.RELEASE</version>
	</dependency>
	<!--aspectjweaver是spring aop的底层依赖-->
	<dependency>
		<groupId>org.aspectj</groupId>
		<artifactId>aspectjweaver</artifactId>
		<version>1.9.5</version>
	</dependency>
</dependencies>
2)编写切面类与切面方法
public class MethodAspect{  //切面类
	public void printTime(JoinPoint joinPoint){  //切面方法, 必须包含JoinPoint连接点参数
		SimpleDateFormat sdf = new SimpleDateFormat("YYYY-MM-dd HH:mm:ss sss");
		String time = sdf.format(new Date());
		String className = joinPoint.getTarget().getClass().getName();  //获取目标类的名称
		String methodName = joinPoint.getSignature().getName();  //获取目标方法的名称
		System.out.println("--->" + time + ":" + className + "." + methodName);
	}
}
3)在applicationContext.xml中进行aop配置
<!--ioc配置-->
<bean id="methodAspect" class="com.imooc.spring.aop.aspect.MethodAspect"/>
<!--aop配置-->
<aop:config>
	<!--PointCut 切点, 使用execution表达式描述切面的作用范围-->
	<aop:pointcut id="pointcut" expression="execution(public * com.imooc..*.*(..))"></aop:pointcut>
	<!--定义切面类-->
	<aop:aspect ref="methodAspect">
		<aop:before method="printExecutionTime" pointcut-ref="pointcut"/>
	</aop:aspect>
</aop:config>
3, 关键概念
1)Aspect 
切面, 具体的可插拔组件功能类, 通常一个切面只实现一个通用功能;
2)Target Class/Method
目标类、目标方法, 指真正要执行与业务相关的方法;
3)PointCut
切点, 使用execution表达式说明切面要作用在系统的哪些类上;
4)JoinPoint
连接点, 切面运行过程中是包含了目标类/方法元数据的对象;
5)Advice 
通知, 说明具体的切面的执行时机, Spring包含了五种不同类型通知;
4, JoinPoint核心方法
1)getTarget()
获取IoC容器内目标对象;
2)getSignature()
获取目标方法;
3)getArgs()
获取目标方法参数;
Object[] args = joinPoint.getArgs();
System.out.println("--->参数个数: " + args.length);
for(Object arg : args){
	System.out.print(arg + "  ");
}
5, PointCut切点表达式
1)切点表达式描述切面的作用范围;
execution(public * com.imooc..*.*(..)),  可匹配如下具体的方法:
public void com.imooc.spring.ioc.service.UserService.createUser(形参1, 形参2);
public * com.imooc..*Service.*(..)可匹配如UserService等以Service结尾的类的任意方法;
void com.imooc..*.*(..)可匹配没有返回值的方法;
* com.imooc..*.*()可匹配没有参数的方法;
* com.imooc..*.*(String, *)可匹配只有两个参数并且第一个参数为String类型的方法;
* com.imooc..*Service.create*(..)可匹配以Service结尾的类并且以create开头的方法;
其中, * - 通配符, .. - 包通配符, (..) - 参数通配符; 
public可省略, 默认为public;
6, AOP通知
AOP有五种通知类型
1)Before Advice  //前置通知, 目标方法运行前执行;
<aop:before method="doBefore" pointcut-ref="pointcut"/>
2)After Advice  //后置通知, 目标方法运行后执行, 类似于finally;
<aop:after method="doAfter" pointcut-ref="pointcut"/>
注: 后置通知无法获取目标方法的返回值或内部抛出的异常, 如果需要必须使用下面两种通知类型;
3)After Returning Advice  //返回后通知, 目标方法返回数据后执行;
//切面方法
public String doAfterReturning(JoinPoint joinPoint, Object ret){
	System.out.println("<---触发返回后通知, 返回值: " + ret);
}
//配置
<aop:after-returning method="doAfterReturning" pointcut-ref="pointcut" returning="ret"/>
注: 返回后通知, 切面方法需提供第二个参数用来接收目标方法的返回值;
4)After Throwing Advice  //异常通知, 目标方法抛出异常后执行;
//切面方法
public void doAfterThrowing(JoinPoint joinPoint, Throwable th){
	System.out.println("<---触发异常通知, 异常: " + th.getMessage());
}
//目标方法
public void createUser(String username){
	if(username.equals("zhao")){
		throw new RuntimeException("用户已存在");
	}
}
//配置
<aop:after-throwing method="doAfterThrowing" pointcut-ref="pointcut" throwing="th"/>
5)Around Advice  //环绕通知, 自定义通知执行时机, 可决定目标方法是否运行;
//切面方法
public Object check(ProceedingJoinPoint pjp){  //ProceedingJoinPoint是JoinPoint的升级版, 在原有功能外, 还可以控制目标方法是否执行
	//方法执行前的操作
	long stime = new Date().getTime();
	//执行目标方法, 返回目标方法的返回值
	Object ret = pjp.proceed();
	//方法执行后的操作
	long etime = new Date().getTime();
	System.out.println("方法的执行时间: " + (etime-stime) + "毫秒");
	return ret;
}
//配置
<aop:around method="check" pointcut-ref="pointcut"/>
注: 环绕通知的功能最强大, 可完成前面四种基本通知的操作;
7, aop的注解形式
1)pom.xml中增加相关依赖
2)applicationContext.xml中开启IoC组件扫描以及启用AOP注解模式
<context:component-scan base-package="com.imooc" />
<aop:aspectj-autoproxy />
3)在切面类和切面方法中使用注解
@Component  //标记切面类为组件
@Aspect  //切面类的注解
public class MethodChecker{
	@Around("execution(* com.imooc..*Service.*(..))")  //环绕通知的注解, 参数为切点表达式
	public Object check(ProceedingJoinPoint pjp){
		//....
	}
}
注: 其他几种通知的注解分别为: @Before, @After, @AfterReturning, @AfterThrowing;
8, aop的实现原理
1)代理模式-静态代理
代理模式是指通过代理对象来对原有对象(委托类的对象)的功能进行扩展;
静态代理是值必须手动创建代理类的代理模式;
//UserService(接口)
public interface UserService{
	public void createUser();
}
//UserServiceImpl(实现类)
public class UserServiceImpl implements UserService{
	public void createUser(){
		System.out.println("执行创建用户业务逻辑");
	}
}
//UserServiceProxy(代理类)
public class UserServiceProxy implements UserService{
	private UserService userService;  //持有委托类的对象
	public UserServiceProxy(UserService userService){	//通过带参构造函数实例化委托类对象
		this.userService = userService;
	}
	public void createUser(){  //对委托类的目标方法进行功能扩展
		System.out.println("当前时间: " + new Date());
		userService.createUser();
	}
}
注: 可以嵌套使用代理模式;
2)JDK动态代理
根据接口的结构自动生成代理类, 来对目标方法进行扩展;
3)Spring AOP基于代理类实现功能动态扩展, 有两种形式:
目标类实现了某接口, 通过JDK动态代理实现功能扩展;
目标类没有实现接口, 通过CGLib组件实现功能扩展;


>>Spring JDBC
1, JdbcTemplate是Spring JDBC的核心类, 提供数据CRUD方法;
Spring JDBC是对JDBC轻量级的封装, 比Mybatis的执行效率要高;
2, Spring JDBC的使用步骤
1)maven工程引入spring-jdbc依赖;
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.2.6.RELEASE</version>
</dependency>
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-jdbc</artifactId>
	<version>5.2.6.RELEASE</version>
</dependency>
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
	<version>8.0.27</version>
</dependency>
2)applicationContext.xml中配置DataSource数据源;
<!--(Datasource)数据源-->
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
	<property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
	<property name="url" value="jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true"/>
	<property name="username" value="root"/>
	<property name="password" value="123456"/>
</bean>
<!--IoC: JdbcTemplate-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
	<property name="dataSource" ref="dataSource"/>
</bean>
<!--IoC: Dao-->
<bean id="employeeDao" class="com.imooc.spring.jdbc.dao.EmployeeDao">
	<property name="jdbcTemplate" ref="jdbcTemplate"/>
</bean>
3)在dao中注入JdbcTemplate对象, 实现数据CRUD;
public class EmployeeDao{
	private JdbcTemplate jdbcTemplate;
	//省略getter/setter
	public Employee findById(int eno){
		String sql = "select * from employee where eno = ?";
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{eno}, new BeanPropertyRowMapper<Employee>(Employee.class));
        return employee;
	}
}
3, JdbcTemplate的数据查询方法
1)queryForObject()  //查询单条数据
String sql = "select * from employee where eno = ?";
Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{1001}, new BeanPropertyRowMapper<Employee>(Employee.class));
2)query()  //查询多条数据
String sql = "select * from employee where dname = ?";
List<Employee> list = jdbcTemplate.query(sql, new Object[]{"研发部"}, new BeanPropertyRowMapper<Employee>(Employee.class));
3)queryForList()  //将查询结果作为Map进行封装
String sql = "select eno as empno, salary as sal from employee where dname = ?";
List<Map<String, Object>> map = jdbcTemplate.queryForList(sql, new Object[]{"研发部"});
4, JdbcTemplate的数据写入方法
数据的插入、更新、删除等写操作统一使用update()函数;
1)数据插入
String sql = "insert into employee(eno, ename) values (?, ?)";
jdbcTemplate.upadte(sql, new Object[]{1001, "zhao"});
2)数据更新
String sql = "update employee set salary = salary + ? where eno = ?";
int count = jdbcTemplate.update(sql, new Object[]{500, 1001});  //返回更新的数据条数
3)数据删除
String sql = "delete from employee where eno = ?";
int count = jdbcTemplate.update(sql, new Object[]{1001});  //返回删除的数据条数
5, 编程式事务
1)编程式事务是指通过代码手动提交与回滚事务;
SpringJDBC通过TransactionManager事务管理器实现事务控制, commit/rollback;
2)编程时事务的步骤
//applicationContext.xml
<!--IoC: 事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource" />
</bean>
<!--IoC: service中注入事务管理器属性-->
<bean id="employeeService" class="com.imooc.spring.jdbc.service.EmployeeService">
	<property name="employeeDao" ref="employeeDao"/>
	<property name="transactionManager" ref="transactionManager"/>
</bean>
//EmployeeService.java
public EmployeeService{
	private EmployeeDao employeeDao;
	private DataSourceTransactionManager transactionManager;
	//省略getter/setter
	public void batchImport(){
        //事务默认的标准配置
        TransactionDefinition definition = new DefaultTransactionDefinition();
        //开始一个事务
        TransactionStatus status = transactionManager.getTransaction(definition);
        try {
            //....
            transactionManager.commit(status); //事务提交
        } catch (Exception e) {
            transactionManager.rollback(status); //事务回滚
            e.printStackTrace();
        }
    }
}
6, 声明式事务
1)声明式事务是指通过配置形式自动实现事务控制, 本质就是AOP环绕通知;
当目标方法执行成功时, 自动提交事务; 当目标方法抛出运行时异常时, 自动回滚事务;
2)声明式事务的步骤
//pom.xml中加入aop的依赖
//applicationContext.xml中的配置
配置声明式事务需要三个步骤, 完整的applicationContext.xml如下:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--数据源-->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url"
                  value="jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    <!--IoC: JdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>
	<!--IoC: Dao-->
    <bean id="employeeDao" class="com.imooc.spring.jdbc.dao.EmployeeDao">
        <property name="jdbcTemplate" ref="jdbcTemplate"/>
    </bean>
	<!--IoC: Service-->
    <bean id="employeeService" class="com.imooc.spring.jdbc.service.EmployeeService">
        <property name="employeeDao" ref="employeeDao"/>
    </bean>
    <!--第一步: IoC: 事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!--第二步: 事务通知配置-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="batchImport" propagation="REQUIRED"/>
			<tx:method name="batch*" propagation="REQUIRED"/>  <!--使用通配符*来匹配多个方法-->
			<tx:method name="find*" propagation="NOT-SUPPORTED" read-only="true"/> <!--表示对该类方法不使用事务-->
			<tx:method name="*" propagation="REQUIRED"/> <!--其他方法-->
        </tx:attributes>
    </tx:advice>
    <!--第三步: 定义声明式事务的作用范围-->
    <aop:config>
        <aop:pointcut id="pointcut" expression="execution(* com.imooc..*Service.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut"/>
    </aop:config>
</beans>
7, 事务传播方式
1)事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式;
2)配置方式
XML: <tx:method name="..." propagation="REQUIRED"/>
注解: @Transactional(propagation=Propagation.REQUIRED)
3)事务传播的七种类型
事务传播有七种类型, 80%以上的场景都使用默认的"REQUIRED";
REQUIRED(默认): f1(f2, f3), 以f1的事务来运行, f2和f3要么都完成, 要么都不完成;
REQUIRES_NEW: f1(f2, f3), f2和f3的事务独立运行;
NOT_SUPPORTED: 以非事务方式运行, 一般用于查询操作;
8, 注解配置声明式事务
//applicationContext.xml中的配置
<!--省略: DataSource数据源、IoC:jdbcTemplate, IoC:事务管理器-->
<Context:component-scan base-package="com.imooc"/>  <!--开启组件扫描-->
<tx:annotation-driven transaction-manager="transactionManager"/>  <!--启用注解形式声明式事务-->
//Service
@Service
@Transactional
public class EmployeeService{
	@Resource
	private EmployeeDao employeeDao;
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void importJob1(){
		//....
	}
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	public void importJob2(){
		//....
	}
}
注: @Transactional注解放在类上, 表示将声明式事务应用于该类的所有方法, 默认事务传播为REQUIRED;
放在方法上, 表示仅适用于该方法; 方法注解覆盖类注解;


>>Spring MVC
1, idea中将普通maven工程配置成web工程的步骤
1)File -> Project Structure -> Facets -> + -> 在右边的配置面板将两个目录设置为: 
	E:\java\workspace\test\src\main\webapp\WEB-INF\web.xml 与
	E:\java\workspace\test\src\main\webapp;
2)Edit Configuration -> + -> Tomcat Server -> 右边的配置面板进行相关配置;
2, Spring MVC的配置步骤
1)maven中引入spring-webmvc依赖
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-webmvc</artifactId>
	<version>5.1.9.RELEASE</version>
</dependency>
2)web.xml配置DispatcherServlet
<servlet>
	<servlet-name>springmvc</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<!--在IoC容器启动时要加载的配置文件-->
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext.xml</param-value>
	</init-param>
	<load-on-startup>0</load-on-startup> 
</servlet>
<servlet-mapping>
	<servlet-name>springmvc</servlet-name>
	<url-pattern>/</url-pattern>
</servlet-mapping>
注: DispatcherServlet是Spring MVC最核心的对象, 用于拦截http请求, 并根据请求的url调用与之对应的controller方法;
配置load-on-startup是在web应用启动时自动创建Spring IoC容器, 并初始化DispatcherServlet, 如果不设置load-on-startup, 则在第一次请求url时初始化DispatcherServlet;
一般情况下DispatcherServlet只需要处理后台服务器的请求, 不需要处理静态页面, 所以, 建议使用/;
3)applictionContext配置mvc标记
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mv="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--开启组件扫描-->
    <context:component-scan base-package="com.imooc.springmvc"/>
    <!--启用Spring MVC的注解开发模式-->
    <mvc:annotation-driven/>
    <!--将图片/JS/CSS等静态资源排除在外, 可提高执行效率-->
    <mvc:default-servlet-handler/>
</beans>
4)开发Controller控制器
@Controller
public class TestController {
    @GetMapping("/t")
    @ResponseBody //直接向响应输出字符串数据, 不跳转页面
    public String test(){
        return "hello mvc";
    }
}
注: 运行时还要先点击 File -> Project Structure -> Artifacts, 将面板工程名下面的所有依赖包全部放入左边的lib目录下;
3, 工程结构
1)源代码目录结构:
src
	main
		java
			com.imooc.springmvc.controller
				TestController
		resources
			applicationContext.xml
		webapp
			WEB-INF
				web.xml
			index.html
2)运行后out的目录结构:
out
	artifacts
		test
			META-INF
				MANIFEST.MF
			WEB-INF
				classes
					com.imooc.springmvc.controller
						TestController.java
				lib
					...(各种spring.jar)
				web.xml
			index.html
注: index.html与TestController.java可当作是同一级相对路径;
4, Spring MVC的处理流程
请求 -> DispatcherServlet("/") -> TestController.test()("/t") -> DispatcherServlet -> 响应;
5, URL Mapping
1)URL Mapping是指将URL与Controller方法绑定;
2)URL Mapping注解
@RequestMapping("/r")  //通用绑定
@GetMapping("/g")  //绑定Get请求, 等价于@RequestMapping(value="/g", method=RequestMethod.GET)
@PostMapping("/p")  //绑定Post请求, 等价于@RequestMapping(value="/p", method=RequestMethod.POST)
6, 请求参数
1)接收请求参数的三种方式:
//使用Controller方法参数接收
public String test(String ename, @RequestParam("depart_name") String dname){
	return "ename: " + ename + ", dname: " + dname;
}
注: 参数名必须与请求名一致, 如果请求名包含下划线, 则参数必须使用@RequestParam注解来将参数名与请求名进行关联;
@RequestParam(value="username", defaultValue="zhao") String name 表示使用接收username的请求名, 并且如果没有username的请求, 则设置一个默认值;
//使用Java Bean接收数据
public String test(User user){
	return user.getUsername() + ": " + user.getPassword();
}
注: User实体类的字段名必须与请求名保持一致;
//使用Map接收数据
public String test(@RequestParam Map map){
	return "ename: " + map.get("ename") + ", dname: " + map.get("dname");
}
注: 使用Map接收数据需要注意两点: 一是参数前必须添加@RequestParam注解, 二是Map不能接收复合请求的参数;
2)使用List或数组来接收复合请求(checkbox表单)
public String test(@RequestParam List<String> likes){
	//...
}
注: 使用List来接收复合请求, 必须加@RequestParam注解, 而使用数组则不需要;
3)使用关联对象来接收嵌套表单的数据
//index.html
username: <input type="text" name="username"/>
password: <input type="password" name="password"/>
<div class="delivery">
	name: <input type="text" name="delivery.name"/>
	address: <input type="text" name="delivery.address"/>
	mobile: <input type="text" name="delivery.mobile"/>
</div>
//com.imooc.springmvc.entity
public class User{
	private String username;
	private String password;
	private Delivery delivery = new Delivery();
	//...
}
public class Delivery{
	//...
}
注: 前台嵌套的表单中name必须使用如delivery.address形式, 才能使用关联对象来接收值;
7, 日期类型转换
当前台输入日期字符串, 后台需要转换为日期类型, 有两种方式:
1)每次单独转换, 使用@DateTimeFormat(pattern="")注解
public String postTest(@DateTimeFormat(pattern="yyyy-MM-dd") date){
	//...
}
或
public class User{
	private String name;
	@DateTimeFormat(pattern="yyyy-MM-dd")
	private Date date;
}
2)定义转换器类, 全局转换
//定义转换器类, com.imooc.springmvc.converter.MyDateConverter
public class MyDateConverter implements Converter<String, Date>{
	public Date convert(String s){
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); //实际中一般要根据输入的日期格式进行判断
        try {
            Date date = sdf.parse(s);
            return date;
        } catch (ParseException e) {
            return null;
        }
	}
}
//在applicationContext.xml中进行配置
<mvc:annotation-driven conversion-service="conversionService"/> <!--在原有的mvc注解上面添加conversion-service属性-->
<!--配置转换服务-->
<bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
	<property name="converters">
		<set>
			<bean class="com.imooc.springmvc.converter.MyDateConverter"/>
		</set>
	</property>
</bean>
8, 请求和响应中的中文乱码
1)Get请求乱码
在server.xml中设置URIEncoding(tomcat8以后的版本不需要设置);
//tomcat: server.xml
<Connector ... URIEncoding="UTF-8"/> //只需增加URIEncoding属性
2)Post请求乱码
在web.xml中配置CharacterEncodingFilter过滤器;
//web.xml
<filter>
	<filter-name>characterEncodingFilter</filter-name>
	<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
	<init-param>
		<param-name>encoding</param-name>
		<param-value>UTF-8</param-value>
	</init-param>
</filter>
<filter-mapping>
	<filter-name>characterEncodingFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
3)响应的乱码
在applicationContext.xml中配置StringHttpMessageConverter;
//applicationContext.xml
<mvc:annotation-driven>
	<mvc:message-converters>
		<bean class="org.springframework.http.converter.StringHttpMessageConverter">
			<property name="supportedMediaTypes">
				<list>
					<value>text/html;charset=utf-8</value>
				</list>
			</property>
		</bean>
	</mvc:message-converters>
</mvc:annotation-driven>
9, 响应输出
1)@ResponseBody
直接产生响应数据, 不涉及视图, 可产生字符串、json、xml等各种数据;
2)ModelAndView
可将Model产生的数据与View进行绑定, 默认的View是jsp, 也可以配置其他模板引擎;
//Controller
@GetMapping("/show")
public ModelAndView show(int id){
	ModelAndView mv = new ModelAndView("/view.jsp");
	User user = userService.findById(id);
	mv.addObject("user", user);
	return mv;
}
//view.jsp
<div>
	用户名: ${user.username}
	年龄: ${user.age}
</div>
注: 创建ModelAndView也可以使用如下方式:
ModelAndView mv = new ModelAndView();
mv.setViewName("/view.jsp");
10, ModelAndView
1)mv.addObject()方法设置的属性默认存放在当前请求中;
2)ModelAndView默认使用请求转发(forward)来跳转页面, 
而new ModelAndView("redirect:/view.jsp")使用重定向;
11, 使用String与ModelMap替代ModelAndView(这种方式很常用)
@GetMapping("/show")
public String show(int id, ModelMap modelMap){
	String view = "/view.jsp";
	User user = userService.findById(id);
	modelMap.addAttribute("user", user);
	return view;
}
注: 当有@ResponseBody注解时, 表示返回字符串, 而当没有@ResponseBody注解时, 表示返回视图;
当不需要给视图绑定数据时, ModelMap可以省略; 
12, Spring MVC整合FreeMarker
1)pom.xml中引入相关依赖
<dependency>
	<groupId>org.freemarker</groupId>
	<artifactId>freemarker</artifactId>
	<version>2.3.28</version>
</dependency>
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context-support</artifactId>
	<version>5.1.19.RELEASE</version>
</dependency>
注: 每次新增依赖后, 在运行程序之前都要通过Edit Configurations将引入的依赖包放入/WEB-INF/lib中;
2)applicationContext.xml中启用freemarker以及配置freemarker参数
<!--启用freemarker-->
<bean id="ViewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver">
	<!--设置响应输出, 并解决中文乱码-->
	<property name="contentType" value="text/html;charset=utf-8"/>
	<!--指定freemarker模板文件扩展名-->
	<property name="suffix" value=".ftl"/>
</bean>
<!--配置freemarker参数-->
<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
	<!--设置模板保存的目录-->
	<property name="templateLoaderPath" value="/WEB-INF/ftl"/>
	<!--其他模板引擎设置-->
	<property name="freemarkerSettings">
		<props>
			<!--设置freemarker脚本与数据渲染时使用的字符集-->
			<prop key="defaultEncoding">UTF-8</prop>
		</props>
	</property>
</bean>
注: tomcat无法直接解析freemarker的模板引擎, 为了安全, 将freemarker模板文件放在/WEB-INF/ftl目录下;
设置模板存放的目录后, 根目录就不再是webapp, 而是/WEB-INF/ftl;
3)Controller
@Controller
@RequestMapping("/fm")
public class FreemarkerController {
    @GetMapping("/test")
    public ModelAndView show(String username){
        ModelAndView mv = new ModelAndView("/test");
        Form form = new Form();
        form.setUsername(username);
        mv.addObject("f", form);
        return mv;
    }
}
4)ftl
//test.ftl
<h1>freemarker: ${f.username}</h1>
13, /, /*, /**的区别
1)/与/*一般用于配置<url-pattern>, /会匹配到如/login这样的路径型url, 不会匹配到如*.jsp这样的后缀型url,
而/*会匹配包括路径型url与后缀型url的所有url;
2)/*与/*一般用于配置mvc的拦截器, /*仅匹配一级如/add, /**可匹配多级如/add/user等;


>>Restful风格
1, restful开发规范:
1)使用URL作为用户交互入口;
2)明确的语义规范(get/post/put/delete);
3)只返回数据(json/xml), 不包含任何展现;
restful命名要求: URI必须具有语义、URI必须使用名词、URI不超两级、URI名词区分单复数, 如
GET /articles?au=lily (√)
GET /a/1 (×) -> GET /student/1
POST /createArticle/1 (×) -> POST article/1
GET /articles/author/1 (×) -> GET articles/author?id=1
DELETE /articles/a (×) -> GET articles?au=lily 或 DELETE /article/1
2, controller
@RestController
@RequestMapping("/restful")
public class RestfulController {
    @GetMapping("/request")
    public String doGetRequest(){
        return "{\"message\":\"返回查询结果\"}";
    }
	@PostMapping("/request/{id}")
    public String doPostRequest(@PathVariable("id") int requestId){
        return "{\"message\":\"返回查询结果\", \"id\":" + requestId + "}";
    }
}
注: 1)需要修改applicationContext.xml中解决响应的中文乱码的某一处:
<value>application/json;charset=utf-8</value>
2)与请求get/post/put/delete对应的注解分别为@requestMapping/@postMapping/@putMapping/@deleteMapping;
不同请求的url可以相同, 比如@requestMapping("/request")与@postMapping("/request")可以同时存在;
3)@RestController注解用来替换@Controller和@ResponseBody;
4)路径变量: 包含在url请求中的变量(如/employee/5), 成为路径变量, 使用路径变量需要在方法参数中添加@PathVariable注解;
3, 简单请求与非简单请求
1)简单请求是指标准结构的http请求, 对应get/post请求;
非简单请求是复杂要求的http请求, 指put/delete请求、和扩展的标准请求;
两者的区别是非简单请求发送前需要先发送预检请求;
2)spring mvc默认不支持非简单请求的参数接收, 需要在web.xml中配置过滤器:
//web.xml
<!--FormContentFilter过滤器: 处理非简单请求-->
<filter>
	<filter-name>formContentFilter</filter-name>
	<filter-class>org.springframework.web.filter.FormContentFilter</filter-class>
</filter>
<filter-mapping>
	<filter-name>formContentFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
4, JSON序列化
1)常用的JSON序列化组件:
Jackson(国外常用的json组件),
Gson(Google开源json组件),
FastJSON(阿里巴巴开源json组件);
2)Jackson的使用
//pom.xml中引入jackson依赖
<dependency>
	<groupId>com.fasterxml.jackson.core</groupId>
	<artifactId>jackson-core</artifactId>
	<version>2.9.9</version>
</dependency>
<dependency>
	<groupId>com.fasterxml.jackson.core</groupId>
	<artifactId>jackson-databind</artifactId>
	<version>2.9.9</version>
</dependency>
<dependency>
	<groupId>com.fasterxml.jackson.core</groupId>
	<artifactId>jackson-annotations</artifactId>
	<version>2.9.9</version>
</dependency>
//controller
@GetMapping("/persons")
public List<Person> findPersons(){
	List<Person> list = new ArrayList<Person>();
	list.add(new Person("zhao", 20, new Date()));
	list.add(new Person("qian", 40, new Date()));
	list.add(new Person("sun", 30, new Date()));
	return list;
}
注: 引入了jackson依赖后, 控制器方法可以直接返回对象, jackson自动进行序列化;
注: 如果使用fastjson组件, 控制器方法需要返回JSON.toJSONString()后的字符串;
//实体类对日期类型的注解
public class Person {
    private String name;
    private int age;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
    private Date birthday;
}
注: 日期类型转换为json后默认为时间戳, 需要使用注解指定格式;


>>跨域(CORS)
1, 什么是跨域
http://www.abc.com:8080/scripts/jquery.js
协议: http, 子域名: www, 主域名: abc.com, 端口号: 8080,
请求资源路径(URI): /scripts/jquery
当协议、子域名、主域名、端口号中任意一个不相同时，都算跨域；
注: 由于浏览器同源策略的限制，js不能跨域调用;
注: 浏览器console看到Access-Control-Allow-Origin就代表跨域了;
2, HTML中允许跨域的标签
<img>, <script>, <link>;
3, SpringMVC解决跨域访问
1)CORS是一种机制, 使用额外的http头通知浏览器可以访问其他域;
URL响应头包含Access-control-*指明请求可以跨域;
Spring MVC解决跨域有两种方式:
2)方式一: @CrossOrigin - Controller跨域注解
@RestController
@CrossOrigin(origins = {"http://localhost:8080", "http://www.imooc.com"})
public class TestController{
	//...
}
注: 也可以设置所有域名都可以访问，@CrossOrigin(origins="*"), 但不推荐;
3)方式二: <mvc:cors> - Spring MVC全局跨域配置
<mvc:cors>
	<mvc:mapping path="/test/**" allowed-origins="http://domain1.com, http://domain2.com" allowed-method="get, post" max-age="3600"/>
	<mvc:mapping path="/**"/> <!--"/**"表示所有的方法-->
</mvc:cors>
注: max-age代表预检请求的缓存时间;


>>拦截器Interceptor
1, 基本概念
拦截器用于对URL请求进行前置/后置过滤, 与Filter用途相似;
Interceptor是SPring MVC的标准组件, 而Filter是J2EE的标准组件;
Interceptor底层是基于Spring AOP面向切面编程;
2, 开发流程
1)maven依赖servlet-api
<dependency>
	<groupId>javax.servlet</groupId>
	<artifactId>javax.servlet-api</artifactId>
	<version>3.1.0</version>
	<!--scope表示仅在开发时使用该jar包, 打包时丢弃, 防止与tomcat自带的servlet冲突-->
	<scope>provided</scope> 
</dependency>
2)实现HandlerInterceptor接口
public class MyInterceptor implements HandlerInterceptor {
    //请求到达controller之前, 返回值为true表示请求继续传递, false表示立即返回
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(request.getRequestURL() + "-准备执行");
        return true;
    }
    //controller处理完请求, 但还未生成响应文本
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(request.getRequestURL() + "-目标执行成功");
    }
    //响应文本产生以后
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(request.getRequestURL() + "-响应内容已产生");
    }
}
3)applicationContext配置过滤地址
<mvc:interceptors>
	<mvc:interceptor>
		<mvc:mapping path="/**"/>  <!--"/**"表示对所有请求进行拦截-->
		<mvc:exclude-mapping path="/resources/**"/>  <!--表示将/resources目录下的资源排除在过滤地址以外-->
		<bean class="com.imooc.restful.interceptor.MyInterceptor"/>
	</mvc:interceptor>
</mvc:interceptors>
注: 一般将js、css、image等静态资源放在 webapp/resources目录下;
注: 可以开发多个拦截器, 按配置的顺序依次对请求进行拦截;


>>Spring Boot
1, idea创建springboot工程
Project -> Spring Initializr -> 进入配置页面进行工程的设置;
2, 工程结构
test
	src	
		main
			java
				com.imooc.springboot
					SpringBootTestApplication  //主启动类
					controller
						MyController
					dao
					service
			resources
				static
				templates
				application.properties  //配置文件
	test
	pom.xml
1)pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.1.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.imooc</groupId>
    <artifactId>spring-boot-test</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>spring-boot-test</name>
    <description>Demo project for Spring Boot</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
2)SpringBootTestApplication.java
@SpringBootApplication
public class SpringBootTestApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringBootTestApplication.class, args);
    }
}
3, 配置文件的写法
配置文件的两种形式: 
1).properties
my.url=http://imooc.com
my.name=imooc
2).yml
my:
url: http://imooc.com  //中间要有一个空格
name: imooc
3)自定义配置
//application.properties
school.grade=3
school.classnum=5
//TestController.java
@RestController
public class TestController{
	@Value("${school.grade}")
	private int g;
	@Value("${school.classnum}")
	private int c;
	@GetMapping("/info"){
		return "年级: " + g + ", 班级: " + c;
	}
}


>>多线程
1, 进程(process)与线程(thread)
进程是操作系统分配资源的最小单位，线程是程度执行与调度的最小单位，
一个进程一般包含多个线程;
2, Thread类
1)构造方法
Thread();
Thread(String name);
Thread(Runnable target);
Thread(Runnable target, String name);
2)常用方法
run(); //线程执行体, 需要被重写
start(); //启动线程
sleep(long m); //让自己休眠, Thread.sleep(), 使当前线程休眠m毫秒，属于静态方法，并且需要进行异常处理
join()/join(m); //别的线程抢先执行, 调用join()的线程抢占执行, 需要进行异常处理
wait()/wait(m); //让自己等待，需要处理异常
notify(); //唤醒某个正在等待的线程
notifyAll(); //常用, 唤醒所有正在等待的线程
注: 在A线程中调用B.join()方法，只能保证B插队在A之前，而B会和其他线程并发执行;
A: B.join(m)的意思是，A等待B执行m毫秒后再执行;
3, 创建线程的三种方式
1)继承Thread类
class MyThread extends Thread{
	@Override
	public void run(){ //... }
}
MyThread t = new MyThread("java");
t.start();
2)实现Runnable接口
class MyThread implements Runnable{
	private int i = 10;
	@Override
	public void run(){
		while(i > 0){
			System.out.println(Thread.currentThread().getName() + "-" + i);
			i--;
		}
	}
}
MyThread m = new MyThread();
Thread t1 = new Thread(m, "java");
Thread t2 = new Thread(m, "c++");
t1.start();
t2.start();
注: 此时两个线程共享变量i;
Thread.currentThread()返回当前线程;
3)实现Callable接口
此方式的优点是具有返回值，且可以声明并抛出异常;
4, 线程的状态和生命周期
1)五种状态
新建(NEW)、可运行/就绪(RUNNABLE)、正在运行(RUNNING)、阻塞(BLOCKED)、终止(TERMINATED);
2)生命周期
线程的生命周期，就是线程在这五种状态之间的转换过程;
新建: new Thread();
可运行: start();
可运行->正在运行: 获得CPU使用权;
正在运行->可运行: CPU时间片用完/yield();
正在运行->阻塞: join()/wait()/sleep()/IO请求;
阻塞->可运行: 等待调用join()的线程执行完毕/notify()或notifyAll()/sleep时间超时/IO请求完成;
正在运行->终止: 线程执行完毕/异常终止/stop();
5, 线程的优先级
1)优先级分为10个级别, 由低到高用数字1-10表示, 默认为5;
2)常用方法
t.getPriority(); //获取优先级
t.setPriority(n); //设置优先级
注: 优先级高并不能保证一定会优先执行，因为会受到操作系统调度的影响;
6, 线程同步
1)synchronized可以保证共享对象在同一时刻只能被一个线程访问;
2)synchronized关键字可以用在如下地方:
//方法
public synchronized void saveAccount(){}
//语句块
synchronized(obj){}
3)案例: 银行账户存取款线程同步问题
class Bank{ //银行账户类
	private String account;
	private int balance;
	//构造方法、getter/setter、toString方法省略
	public synchronized void save(){ //存钱方法, 用第一种方式同步
		int balance = getBalance();
		balance += 100;
		Thread.sleep(1000); //休眠，省略异常处理
		setBalance(balance);
		System.out.println("存钱后账户余额为: " + balance);
	}
	public void withdraw(){ //取钱方法, 用第二种方式同步
		synchronized(this){
			int balance = getBalance();
			balance -= 200;
			Thread.sleep(1000); //休眠，省略异常处理
			setBalance(balance);
			System.out.println("取钱后账户余额为: " + balance);
		}
	}
}
class SaveAccount implements Runnable{ //存款线程
	Bank bank;
	public SaveAccount(Bank bank){ this.bank = bank; }
	@Override
	public void run(){
		bank.save();
	}
}
class WithdrawAccount implements Runnable{	//取款线程
	Bank bank;
	public WithdrawAccount(Bank bank){ this.bank = bank; }
	@Override
	public void run(){
		bank.withdraw();
	}
}
public class Test{
	public static void main(String[] args){
		Bank bank = new Bank("1001", 1000);
		Thread t1 = new Thread(new SaveAccount(bank));
		Thread t2 = new Thread(new WithdrawAccount(bank));
		t1.start();
		t2.start();
		try{
			t1.join();
			t2.join();
		}catch(InterruptedException e){
			e.printStackTrace();
		}
		System.out.println("账户余额为: " + bank.getBalance());
	}
}
7, 线程间通信
1)通过wait()和notifyAll()/notify()来实现进程间通信;
2)案例: 生产者消费者线程通信
class Box{ //商品容器类, 容器里只放一件商品
	private int n; //商品的序号
	private boolean flag = false; //false表示无商品，true表示有商品
	public synchronized int get(){ //消费
		if(!flag){ //容器空则等待
			try{
				wait();
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
		System.out.println("消费: " + n);
		this.flag = false;
		notifyAll(); //唤醒等待的其他进程(如生产者进程)
		return n;
	}
	public synchronized void set(int n){ //生产
		if(flag){ //容器满则等待
			try{
				wait();
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
		System.out.println("生产: " + n);
		this.n = n;
		this.flag = true;
		notifyAll(); //唤醒等待的其他进程(如消费者进程)
	}
}
class Producer implements Runnable{ //生产者进程
	Box box;
	public Producer(Box box){ this.box = box; }
	@Override
	public void run(){
		int i = 1;
		while(true){
			box.set(i++);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
class Consumer implements Runnable{ //消费者进程
	Box box;
	public Consumer(Box box) {
		this.box = box;
	}
	@Override
	public void run() {
		while(true) {
			box.get();
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
public class Test{
	public static void main(String[] args){
		Box box = new Box();
		Thread t1 = new Thread(new Producer(box));
		Thread t2 = new Thread(new Consumer(box));
		t1.start();
		t2.start();
	}
}


>>线程池
1, 线程池的好处
加快响应速度、合理利用CPU和内存、统一管理;
2, 线程池的应用场合
1)批量计算任务、服务器处理请求、excel解析等;
2)实际应用中, 需要5个以上的线程就可以使用线程池来管理;
3, 普通线程与守护线程
两者的区别主要在于是否需要JVM的运行, 只要普通线程在则JVM的运行不会结束, 而守护线程可以在JVM停止运行时存在, 如垃圾处理器GC;
4, 创建线程池
1)构造方法的参数
int corePoolSize: 核心线程数;
int maxPoolSize: 最大线程数;
BlockingQueue workQueue: 任务存储队列;
	3种常见的队列类型: 
	直接交接(无缓冲): SynchronousQueue;
	无界队列: LinkedBlockingQueue;
	有界队列: ArrayBlockingQueue;
long keepAliveTime: 保持存活时间;
	当线程总数 > corePoolSize时, 多余的线程空闲时间超过keepAliveTime就会被终止;
ThreadFactory threadFactory: 当线程池需要新的线程时, 使用threadFactory来生成新的线程;
	自己指定threadFactory可以改变线程名和优先级等, 如果不指定, 则默认使用Executors.线程池()来创建线程;
RejectedExecutionHandler Hander: 线程池无法接受新任务时的拒绝策略;
	AbortPolicy(常用): 抛出异常;
	DiscardPolicy: 直接丢弃;
	DiscardOldestPolicy: 移除最老的线程;
	CallerRunsPolicy: 由提交者自己执行;
2)添加线程的规则
当线程总数 < corePoolSize时, 每来一个新任务就创建线程, 直到线程数等于corePoolSize;
当线程总数 = corePoolSize时, 再来新任务就放到任务队列workQueue;
当workQueue也满了, 如果此时线程总数 < maxPoolSize, 就会创建新线程来执行任务;
当线程数 = maxPoolSize时, 再来新任务就拒绝;
5, jdk提供的几种线程池
1)FixedThreadPool
corePoolSize: n, maxPoolSize: n, workQueue: LinkedBlockingQueue;
特点: 队列满后, 无法再增加线程;
2)SingleThreadExecutor
corePoolSize: 1, maxPoolSize: 1, workQueue: LinkedBlockingQueue;
3)CachedThreadPool
corePoolSize: 0, maxPoolSize: Integer.MAX_VALUE, workQueue: SynchronousQueue;
特点: 无需核心线程, 有新任务到来就创建线程, 且可以创建无数个;
4)ScheduledThreadPool
支持定时及周期性任务执行的线程池;
举例:
public class Demo{
	public static void main(String[] args){
		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
		ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
		ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);
		fixedThreadPool.execute(new Task());
		//等价于 fixedThreadPool.submit(new Task());  
	}
	static class Task implements Runnable{
		@Override
		public void run(){
			System.out.println(Thread.currentThread().getName());
		}
	}
}
6, 自动创建与手动创建
自动创建线程池, 即调用jdk提供的几种线程池, 有可能会产生内存溢出的问题;
一般使用手动创建线程池, 即根据不同的业务场景来设置线程池的参数;
线程数 = CPU核数*(1+平均等待时间/平均工作时间), 如:
CPU密集型(计算): 线程数为CPU核数的1-2倍左右;
耗时IO型(数据库、文件、网络读写等): 线程数为CPU核数的很多倍;
7, 停止线程池
1)shutdown()
fixedThreadPool.shutdown();
对线程池进行停止的初始化工作, 调用该方法并不立即停止线程池, 要等当前线程及任务队列中的线程执行完毕再停止, 如果再来新任务则拒绝;
2)isShutdown()
判断是否调用了shutdown()方法, 不代表此时线程池已经停止了;
3)isTerminated()
判断此时线程池是否已经停止;
4)awaitTermination()
boolean b = fixedThreadPool.awaitTermination(3, TimeUnit.SECONDS);
在等待3秒之后, 判断线程池是否已停止;
5)shutdownNow()
List<Runnable> runnableList = fixedThreadPool.shutdownNow();
立即停止线程池, 中断正在执行的线程, 并返回任务队列中的线程列表;
7, 自定义线程池
public class MyThreadPool extends ThreadPoolExcutor{
	private ReentrantLock lock = new ReentrantLock();  //加锁
	private boolean flag = false;
	//自动生成四个构造函数, 省略
	private void fn(){
		lock.lock();
		try{
			flag = true;
		}finally{
			lock.unlock();
		}
	}
}
8, 线程池家族的继承关系
Executor <- ExecutorService <- AbstractExecutorService <- ThreadPoolExcutor;
自定义线程池, 就是继承自ThreadPoolExecutor;
另外还有一个线程池工具类Executors, 用来自动创建线程池;
注: 线程池实现复用的核心是相同的线程执行不同的任务;
9, 线程池的状态
1)RUNNING
接受新任务并处理队列任务;
2)SHUTDOWN
调用shutdown()后的状态, 不接受新任务, 但处理队列任务;
3)STOP
调用shutdownNow()后的状态, 不接受新任务, 也不处理队列任务, 并中断正在进行的任务;
4)TIDYING
所有任务都清理完成时的整洁状态;
5)TERMINATED
线程池已终止;


>>ThreadLocal
1, SimpleDateFormat的进化之路
1)2个线程分别用自己的SimpleDateFormat, 这没问题;
2)后来延伸出10个, 那就有了10个线程和10个SimpleDateFormat, 这虽然写法不优雅(应该复用对象), 但勉强可以接受;
3)但是当需求变成了1000个, 那么必然要用线程池(否则消耗内存太多);
4)所有线程都共用一个SimpleDateFormat对象;
5)这是线程不安全的, 出现了并发安全问题;
6)我们可以选择加锁, 加锁后结果正常, 但是效率低;
7)更好的解决方案是使用ThreadLocal;
2, ThreadLocal的两个使用场景
1)每个线程需要一个独立的对象(通常是工具类如SimpleDateFormat和Random);
2)每个线程内需要保存全局变量(如在拦截器中获取用户信息), 可以让不同方法直接使用, 避免了参数传递的麻烦;
3, 使用加锁来解决共享资源的线程安全问题
public class Demo{
	private static ExecutorService threadPool = Executors.newFixedThreadPool(5); //创建线程池
	private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //共享资源
	public static void main(String[] args){
		for(int i = 0; i < 100; i++){
			int finalI = i;
			threadPool.submit({  //将任务添加到线程池
				@Override
				public void run(){
					System.out.println(n + ">>" + new Demo().date(100*finalI));
				}
			});
		}
		threadPool.shutdown(); //停止线程池
	}
	public String date(int seconds){
		Thread.sleep(500);
		Date date = new Date(1000*seconds);
		String rs = ""; 
		synchronized(Demo.class){  //对资源加锁: 类锁
			rs = sdf.format(date);
		}
		return rs;
	}
}
注: 加锁后一次只能执行一个任务, 失去了并行的高效;
4, 使用场景一
使用ThreadLocal, 给每个线程分配自己的对象, 既保证了线程安全, 又能高效利用内存;
public class Demo {
    private static ExecutorService threadPool = Executors.newFixedThreadPool(5);
    public static void main(String[] args) {
        for (int i = 1; i <= 20; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.println(finalI + ">>" + new Demo().date(100*finalI));
                }
            });
        }
        threadPool.shutdown();
    }
    public String date(int seconds) {
        Thread.sleep(500);
        Date date = new Date(1000*seconds);
        SimpleDateFormat sdf = ThreadSafeFormatter.dateFormatThreadLocal.get();
        return sdf.format(date);
    }
}
class ThreadSafeFormatter {
    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>(){
		@Override
		protected SimpleDateFormat initialValue() {
			return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		}
	};
}
5, 当使用多个线程来处理多个用户请求时, 对于用户信息的保存以及用户信息在不同方法间的传递, 有如下方法:
1)定义类变量UserMap来保存多个用户信息, 并结合synchronized来对UserMap加锁从而防止并发安全问题, 但这会影响效率;
2)使用ConcurrentHashMap(线程安全的HashMap), 不需要加锁, 但存在效率问题;
3)使用ThreadLocal, 保证了每个线程保存自己的用户信息, 并且避免了参数传递;
6, 使用场景二
public class Demo2 {
    public static void main(String[] args) {
        new Service1().process("张三");
    }
}
class Service1{
    public void process(String name){
        User user = new User(name);
        UserContextHolder.threadLocal.set(user);
        new Service2().process();
    }
}
class Service2{
    public void process(){
        User user = UserContextHolder.threadLocal.get();
        System.out.println(user);
    }
}
class UserContextHolder {
    public static ThreadLocal<User> threadLocal = new ThreadLocal<>();
}
注: 场景一的initialValue(), 是在定义时就把对象初始化出来;
场景二的set(), 对象的生成时机不确定, 例如拦截器生成的用户信息;
7, 使用ThreadLocal的优点
1)线程安全
2)不需要加锁, 提高执行效率
3)更高效地利用内存
4)避免了参数传递
8, Thread, ThreadLocal, 与ThreadLocalMap之间的关系
每个Thread都有一个ThreadLocalMap的实例变量, 而ThreadLocalMap的每个key就是ThreadLocal, value就是设置的值;
所以一个线程可以设置多个ThreadLocal;
9, ThreadLocalMap和HashMap
如果两个不同的元素, 通过哈希函数得出的实际存储地址相同, 就成为哈希冲突(也叫哈希碰撞);
HashMap解决哈希冲突的方式是在冲突的地址上使用链表, 当某个位置冲突到一定的量, 就使用红黑树;
ThreadLocalMap解决哈希冲突的方式是线性探测法, 也就是寻找下一个空位置, 而不是引入链表;
10, ThreadLocal的常用方法
1)T initialValue()
返回当前线程对应的初始值, 如果先前没有通过set()设置值则在第一次调用get()时默认调用此方法;
2)void set(T t)
为当前线程设置新值;
3)T get()
得到当前线程对应的值;
4)void remove()
删除当前线程对应的值;
11, 使用ThreadLocal以后要调用remove()方法, 否则容易引起内存泄漏;
实际项目中应优先使用框架提供的工具, 尽量避免使用ThreadLocal;


>>分布式
1, 分布式的定义
利用物理架构形成多个自治的处理元素, 不共享主内存, 但是通过发送信息合作;
2, CAP定理
C: 一致性; A: 可用性; P: 分区容错性;
实际中只能满足其中两个, 如CDN选择AP, 转账使用CP;
3, 集群、分布式、微服务
集群: 同一个项目部署在多个服务器上, 仅仅为了分散压力;
微服务: 是从架构设计的角度, 对业务进行拆分, 如一个项目拆分为用户模块、订单模块等;
分布式: 是从系统部署的方式, 将一个项目的多个子系统分别部署在不同的服务器;
实际中经常是微服务设计, 然后分布式部署;





































