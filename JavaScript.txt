>>javascript六种数据类型：
原始类型: boolean, number, string, undefined, null;
对象: object;

>>isNaN()
判断一个变量是否是数字类型;

>>javascript没有块级作用域；
for(var i = 0; i < 10; i++){
	//...
}
console.log(i); //10

>>连续赋值的陷阱
function foo(){
	var a = b = 1;
}
foo();
console.log(typeof a); //'undefined'
console.log(typeof b); //'number'
这里的b隐式的创建为一个全局变量，应该改为:
var a = 1, b = 1;

>>try...catch
//抛出基本类型如字符串
try{
	throw 'test';
}catch(ex){
	console.log(ex);
}finally{
	console.log('finally');
}
//抛出对象
try{
	throw new Error('test');
}catch(ex){
	console.log(ex.message);
}finally{
	console.log('finally');
}
注：finally语句可有可无, 无论是否抛出异常，finally都会被执行;

//for...in
var obj = {x: 1, y: 2};
for(var p in obj){
	//...
}
注：使用for...in时要注意，
1, 属性顺序不确定;
2, 属性标签enumerable为false时不会出现;
3, 属性受原型链的影响;

>>with
with可以关联一个对象到当前作用域。
with(document.forms[0]){
	console.log(name.value);
}
注: with语句有以下缺点：
1，可读性差；
2，让JS引擎优化更难；
3，严格模式下被禁用；
4，可被变量定义代替；
使用变量定义来代替，如下：
var form = document.form[0];
console.log(form.name.value);

>>对象的创建
1, 对象字面量
var obj = {x: 1, y: 2};
2, 构造函数
function foo(){this.x = 1; this.y = 2;}
foo.prototype.z = 3;
var obj = new foo();
3, Object.create(o);
该方法创建了一个以o为原型的空对象;

>>读对象的属性前要判断对象是否存在
var yz, obj = {};
if(obj.y){
	yz = obj.y.z;
}
上面的程序段可以简写如下：
var yz = obj && obj.y && obj.y.z;

>>对象属性的标签
1, 四个静态标签和两个读写的方法:
configurable, writable, enumerable, value;
get, set;
2, Object.defineProperty()
//给对象添加一个属性，并给该属性指定相关标签
var person = {};
Object.defineProperty(person, 'name', {
	enumerable: true,
	value: 'zhao'
});
注：用Object.defineProperty()方法添加属性，默认情况下该属性的标签都为false；
而用对象字面量的方式添加属性，属性的标签默认为true；
3, Object.defineProperties()
//给对象添加多个属性，并指定标签
var person = {};
Object.defineProperties(person, {
	title: {value: 'fe', enumerable: true},
	corp: {value: 'baba', enumerable: true},
	salary: {value: 10000, enumerable: true, writable: true}
});
4, Object.getOwnPropertyDescriptor()
//取对象的某个属性的所有标签，返回结果为一个对象
Object.getOwnPropertyDescriptor(person, 'salary');
//Object{value: 10000, writable: true, enumerable: true, configurable: false}
5, Object.getOwnPropertyDescriptors()
//取对象的所有属性的所有标签，返回结果为一个对象
Object.getOwnPropertyDescriptors(person);
//Object{title: {...}, corp: {...}, salary: {...}}
6, get/set方法
1)通过对象字面量来定义get/set方法
var man = {
	name: 'Bosn',
	_age: null,
	get age(){
		if(this._age == undefined){
			return new Date().getFullYear() - 1988;
		}else{
			return this._age;
		}	
	},
	set age(val){
		if(!isNaN(val) && val > 0 && val < 150){
			this._age = val;
		}else{
			throw new Error('Incorrect val = ' + val);
		}
	}
};
man.age; //32
man.age = 100;
man.age; //100
man.age = 'abc'; //error:Incorrect val = abc
2)通过Object.defineProperties()方法来定义get/set方法
var person = {};
Object.defineProperties(person, {
	title: {value: 'fe', enumerable: true},
	corp: {value: 'baba', enumerable: true},
	salary: {value: 10000, enumerable: true, writable: true},
	luck: {
		get: function(){
			return Math.random() > 0.5 ? 'good' : 'bad';
		}
	},
	promote: {
		set: function(level){
			this.salary *= 1 + level*0.1;
		}
	}
});
person.salary; //10000
person.promote = 2;
person.salary; //12000

>>对象的序列化
1, JSON.stringify(obj)
将对象序列化为字符串
2, JSON.parse(str)
将json字符串解析为对象
2, 可以通过toJSON来定制序列化的过程
var obj = {
	x: 1,
	y: 2,
	o: {
		o1: 1,
		o2: 2,
		toJSON: function(){
			return this.o1 + this.o2;
		}
	}
};
JSON.stringify(obj); //'{"x":1,"y":2,"o":3}'

>>对象转换为基本类型的过程
首先查找对象的valueOf()方法，如果valueOf()方法不存在或者返回对象，
则继续查找toString()方法，如果toString()方法也不存在或者返回对象，
则报错；

>>String对象
1, 常用方法
1)charAt()
指定位置的字符
2)indexOf()/lastIndexOf()
指定的字符第一次出现的位置
var s = 'hello,world';
s.indexOf('o'); //4
s.indexOf('o', 5); //7
s.lastIndexOf('o'); //7
3)substring()
提取指定起止的子字符串
4)substr()
提取指定数目的子字符串
var s = 'hello,world';
s.substring(2, 6); //'llo,'
s.substr(2, 6); //'llo,wo'
5)search()
查找指定子串的位置，不存在则返回-1
'aaa123bbb'.search('123'); //3
'aaa123bbb'.search(/\w\d/); //2
6)replace()
对指定的子串进行替换
'a1b1c1'.replace('1', 'X'); //'aXb1c1'
'a1b1c1'.replace(/1/g, 'X'); //'aXbXcX'
7)split()
字符串分割
var s = 'hello,world';
s.split(','); //['hello', 'world']
s.split(''); //['h', 'e', 'l', 'l', 'o', ',', 'w', 'o', 'r', 'l', 'd']
s.split('', 5); //['h', 'e', 'l', 'l', 'o']
'a1b2c3d4'.split(/\d/); //['a', 'b', 'c', 'd', '']
8)match()
正则匹配
var r = 'a1b2c3d4'.match(/(\w)\d/);
r; //['a1', 'a', index: 0]
var r = 'a1b2c3d4'.match(/(\w)\d/g);
r; //['a1', 'b2', 'c3', 'd4']

>>Math对象
1, 常用方法
1)Math.floor(), Math.ceil(), Math.round();
2)Math.random();
返回介于[0, 1)之间的小数;
注；四舍五入到指定小数点位数用 toFixed();
var a = 3.146;
a.toFixed(2); //3.15

>>Date对象
1, 创建Date对象
new Date(); //当前时间
new Date('October 13, 1975 11:13:00');
new Date(75, 10, 13, 11, 13, 0);
2, 获取与设置
d.getFullYear()/d.setFullYear();
d.getMonth()/d.setMonth(); //月份从0开始计算
d.getDate()/d.setDate();
d.getHours()/d.setHours();
d.getMinutes()/d.setMinutes();
d.getSeconds()/d.setSeconds();
d.getDay(); //星期只有获取，没有设置函数
举例：
d.setDate(d.getDate()+2);
3, 时间戳(单位是毫秒)
d.getTime();
d.setTime();
举例: 
d.setTime(d.getTime()+24*60*60*1000); //将时间设置为一天后

>>数组的创建
1, 数组字面量
var arr = [1, 2, 4];
2, 构造函数
var arr = new Array(1, 2, 4);

>>常用的数组方法
1, Array.isArray()
判断一个对象是否为数组；
注意该方法属于Array构造器的方法，其他方法为Array.prototype的方法；
2，arr.indexOf()，arr.lastIndexOf()
查找元素在数组中的下标，如果不存在则返回-1;
也可以指定查找的起始位置；
3, arr.push()
将元素添加到数组尾部，返回数组的长度
4, arr.pop()
删除数组的最后一个元素，并返回该元素
5，arr.unshift()
将元素添加到数组头部，返回数组的长度
6，arr.shift()
删除数组的第一个元素，并返回该元素
7，arr.join()
将数组元素以指定分隔符连接成字符串，如果不指定分隔符，默认以逗号分隔；
8，arr.reverse()
数组逆序，注意该方法为本地方法，会修改原数组
9，arr.sort()
默认按字符串的顺序来排序，如果需要按数字的顺序或者要排序对象，需要自定义函数来排序；
该方法也是本地方法，会修改原数组；
10，arr.concat()
数组连接, 该方法不会改变原数组
var arr = [1, 2, 3];
arr.concat([10, 11], 13); //[1, 2, 3, 10, 11, 13]
11, arr.slice(start, end)
返回数组片段
12，arr.splice()
数组拼接，返回被删除的元素组成的数组，该方法为本地方法，会修改原数组
var arr = [1, 2, 3, 4];
var b= arr.splice(1, 2, 'a', 'b'); //[1, 'a', 'b', 4]
b; //[2, 3]
13, arr.forEach()
遍历数组
var arr = [1, 2, 3];
arr.forEach(function(x, index, a){
	console.log(x + '|' + index + '|' + (a === arr));
});
//1|0|true
//2|1|true
//3|2|true
14, arr.map()
数组映射，该方法不修改原数组
var arr = [1, 2, 3];
var b= arr.map(function(x){
	return x + 10;
});
b; //[11, 12, 13]
arr; //[1, 2, 3]
15, arr.filter()
数组过滤，该方法不修改原数组
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var b = arr.filter(function(x, index){
	return x % 3 === 0;
});
b; //[3, 6, 9]
arr; //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
16, arr.every()
判断数组中的所有元素满足某个条件
17，arr.some()
判断数组中是否存在元素满足某个条件

>>函数的创建
1，函数声明
function foo(){}
2, 函数表达式
var foo = function(){}
注：函数声明可以提前调用，而函数表达式不可以；

>>函数的调用方式
1，直接调用
foo();
2, 对象方法
o.method();
3, 构造器
new Foo();
4, call/apply/bind
func.call(o);

>>this
一般情况下，this绑定到调用该函数的对象上；

>>js函数作为一般函数调用和作为构造函数的区别
作为一般函数调用时，如果有return返回值则取返回值，没有则是undefined；
作为构造函数时，如果return一个对象，则返回该对象，如果没有return或者return一个基本类型，则按默认返回this处理;
function f1(){
	this.a = 1;
	return 5;
}
f1(); //5
new f1(); //{a: 1}
function f2(){
	this.a = 1;
	return {b: 2};
}
f2(); //{b: 2}
new f2(); //{b: 2}

>>call/apply
call()和apply()可以将函数中的this绑定到指定的对象
function add(c, d){
	return this.a + this.b + c + d;
}
var o = {a: 10, b: 20};
add.call(o, 1, 2); //33
add.apply(o, [1, 2]); //33
注：call()与apply()的作用一样，区别是call()以扁平化的方式传参，而apply()是以数组的方式传参；

>>bind()
1, 将函数中的this绑定到指定的对象, bind()返回的仍然是一个函数
function f(){return this.a;}
var o = {a: 1};
var g = f.bind(o);
g(); //1
2, currying
科里化，将一个函数拆分成不同的单元；
function add(a, b, c){
	return a + b + c;
}
var f1 = add.bind(null, 100);
f1(1, 2); //103
var f2 = f1.bind(null, 1000);
f2(1); //1101

>>闭包
内部函数包含了外部变量的引用，就是闭包。
function outer(){
	var localVar = 30;
	return function(){
		return localVar;
	}
}
var func = outer();
func(); //30
1, 闭包的常见例子：
1)事件点击
(function(){
	var localData = 'localData here';
	document.addEventListener('click', function(){
		console.log(localData);
	});
})();
2)异步请求的回调
(function(){
	var localData = 'localData here';
	$.ajax({
		url: 'test.php',
		success: function(){
			console.log(localData);
		}
	});
})();
2, 闭包的陷阱
以下程序段是应用闭包常见的陷阱：
document.body.innerHTML = '<div id="div1">aaa</div>' + 
	'<div id="div2">bbb</div><div id="div3">ccc</div>';
for(var i = 1; i < 4; i++){
	document.getElementById('div'+i).addEventListener('click', function(){
		alert(i); //all are 4!
	});
}
可改写为:
for(var i = 1; i < 4; i++){
	(function(k){
		document.getElementById('div'+k).addEventListener('click', function(){
			alert(k);
		});
	})(i);
}
3, 闭包的优点
1)永久保存外层函数的变量；
2)实现封装，避免全局对象的污染：
var person = {};
(function(){
	var name = 'zhao';
	var age = 30;
	person.getName = function(){
		return name;
	};
	person.getAge = function(){
		return age;
	};
})();
或者
var person = function(){
	var name = 'zhao';
	var age = 30;
	return {
		getName: function(){
			return name;
		},
		getAge: function(){
			return age;
		}
	};
}();
或者
var person = new function(){
	var name = 'zhao';
	var age = 30;
	this.getName = function(){
		return name;
	};
	this.getAge = function(){
		return age;
	}
};
4, 闭包的缺点
1)空间浪费
2)内存泄漏
3)性能消耗

>>原型
function Foo(){
	this.x = 1;
}
Foo.prototype.y = 2;
new Foo()的初始结构: 
{
	__proto__: Foo.prototype,
	x: 1
}
Foo.prototype的初始结构:
{
	constructor: Foo,
	__proto__: Object.prototype,
	y: 2
}

>>基于原型的继承
function Person(name, age){ 
	this.name = name;
	this.age = age;
}
Person.prototype.say = function(){
	console.log('My name is ' + this.name + ', I am ' + this.age + 
		' years old.');
};
Person.prototype.walk = function(){
	console.log(this.name + ' is walking.');
};
function Student(name, age, major){
	Person.call(this, name, age);
	this.major = major;
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
Student.prototype.say = function(){
	console.log('My name is ' + this.name + ', I am ' + this.age + 
		' years old, I am majoring ' + this.major);
};
Student.prototype.learn = function(){
	console.log(this.name + ' is learning.');
};
这是最经典的组合式原型继承,
通过Person.call(this, name, age)继承基类的构造函数,
通过Student.prototype = Object.create(Person.prototype)继承基类的原型;
Student的原型链如下：
Student.prototype -> Person.prototype -> Object.prototype -> null;

>>BOM
1, window对象
BOM的核心，window对象指当前的浏览器窗口;
常用方法:
1)open()/close()
var win = window.open([url], [窗口名称], [参数字符串]);
url: http://www.baidu.com 或 test.php;
窗口名称: _blank(在新窗口打开, 默认), _self(当前窗口), _top(顶部窗口);
参数字符串: 'width=600,height=300,top=100,left=100,menubar=yes,toolbar=no,scrollbars=yes,status=yes';
window.close(); //关闭本窗口
win.close(); //关闭指定窗口
2)alert()/confirm()/prompt()
警示框、确认框、输入框;
3)print()
打印当前窗口内容
4)focus()/blur()
将焦点移入指定窗口或从指定窗口移开
5)moveBy()/moveTo(), resizeBy()/resizeTo(), scrollBy()/scrollTo()
移动窗口、调整窗口尺寸、滚动窗口内容;
6)setTimeout()/clearTimeout(), setInterval()/clearInterval()
计时器
var i = setInterval(function(){
	//...
}, 1000); //时间间隔的单位为毫秒
clearInterval(i);
2, history对象
记录用户浏览过的页面的历史记录，从窗口打开的那一刻开始记录;
history.length; //浏览器历史列表中的url数量
常用方法:
1)back()
前进到前一个页面，相当于go(-1);
2)forward()
后退到后一个页面，相当于go(1);
3)go(n)
跳转到某个具体的页面;
3, location对象
用于解析窗体的url;
举例: http://www.imooc.com:8080/list.php?courseid=8&chapterid=86#mediaid118
常用属性:
1)href //返回完整的url
2)protocol //协议 http
3)hostname //主机名 www.immoc.com
4)port //端口号 8080
5)host //主机名+端口号 www.imooc.com:8080
6)pathname //路径 list.php
7)search //查询字符串 ?courseid=8&chapterid=96
8)hash //锚 #mediaid118
常用方法:
1)assign()
加载新的文档
2)reload()
重新加载当前文档
3)replace()
用新的文档替换当前文档
4, navigator对象
包含浏览器的相关信息;
常用属性:
1)userAgent //用户代理，客户端发送给服务器的user-agent头部的值
2)appName //浏览器的名称
3)appVersion //浏览器的版本信息
4)appCodeName //浏览器代码名的字符串表示
5)platform //浏览器运行的操作系统信息
5, screen对象
用户的屏幕信息;
常用属性:
1)width/height //屏幕的宽度与高度
2)availWidth/availHeight //屏幕的可用宽度与可用高度
3)colorDepth //颜色位数

>>各种对象的尺寸
1, offsetParent
布局中设置了position属性(relative、absolute、fixed)的父容器，从最近的父节点开始查找，
一直到document.body;
2, 盒子的宽度与高度
box.offsetWidth;
box.offsetHeight;
3, 盒子的左边距和上边距
box.offsetLeft;
box.offsetTop;
4, 盒子滚动条的偏移距离
box.scrollLeft;
box.scrollTop;
5, 窗口显示区域的宽度与高度，不包括滚动条
window.innerWidth;
window.innerHeight;


>>ES6的新特性
1, let和const命令
2, 模板字符串
3, 箭头函数
4, 解构赋值
5, 字符串、数组、对象新增的方法
6, Symbol
7, Map和Set类型
8, 迭代器和生成器
9, Promise对象
10, Proxy对象
11, async的用法
12, 类 class
13, 模块化实现


>>let和const
1, let与var的区别:
1)let有块级作用域
2)let不允许重复声明
3)let不存在变量提升;
4)var声明的全局变量都会绑定到window上, 而let不会;
var a = 1; window.a  //1
let b = 2; window.b  //error
5)避免闭包中var存在的问题;
const a = [], b = [];
for(var i = 0; i < 10; i++){ a[i] = () => i; }  a[1]()  //10
for(let i = 0; i < 10; i++){ b[i] = () => i; }  b[1]()  //1
2, const必须在声明时初始化, const声明的基本类型就是常量, 声明的复杂类型只是引用不变;


>>解构赋值
可对任何可遍历的对象进行解构, 如数组、对象、字符串等;
const [a, b] = [1, 2];  //完全解构
const [a, b] = 'hi';
const {name: a, age: b} = {name: 'zhao', age: 30}; 
const {name, age} = {name: 'zhao', age: 30};
const [a, , c] = [1, 2, 3];  //部分解构
const [a=1, b=2, c] = [6, 7, 8];  //带默认值的解构
const [a=1, b=a] = [6, 7];  //a=6, b=6
const obj = {name: 'zhao', age: 32, major: 'maths', addr: 'hefei'};
const [name, ...o2} = obj;  //o2: {age: 32, major: 'maths', addr: 'hefei'}  //剩余解构
const arr = [1, [2], 3];
const [a, [b], c] = arr;  //嵌套解构


>>...(拓展运算符)的用法
1, 将数组的各个元素分离出来传递给函数
如求数组的最大值, const a = [2, 5, 1, 9, 2],
es5中的做法:
const maxNum = Math.max.apply(null, a);
es6中的做法:
const maxNum = Math.max(...a);
2, 将字符串、集合等转换为数组
const a1 = new Set([1, 2, 3]), a2 = 'hello';
const b1 = [...a1];  //集合 -> 数组
const b2 = [...a2];  //字符串 -> 字符数组
3, 数组、对象的复制
const a1 = [1, 2, 3], b1 = {name: 'zhao', age: 32};
const a2 = [...a1];  //复制数组
const b2 = {...b1};  //复制对象
4, 数组、对象的合并
const a1 = [1, 2], a2 = [2, 3]
[...a1, ...a2];  //[1, 2, 2, 3]
[...a1, 2, 3];  //[1, 2, 2, 3]
const c1 = {name: 'zhao', age: 32}, c2 = {name: 'qian', major: 'maths'}
{...c1, ...c2};  //{name: 'qian', age: 32, major: 'maths'}
{...c1, name: 'qian', major: 'maths'}
5, 用在函数的形参前表示可变参数;
function f(...names) {
	//names等价于数组
}
6, 结合部分解构
const props = {name: 'zhao', age: 30, major: 'maths'};
const {name, ...other} = props;  //name: 'zhao', other: {age: 30, major: 'maths'}


>>字符串
1, es6新增了一些字符串的方法:
s.includes(s1);  //判断字符串中是否包含指定的子串, 返回布尔值
s.startsWith(s1);  //判断字符串是否以指定的字符串开头
s.endsWith(s1);  //判断字符串是否以指定的字符串结尾
s.repeat(n);  //将字符串重复n次
'hh'.padStart(5, 'o');  //开头填充, ooohh
'hh'.padEnd(5, 'o');  //结尾填充, hhooo
2, ``(模板字符串)
``可以作为定义普通字符串、多行字符串, 也可以在其中用{}包含js的变量、表达式或函数调用;
let s1 = `My name is ${name}, I am ${age+1} years old next year`;
let s2 = `Game start, ${f()}`;
注: 模板字符串中的空格和换行都会原样保留;


>>数值
1, parseInt()和parseFloat()从全局移到Number对象;
2, Math对象扩展了很多新方法;
3, Number.isFinite()  //判断一个数值是否是有限的
Number.isInteger()  //判断是否为整数
4, a ** b  //指数运算符


>>函数
1, 默认参数
function fn(name, age=20) { //... }
es5中的做法:
function add(a, b) {
	a = a || 10;
	b = b || 20;
	return a + b;
}
es6中的做法:
const add = (a = 10, b = 20) => a + b;
2, 不定参数
function fn(...args) { //... }  //es6中...args代替了es5中的arguments;
es5中的做法:
const person = {name: 'zhao', age: 32, major: 'maths', addr: 'hefei'};
function pick() {
	const rs = Object.create(null);
	for(let i = 1; i < arguments.length; i++) {  //第一个参数为对象, 所以跳过
		rs[arguments[i]] = person[arguments[i]];
	}
	return rs;
}
es6中的做法:
const pick = (obj, ...params) => {
	const rs = Object.create(null);
	for(let i = 0; i < params.length; i++) {
		rs[params[i]] = obj[params[i]];
	}
	return rs;
}
pick(person, 'name', 'age')  //{name: 'zhao', age: 32}
pick(person, 'name', 'major', 'addr')  //{name: 'zhao', major: 'maths', addr: 'hefei'}
3, 箭头函数
var fn = (id, name) => ({id: id, name: name});
注: 当只有一个参数时, 参数可以省略(), 当函数体只有一条语句时, 可以省略{};
如果返回一个对象, 为了区分于代码块, 要用()将对象包裹起来;
注: 返回函数的函数, 使用箭头函数来简写:
const f = () => () => console.log('hello bing');
f()() //hello bing
4, 箭头函数中的this
1)箭头函数中this没有自身的作用域, 它会向外查找最近的外层作用域;
function fn() {
	setTimeout(() => {
		console.log(this.a);
	}, 1000);
}
var a = 20;
fn.call({a: 18});  //18
2)箭头函数不适合的场景, 看下面的例子:
var o1 = {
	age: 20,
	say: function(){
		console.log(this.age);  //此处的 this == o1 
	}
}
var o2 = {
	age: 20, 
	say: () => {
		console.log(this.age);  //此处的 this == window
	}
}
3)箭头函数不能作为构造函数;
const o = () => {};
new o();  //×


>>对象
1, 属性和方法都可以简写
const name = 'zhao', age = 32;
const person = {
	name, 
	age, 
	say() {
		//...
	}
}
2, 属性的计算值
const prop = 'name';
const o1 = {
	[prop]: 'zhao',
	['age'+1]: 32
};
3, 拓展运算符(...)写在对象前面, 可进行对象的复制和合并;
const o2 = {...o1};  //复制
const o3 = {...o1, ...o2};  //两个对象合并
const o3 = {...o1, name: 'qian', major: 'maths'};  //对象与其他属性的合并
4, 对象的新方法
1)Object.assign(target, source1, ...) 
将后面对象的属性复制进第一个对象, 并返回第一个对象;
const p1 = Object.assign({}, {name: 'zhao'}, {age: 32});
p1  //{name: 'zhao', age: 32}


>>数组
1, 数组的创建
1)Array.of() 
let a = Array.of(1, 2, 4);  //等价于 new Array()
2)Array.from()
用于将类数组、字符串、Set、Map等可迭代对象转化为数组;
var a1 = Array.from([1, 2, 3], n => n*n);  //[1, 4, 9]
var a2 = Array.from('hello');  //字符串->字符数组
var a3 = Array.from(new Set([1, 2, 1, 3, 1, 4]));  //[1, 2, 3, 4], 可用于数组的去重
2, 扩展运算符(...)写在数组前面, 可进行数组的复制与合并;
const a2 = [...a1];  //复制
const a3 = [...a1, ...a2];  //两个数组的合并
const a3 = [...a1, 4, 5];  //数组与其他值的合并


>>类
1, es6中的Class底层就是函数实现;
类中的成员包括静态属性、静态方法、实例属性、构造方法、原型方法等;
class Demo {
	static a = 1;  //静态属性
	b = 2;  //实例属性
	constructor(value){  //构造方法
		this.c = value;  //实例属性  
	}
	static f1() {  //静态方法
		//...
	}
	f2() {  //原型方法
		//...
	}
}
注: 类中的方法不用写function, 类中定义的方法会被放到prototype中; 调用静态方法需要用类名来调用;
注: 类定义不会被提升, 必须在使用之前定义;
2, 方法的默认写法是定义在原型上, 如果采用箭头的写法则是定义在类的实例上;
class Person {
	name = 'zhao';  //定义在实例上
	say() {  //定义在原型上
		console.log('my name is ' + this.name);
	}
	walk = () => {  //定义在实例上
		console.log(this.name + ' is walking');
	}
}
住: 箭头函数中的this不进行绑定, 所以等于外层的this;
3, 给类添加新的方法也可以通过原型来添加
class Demo {
	constructor(a, b) {
		this.a = a;
		this.b = b;
	}
	sum() {
		return this.a + this.b;
	}
}
let demo = new Demo(10, 20);
Object.getPrototypeOf(demo).sub = function() {
	return this.a - this. b;
}
此时demo的原型为:
Object.getPrototypeOf(demo):  {constructor: f, sum: f, sub: f}
4, 通过extends实现继承
class Child extends Father {  //... }


>>模块
1, es6通过import与export来导入和导出模块, 可以导入和导出函数、对象以及各种类型的变量等;
//util.js
let age = 32;
let fn = function() {  //... }
class Demo { //... }
export { age, fn, Demo }  //导出
//test.js
import { age, fn, Demo } from './util.js';  //导入
2, as
给导出或导入的名称起别名, 比如导出时隐藏模块内部的变量, 或解决导入不同模块时名称重复的问题;
import { myName as name } from './util.js';
export { myName as name };
3, export default
一个模块中 export default 只能有一个, 导入时可以不加 {}, 且可以使用任意变量名来接收;
4, import React, {Component} from 'react';
说明'react.js'文件中分别使用了默认暴露与分别暴露的形式, 形如
export class Component {
	//...
}
export default React;


>>Map和Set类型
1, Map
1)Map与Object的区别
Map的键可以是字符串、对象、函数等任意类型, Map的键值对个数可以从size属性获取, 
Map不会像Object那样可能产生对象上的键名与原型链上的键名相冲突的问题;
Map通过set()和get()函数来设置和获取值;
2)定义Map
var map = new Map();
var s1 = 'zhao'; map.set(s1, 30);  
var s2 = {}; map.set(s2, 40); 
var s3 = function(){}; map.set(s3, 50);
var s4 = NaN; map.set(s4, 60);
map.get({});  //undefined, 因为{}与{}是不同的对象
map.get(Number('abc'));  //60, 虽然NaN和自己都不相等, 但对于Map来说没有区别
map.has('zhao');  //判断map中存在指定的键
3)遍历Map
有两种遍历方式:
//for...of
for(let [k, v] of map) { //... }
for(let k of map.keys()) { //... }
for(let v of map.values()) { //... }
//forEach
map.forEach(function(value, key) { //... });
4)Map与Array的转换
var a1 = [['zhao', 25], ['qian', 32]];
var m1 = new Map(a1);  //m1: {'zhao'=>25, 'qian'=>32}
var a2 = Array.from(m1);  //a2: [['zhao', 25], ['qian', 32]]
5)Map的克隆
var m1 = new Map([['zhao', 25], ['qian', 32]]];  //注意传入的是二维数组
var m2 = m1; //m2与m1指向同一个实例
var m3 = new Map(m1);  //m3生成新的实例
6)Map的合并
var m1 = new Map([['zhao', 23], ['qian', 30]]);
var m2 = new Map(['zhao', 26], ['sun', 32], ['li', 38]);
var merged = new Map([...m1, ...m2]);  //如果有重复的键, 后面的值会覆盖前面的值
merged.size  //4 通过size属性来取得Map的大小
2, Set
1)Set存储的值唯一, Set的大小也是通过size属性来获得;
var set = new Set();
set.add(1);
set.add({x: 1, y: 2});
set.add({x: 1, y: 2});
set.size  //3 两个对象是不同的引用, 所以视为不同的元素;
set.has('zhao');  //判断set中是否存在指定的元素
2)Set与Array的转换
var a = [1, 2, 3, 2];
var s1 = new Set(a);  //s1: {1, 2, 3}
var b = [...s1];  
3)String转Set
var set = new Set('hello');  //set: {'h', 'e', 'l', 'o'}
4)Set的作用
//数组去重
var set = new Set([1, 2, 3, 3, 3]);
[...set];  //[1, 2, 3]
//进行交并补运算
var a = new Set([1, 2, 3]);
var b = new Set([2, 3, 4]);
var union = new Set([...a, ...b]);
var intersect = new Set([...a].filter(x => b.has(x)));
var diff = new Set([...a].filter(x => !b.has(x)));


>>Symbol
1, 新的原始数据类型Symbol, 表示独一无二的值, 一般用来定义对象的唯一属性名;
let a = Symbol('kk')  //字符串作为Symbol的描述
typeof a == 'symbol'  //true
Symbol('kk') == Symbol('kk');  //false
2, Symbol作为对象的属性名
var o1 = {}; o1[a] = 'zhao';  o1  //{Symbol(kk): 'zhao'}
var o2 = {[a]: 'zhao'};
Object.defineProperty(o3, a, {value: 'zhao'}); 
3, 遍历
对于一般的对象, 可以通过如下放下进行遍历:
for(let key in o){ //... }
Object.keys(o)
Object.getOwnPropertyNames(o)
Reflect.ownKeys(o)
而如果属性是Symbol类型, 则只能通过如下方式才能遍历到:
Object.getOwnPropertySymbols(o)
Reflect.ownKeys(o)


>>Iterator(迭代器)
const a = ['one', 'two', 'three'];
const iterator = a[Symbol.iterator]();
iterator.next();  //{value: 'one', done: false}
iterator.next();  //{value: 'two', done: false}
iterator.next();  //{value: 'three', done: false}
iterator.next();  //{value: undefined, done: true}


>>Generator(生成器)
1, 通过在function关键字后加*表示定义生成器;
Generator在函数内部使用yield表达式来将函数挂起, 为异步编程提供基础;
调用生成器并不会执行生成器里的内容, 只是返回一个迭代器对象;
function* func() {
	console.log('222');
	yield 2;
	console.log('333');
	yield 3;
	console.log('end');
	return 88;
}
const fn = func();  
const a = fn.next();  //222   a: {value: 2, done: false}
const b = fn.next();  //333   b: {value: 3, done: false}
const c = fn.next();  //end   c: {value: 88, done: true}


>>解决回调地狱的几种异步方案
js中的异步请求、定时器、事件处理等操作常会引起回调地狱, 有以下几种解决方法;
1, 使用Generator
function* gn() {
	showLoading();
	yield getData();
	hideLoading();
}
const g = gn();
g.next();  //执行
function showLoading() {
	console.log('show loading...');
}
function getData() {
	setTimeout(() => {
		console.log('get data');
		g.next();  //此处控制获取到数据后程序再往下走
	}, 2000);
}
function hideLoading() {
	console.log('hide loading...');
}
2, 使用Promise
function getJson() {
	return new Promise((resolve, reject) => {
		setTimeout(() => {  //使用定时器来模拟异步请求
			let flag = Math.floor(Math.random() + 0.5);
			if(flag == 1) {  //请求成功
				resolve({
					status: 200,
					data: [{name: 'zhao', age: 30}, {name: 'qian', age: 32}]
				});
			} else {  //请求失败
				reject({
					status: 400,
					message: 'get data error'
				});
			}
		}, 2000);
	});
}
getJson().then(res => { //请求成功时的处理
	console.log(res);
}).catch(err => {  //请求失败时的处理
	console.log(err);
});










