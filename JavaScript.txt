>>javascript六种数据类型：
原始类型: boolean, number, string, undefined, null;
对象: object;


>>isNaN()
判断一个变量是否是数字类型;


>>typeof与instanceof
1, typeof一般用来判断基本类型, instanceof用来判断具体的对象类型;
2, typeof的返回值可能有:
'boolean', 'number', 'string', 'undefined', 'function';
3, 对null的变量使用typeof, 返回的是'object';


>>javascript没有块级作用域；
for(var i = 0; i < 10; i++){
	//...
}
console.log(i); //10


>>连续赋值的陷阱
function foo(){
	var a = b = 1;
}
foo();
console.log(typeof a); //'undefined'
console.log(typeof b); //'number'
这里的b隐式的创建为一个全局变量，应该改为:
var a = 1, b = 1;


>>js语句是否加分号的问题
是否加分号是个人习惯, 但有两种情形必须加分号:
1)小括号开头的前一条语句;
2)中括号开头的前一条语句;


>>try...catch
//抛出基本类型如字符串
try{
	throw 'test';
}catch(ex){
	console.log(ex);
}finally{
	console.log('finally');
}
//抛出对象
try{
	throw new Error('test');
}catch(ex){
	console.log(ex.message);
}finally{
	console.log('finally');
}
注：finally语句可有可无, 无论是否抛出异常，finally都会被执行;


//for...in
var obj = {x: 1, y: 2};
for(var p in obj){
	//...
}
注：使用for...in时要注意，
1, 属性顺序不确定;
2, 属性标签enumerable为false时不会出现;
3, 属性受原型链的影响;


>>with
with可以关联一个对象到当前作用域。
with(document.forms[0]){
	console.log(name.value);
}
注: with语句有以下缺点：
1，可读性差；
2，让JS引擎优化更难；
3，严格模式下被禁用；
4，可被变量定义代替；
使用变量定义来代替，如下：
var form = document.form[0];
console.log(form.name.value);


>>对象的创建
1, 对象字面量
var obj = {x: 1, y: 2};
2, 构造函数
function foo(){this.x = 1; this.y = 2;}
foo.prototype.z = 3;
var obj = new foo();
3, Object.create(o);
该方法创建了一个以o为原型的空对象;


>>读对象的属性前要判断对象是否存在
var yz, obj = {};
if(obj.y){
	yz = obj.y.z;
}
上面的程序段可以简写如下：
var yz = obj && obj.y && obj.y.z;


>>使用[]而不能用.访问对象属性的情形
1, 属性名包含特殊字符, 如 content-type;
2, 属性名是用变量表示的, 如 var key = 'age'; obj[key] = 20;
3, 属性名通过计算得到, 如 var key = 'age'; obj['get'+key];


>>Object.keys(obj)
返回对象obj的所有可枚举属性组成的数组;


>>对象属性的标签
1, 四个静态标签和两个读写的方法:
configurable, writable, enumerable, value;
get, set;
2, Object.defineProperty()
//给对象添加一个属性，并给该属性指定相关标签
var person = {};
Object.defineProperty(person, 'name', {
	enumerable: true,
	value: 'zhao'
});
注：用Object.defineProperty()方法添加属性，默认情况下该属性的标签都为false；
而用对象字面量的方式添加属性，属性的标签默认为true；
3, Object.defineProperties()
//给对象添加多个属性，并指定标签
var person = {};
Object.defineProperties(person, {
	title: {value: 'fe', enumerable: true},
	corp: {value: 'baba', enumerable: true},
	salary: {value: 10000, enumerable: true, writable: true}
});
4, Object.getOwnPropertyDescriptor()
//取对象的某个属性的所有标签，返回结果为一个对象
Object.getOwnPropertyDescriptor(person, 'salary');
//Object{value: 10000, writable: true, enumerable: true, configurable: false}
5, Object.getOwnPropertyDescriptors()
//取对象的所有属性的所有标签，返回结果为一个对象
Object.getOwnPropertyDescriptors(person);
//Object{title: {...}, corp: {...}, salary: {...}}
6, get/set方法
1)通过对象字面量来定义get/set方法
var man = {
	name: 'Bosn',
	_age: null,
	get age(){
		if(this._age == undefined){
			return new Date().getFullYear() - 1988;
		}else{
			return this._age;
		}	
	},
	set age(val){
		if(!isNaN(val) && val > 0 && val < 150){
			this._age = val;
		}else{
			throw new Error('Incorrect val = ' + val);
		}
	}
};
man.age; //32
man.age = 100;
man.age; //100
man.age = 'abc'; //error:Incorrect val = abc
2)通过Object.defineProperties()方法来定义get/set方法
var person = {};
Object.defineProperties(person, {
	title: {value: 'fe', enumerable: true},
	corp: {value: 'baba', enumerable: true},
	salary: {value: 10000, enumerable: true, writable: true},
	luck: {
		get: function(){
			return Math.random() > 0.5 ? 'good' : 'bad';
		}
	},
	promote: {
		set: function(level){
			this.salary *= 1 + level*0.1;
		}
	}
});
person.salary; //10000
person.promote = 2;
person.salary; //12000


>>对象的序列化
1, JSON.stringify(obj)
将对象序列化为字符串
2, JSON.parse(str)
将json字符串解析为对象
2, 可以通过toJSON来定制序列化的过程
var obj = {
	x: 1,
	y: 2,
	o: {
		o1: 1,
		o2: 2,
		toJSON: function(){
			return this.o1 + this.o2;
		}
	}
};
JSON.stringify(obj); //'{"x":1,"y":2,"o":3}'


>>对象转换为基本类型的过程
首先查找对象的valueOf()方法, 如果valueOf()方法不存在或者返回对象,
则继续查找toString()方法, 如果toString()方法也不存在或者返回对象,
则报错;


>>String对象
1, 常用方法
1)charAt()
指定位置的字符
2)indexOf()/lastIndexOf()
指定的字符第一次出现的位置
var s = 'hello,world';
s.indexOf('o'); //4
s.indexOf('o', 5); //7
s.lastIndexOf('o'); //7
3)substring()
提取指定起止的子字符串
4)substr()
提取指定数目的子字符串
var s = 'hello,world';
s.substring(2, 6); //'llo,'
s.substr(2, 6); //'llo,wo'
5)search()
查找指定子串的位置，不存在则返回-1
'aaa123bbb'.search('123'); //3
'aaa123bbb'.search(/\w\d/); //2
6)replace()
对指定的子串进行替换
'a1b1c1'.replace('1', 'X'); //'aXb1c1'
'a1b1c1'.replace(/1/g, 'X'); //'aXbXcX'
7)split()
字符串分割
var s = 'hello,world';
s.split(','); //['hello', 'world']
s.split(''); //['h', 'e', 'l', 'l', 'o', ',', 'w', 'o', 'r', 'l', 'd']
s.split('', 5); //['h', 'e', 'l', 'l', 'o']
'a1b2c3d4'.split(/\d/); //['a', 'b', 'c', 'd', '']
8)match()
正则匹配
var r = 'a1b2c3d4'.match(/(\w)\d/);
r; //['a1', 'a', index: 0]
var r = 'a1b2c3d4'.match(/(\w)\d/g);
r; //['a1', 'b2', 'c3', 'd4']
2, ES6中新增的方法
1)s.includes(s1)  //判断字符串中是否包含指定的子串, 返回布尔值
2)s.startsWith(s1)/s.endsWith(s1)  //判断字符串是否以指定的字符串开头/结尾
3)s.repeat(n)  //将字符串重复n次
4)'hh'.padStart(5, 'o')/'hh'.padEnd(5, 'o')  //开头/结尾填充, ooohh/hhooo


//Number对象
Number.parseInt()和Number.parseFloat()  //ES6中将parseInt()与parseFloat()从全局移到Number
Number.isFinite()  //判断一个数值是否是有限的
Number.isInteger()  //判断是否为整数
a ** b  //指数运算符


>>Math对象
1, 常用方法
1)Math.floor(), Math.ceil(), Math.round();
2)Math.random();
返回介于[0, 1)之间的小数;
注；四舍五入到指定小数点位数用 toFixed();
var a = 3.146;
a.toFixed(2); //3.15


>>Date对象
1, 创建Date对象
new Date(); //当前时间
new Date('October 13, 1975 11:13:00');
new Date(75, 10, 13, 11, 13, 0);
2, 获取与设置
d.getFullYear()/d.setFullYear();
d.getMonth()/d.setMonth(); //月份从0开始计算
d.getDate()/d.setDate();
d.getHours()/d.setHours();
d.getMinutes()/d.setMinutes();
d.getSeconds()/d.setSeconds();
d.getDay(); //星期只有获取，没有设置函数
举例：
d.setDate(d.getDate()+2);
3, 时间戳(单位是毫秒)
d.getTime();
d.setTime();
举例: 
d.setTime(d.getTime()+24*60*60*1000); //将时间设置为一天后


>>数组的创建
1, 数组字面量
var arr = [1, 2, 4];
2, 构造函数
var arr = new Array(1, 2, 4);


>>常用的数组方法
1, Array.isArray()
判断一个对象是否为数组；
注意该方法属于Array构造器的方法，其他方法为Array.prototype的方法；
2，arr.indexOf()，arr.lastIndexOf()
查找元素在数组中的下标，如果不存在则返回-1;
也可以指定查找的起始位置；
3, arr.push()
将元素添加到数组尾部，返回数组的长度
4, arr.pop()
删除数组的最后一个元素，并返回该元素
5，arr.unshift()
将元素添加到数组头部，返回数组的长度
6，arr.shift()
删除数组的第一个元素，并返回该元素
7，arr.join()
将数组元素以指定分隔符连接成字符串，如果不指定分隔符，默认以逗号分隔；
8，arr.reverse()
数组逆序，注意该方法为本地方法，会修改原数组
9，arr.sort()
默认按字符串的顺序来排序，如果需要按数字的顺序或者要排序对象，需要自定义函数来排序；
该方法也是本地方法，会修改原数组；
10，arr.concat()
数组连接, 该方法不会改变原数组
var arr = [1, 2, 3];
arr.concat([10, 11], 13); //[1, 2, 3, 10, 11, 13]
11, arr.slice(start, end)
返回数组片段
12，arr.splice()
数组拼接，返回被删除的元素组成的数组，该方法为本地方法，会修改原数组
var arr = [1, 2, 3, 4];
var b= arr.splice(1, 2, 'a', 'b'); //[1, 'a', 'b', 4]
b; //[2, 3]
13, arr.forEach()
遍历数组
var arr = [1, 2, 3];
arr.forEach(function(x, index, a){
	console.log(x + '|' + index + '|' + (a === arr));
});
//1|0|true
//2|1|true
//3|2|true
14, arr.map()
数组映射，该方法不修改原数组
var arr = [1, 2, 3];
var b= arr.map(function(x){
	return x + 10;
});
b; //[11, 12, 13]
arr; //[1, 2, 3]
15, arr.filter()
数组过滤，该方法不修改原数组
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var b = arr.filter(function(x, index){
	return x % 3 === 0;
});
b; //[3, 6, 9]
arr; //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
16, arr.every()
判断数组中的所有元素满足某个条件
17，arr.some()
判断数组中是否存在元素满足某个条件


>>函数的创建
1，函数声明
function foo(){}
2, 函数表达式
var foo = function(){}
注：函数声明可以提前调用，而函数表达式不可以；


>>函数的调用方式
1，直接调用
foo();
2, 对象方法
o.method();
3, 构造器
new Foo();
4, call/apply/bind
func.call(o);


>>this
一般情况下，this绑定到调用该函数的对象上, 如果没有显式的调用者, 则其调用者为window;


>>回调函数
1, 回调函数的三要素
你自己定义的; 你并没有调用; 函数最终执行了;
2, 常见的回调函数
1)事件处理函数;
2)定时器函数;
3)Ajax请求回调函数;
4)生命周期函数;
5)其他回调函数, 如数组方法中的回调函数;


>>js函数作为一般函数调用和作为构造函数的区别
作为一般函数调用时，如果有return返回值则取返回值，没有则是undefined；
作为构造函数时，如果return一个对象，则返回该对象，如果没有return或者return一个基本类型，则按默认返回this处理;
function f1(){
	this.a = 1;
	return 5;
}
f1(); //5
new f1(); //{a: 1}
function f2(){
	this.a = 1;
	return {b: 2};
}
f2(); //{b: 2}
new f2(); //{b: 2}


>>call/apply
call()和apply()可以将函数中的this绑定到指定的对象
function add(c, d){
	return this.a + this.b + c + d;
}
var o = {a: 10, b: 20};
add.call(o, 1, 2); //33
add.apply(o, [1, 2]); //33
注：call()与apply()的作用一样，区别是call()以扁平化的方式传参，而apply()是以数组的方式传参；


>>bind()
1, 将函数中的this绑定到指定的对象, bind()返回的仍然是一个函数
function f(){return this.a;}
var o = {a: 1};
var g = f.bind(o);
g(); //1
2, currying
科里化，将一个函数拆分成不同的单元；
function add(a, b, c){
	return a + b + c;
}
var f1 = add.bind(null, 100);
f1(1, 2); //103
var f2 = f1.bind(null, 1000);
f2(1); //1101


>>变量提升与函数提升
1, 通过var定义的变量或函数表达式, 在定义之前就可以访问到, 但是值为: undefined;
通过函数声明定义的函数, 在定义之前就可以调用;
2, 下面两段程序的输出不同可以看出变量提升的效果;
1)var a = 1;
function fn() {
	console.log(a); //输出: 1
}
fn();  
2)var a = 1;
function fn() {
	console.log(a);  //输出: undefined
	var a = 2;
}
fn();
3, 变量的赋值在变量提升和函数提升之后
var c = 1;
function c(c) {
	console.log(c)
}
c(2);  //报错: c不是函数


>>执行上下文
1, 全局执行上下文
全局执行上下文对象就是window, 在正式执行代码前会进行预处理, 将全局定义的变量和函数添加为window的属性;
2, 函数执行上下文
function fn(x, y) {
	var a = 1;
	function f1() {
		console.log('f1');
	}
	var f2 = function() {
		console.log('f2');
	}
}
fn(2, 3); 
在正式执行函数前, 会预处理形成函数执行上下文:
{
	a: undefined,
	f1: f,
	f2: undefined,
	arguments: 实参列表的伪数组,
	this: 函数的调用者,
}
注: 函数执行上下文是在函数调用时产生, 而不是函数定义时;
3, 执行上下文栈
全局执行上下文和多个嵌套的函数执行上下文, 形成执行上下文栈;


>>作用域与作用域链
1, 分为全局作用域、函数作用域, ES6之前没有块级作用域(ES6之后有了);
作用域用来隔离变量, 同一作用域中的变量不能重复;
2, 多个作用域形成作用域链, 变量由内而外进行查找, 如果都不存在则报错;
3, 作用域与执行上下文的区别
作用域是在函数定义时确定的, 是静态的; 而执行上下文是在函数调用时确定, 是动态的;
4, var obj = {
	fn: function() {
		console.log(fn);  //报错
		console.log(this.fn);  //正常
	}
}
第一条语句报错是因为先在函数作用域中查找fn, 没有则再去全局作用域中查找, 仍然没有, 则报错;


>>闭包(closure)
满足以下两个条件就构成闭包:
1)函数嵌套;
2)内部函数引用了外部函数的变量;
function outer(){
	var a = 30;
	return function(){
		return a;
	}
}
var func = outer(); 
func(); //30
1, 闭包的常见例子：
1)事件点击
(function(){
	var localData = 'localData here';
	document.addEventListener('click', function(){
		console.log(localData);
	});
})();
2)异步请求的回调
(function(){
	var localData = 'localData here';
	$.ajax({
		url: 'test.php',
		success: function(){
			console.log(localData);
		}
	});
})();
2, 循环监听
以下程序段是循环遍历监听常见的错误：
document.body.innerHTML = '<div id="div1">aaa</div>' + 
	'<div id="div2">bbb</div><div id="div3">ccc</div>';
for(var i = 1; i < 4; i++){
	document.getElementById('div'+i).addEventListener('click', function(){
		alert(i); //all are 4!
	});
}
可使用闭包改写为:
for(var i = 1; i < 4; i++){
	(function(k){
		document.getElementById('div'+k).addEventListener('click', function(){
			alert(k);
		});
	})(i);
}
3, 闭包的优点
1)永久保存外层函数的变量；
2)实现封装，避免全局对象的污染：
var person = {};
(function(){
	var name = 'zhao';
	var age = 30;
	person.getName = function(){
		return name;
	};
	person.getAge = function(){
		return age;
	};
})();
或者
var person = function(){
	var name = 'zhao';
	var age = 30;
	return {
		getName: function(){
			return name;
		},
		getAge: function(){
			return age;
		}
	};
}();
或者
var person = new function(){
	var name = 'zhao';
	var age = 30;
	this.getName = function(){
		return name;
	};
	this.getAge = function(){
		return age;
	}
};
4, 闭包的缺点
1)空间浪费
2)内存泄漏
3)性能消耗
使用完闭包后, 为避免内存泄漏, 应及时释放引用:
var func = outer();
func();
func = null;  //释放引用
5, 内存溢出与内存泄漏的区别
1)内存溢出 
是一种程序运行时错误, 当程序运行需要的内存超过了剩余的内存时, 就会抛出内存溢出的错误;
2)内存泄漏
不是错误, 而是占用的内存没有及时释放, 累计的内存泄漏会导致内存溢出;
常见的内存泄漏有几下几种:
(i)意外的全局变量;
(ii)没有及时清理的计时器或回调函数;
(iii)闭包;


>>无闭包与有闭包举例
1, 无闭包
var name = 'the window';
var obj = {
	name: 'the object',
	func: function() {
		return function() {
			return this.name;
		}
	}
}
obj.func()();  //'the window'
只满足闭包的条件(1)函数嵌套, 并不满足条件(2), 内部函数并没有引用外部函数的变量, 
所以不是闭包;
2, 有闭包
var name = 'the window';
var obj = {
	name: 'the object',
	func: function() {
		var that = this;
		return function() {
			return that.name;
		}
	}
}
obj.func()();  //'the object'
同时满足闭包的两个条件, 所以是闭包;


>>原型(prototype)
每个js函数都有一个prototype属性, 每个实例对象都有一个__proto__属性;
function Foo(){
	this.x = 1;
}
Foo.prototype.y = 2;
new Foo()的初始结构: 
{
	__proto__: Foo.prototype,
	x: 1
}
Foo.prototype的初始结构:
{
	constructor: Foo,
	__proto__: Object.prototype,
	y: 2
}


>>基于原型的继承
function Person(name, age){ 
	this.name = name;
	this.age = age;
}
Person.prototype.say = function(){
	console.log('My name is ' + this.name + ', I am ' + this.age + 
		' years old.');
};
Person.prototype.walk = function(){
	console.log(this.name + ' is walking.');
};
function Student(name, age, major){
	Person.call(this, name, age);
	this.major = major;
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
Student.prototype.say = function(){
	console.log('My name is ' + this.name + ', I am ' + this.age + 
		' years old, I am majoring ' + this.major);
};
Student.prototype.learn = function(){
	console.log(this.name + ' is learning.');
};
这是最经典的组合式原型继承,
通过Person.call(this, name, age)继承基类的构造函数,
通过Student.prototype = Object.create(Person.prototype)继承基类的原型;
Student的原型链如下：
Student.prototype -> Person.prototype -> Object.prototype -> null;


>>原型链
构造函数Student的prototype属性和实例对象stu的__proto__属性都指向Student.prototype;
Student.prototype:
{
	study: f,
	constructor: Student,
	__proto__: Person.prototype
}
Person.prototype:
{
	walk: f,
	constructor: Person,
	__proto__: Object.prototype
}
Object.prototype:
{
	constructor: Object,
	__proto__: null,
	toString: f,
	hasOwnProperty: f,
	...
}
每个原型对象中的__proto__属性依次指向上一层原型对象, 就构成了原型链;


>>Object与Function
var p = new Person('zhao', 30), 其中,
p是Person的实例对象, 同时Person也是Function的实例对象;
Object与Function的关系比较微妙, 它们互为对方的实例对象;
有如下关系成立:
p.__proto__ === Person.prototype;  //true
Person.__proto__ === Function.prototype;  //true
Object instanceof Function;  //true
Function instanceof Object;  //true
Function.prototype.hasOwnProperty('bind');  //true


>>进程与线程
1, 进程是操作系统分配资源的最小单位, 线程是程度执行与调度的最小单位, 一个进程一般包含多个线程;
进程占有独立的一段内存, 多个进程之间的数据不能共享, 一个进程内的数据可以供多个线程共享;
2, js是单线程运行, 但使用H5中的 Web Workers 可以多线程运行;
3, 浏览器是多线程运行, 浏览器内核常用的模块:
1)主线程模块: js引擎模块、html/css文档解析模块、dom解析模块、布局和渲染模块等等;
2)分线程模块: 定时器模块、事件响应模块、网络请求模块等等;
注: 定时器回调函数是在主线程执行, 因为js是单线程的, 所以定时器并不能保证定时执行, 有可能会延迟;


>>Web Workers
1, h5提供的一个js多线程解决方案, 可以将计算量大的代码交由Web Workers完成,
但是子线程完全受主线程控制, 且不得操作DOM, 这个新标准并没有改变js单线程的本质;
2, 使用步骤
1)主线程
document.getElementById('btn').onclick = function() {
	var num = document.getElementById('num').value;
	//创建一个Worker对象
    var worker = new Worker('worker.js');
	//接收分线程传过来的数据函数
    worker.onmessage = function(e) {
        console.log(e.data);
    }
    //向分线程发送数据
    worker.postMessage(num);
}
2)分线程 worker.js
var onmessage = function(e) { 
    var num = e.data;  //主线程传过来的数据
    var r = fn(num);
    postMessage(r); //把结果传给主线程
}
function fn(n) {
    return n <= 2 ? 1 : fn(n-1) + fn(n-2);
}
注: 分线程中的全局对象不是window, 所以分程序只能用于计算, 不能操作界面;
目前并不是所有浏览器都支持, 所有应用较少;


>>BOM
1, window对象
BOM的核心，window对象指当前的浏览器窗口;
常用方法:
1)open()/close()
var win = window.open([url], [窗口名称], [参数字符串]);
url: http://www.baidu.com 或 test.php;
窗口名称: _blank(在新窗口打开, 默认), _self(当前窗口), _top(顶部窗口);
参数字符串: 'width=600,height=300,top=100,left=100,menubar=yes,toolbar=no,scrollbars=yes,status=yes';
window.close(); //关闭本窗口
win.close(); //关闭指定窗口
2)alert()/confirm()/prompt()
警示框、确认框、输入框;
3)print()
打印当前窗口内容
4)focus()/blur()
将焦点移入指定窗口或从指定窗口移开
5)moveBy()/moveTo(), resizeBy()/resizeTo(), scrollBy()/scrollTo()
移动窗口、调整窗口尺寸、滚动窗口内容;
6)setTimeout()/clearTimeout(), setInterval()/clearInterval()
计时器
var i = setInterval(function(){
	//...
}, 1000); //时间间隔的单位为毫秒
clearInterval(i);
2, history对象
记录用户浏览过的页面的历史记录，从窗口打开的那一刻开始记录;
history.length; //浏览器历史列表中的url数量
常用方法:
1)back()
前进到前一个页面，相当于go(-1);
2)forward()
后退到后一个页面，相当于go(1);
3)go(n)
跳转到某个具体的页面;
3, location对象
用于解析窗体的url;
举例: http://www.imooc.com:8080/list.php?courseid=8&chapterid=86#mediaid118
常用属性:
1)href //返回完整的url
2)protocol //协议 http
3)hostname //主机名 www.immoc.com
4)port //端口号 8080
5)host //主机名+端口号 www.imooc.com:8080
6)pathname //路径 list.php
7)search //查询字符串 ?courseid=8&chapterid=96
8)hash //锚 #mediaid118
常用方法:
1)assign()
加载新的文档
2)reload()
重新加载当前文档
3)replace()
用新的文档替换当前文档
4, navigator对象
包含浏览器的相关信息;
常用属性:
1)userAgent //用户代理，客户端发送给服务器的user-agent头部的值
2)appName //浏览器的名称
3)appVersion //浏览器的版本信息
4)appCodeName //浏览器代码名的字符串表示
5)platform //浏览器运行的操作系统信息
5, screen对象
用户的屏幕信息;
常用属性:
1)width/height //屏幕的宽度与高度
2)availWidth/availHeight //屏幕的可用宽度与可用高度
3)colorDepth //颜色位数


>>各种对象的尺寸
1, offsetParent
布局中设置了position属性(relative、absolute、fixed)的父容器，从最近的父节点开始查找，
一直到document.body;
2, 盒子的宽度与高度
box.offsetWidth;
box.offsetHeight;
3, 盒子的左边距和上边距
box.offsetLeft;
box.offsetTop;
4, 盒子滚动条的偏移距离
box.scrollLeft;
box.scrollTop;
5, 窗口显示区域的宽度与高度，不包括滚动条
window.innerWidth;
window.innerHeight;


>>ES6的新特性
1, let和const命令
2, 模板字符串
3, 解构赋值与解构运算符
4, 箭头函数
5, 类(class)
6, 模块化
7, 字符串、数组、对象新增的方法
8, Map和Set类型
9, Symbol
10, 异步操作(Promise, async await)


>>let和const
1, let与var的区别:
1)let有块级作用域
2)let不允许重复声明
3)let不存在变量提升;
4)var声明的全局变量都会绑定到window上, 而let不会;
var a = 1; window.a  //1
let b = 2; window.b  //error
5)避免闭包中var存在的问题;
const a = [], b = [];
for(var i = 0; i < 10; i++){ a[i] = () => i; }  a[1]()  //10
for(let i = 0; i < 10; i++){ b[i] = () => i; }  b[1]()  //1
2, const必须在声明时初始化, const声明的基本类型就是常量, 声明的复杂类型只是引用不变;


>>模板字符串
``可以作为定义普通字符串、多行字符串, 也可以在其中用{}包含js的变量、表达式或函数调用;
let s1 = `My name is ${name}, I am ${age+1} years old next year`;
let s2 = `Game start, ${f()}`;
注: 模板字符串中的空格和换行都会原样保留;


>>解构赋值与解构运算符(又叫拓展运算符)
1, 可对任何可遍历的对象进行解构, 如数组、对象、字符串等;
const [a, b] = [1, 2];  //完全解构
const [a, b] = 'hi';
const {name: a, age: b} = {name: 'zhao', age: 30}; 
const {name, age} = {name: 'zhao', age: 30};
const [a, , c] = [1, 2, 3];  //部分解构
const [a=1, b=2, c] = [6, 7, 8];  //带默认值的解构
const [a=1, b=a] = [6, 7];  //a=6, b=6
const obj = {name: 'zhao', age: 32, major: 'maths', addr: 'hefei'};
const {name, ...o2} = obj;  //o2: {age: 32, major: 'maths', addr: 'hefei'}  //剩余解构
const arr = [1, [2], 3];
const [a, [b], c] = arr;  //嵌套解构
2, ...(解构运算符)的用法
1)将数组的各个元素分离出来传递给函数
如求数组的最大值, const a = [2, 5, 1, 9, 2],
es5中的做法:
const maxNum = Math.max.apply(null, a);
es6中的做法:
const maxNum = Math.max(...a);
2)将字符串、集合等转换为数组
const a1 = new Set([1, 2, 3]), a2 = 'hello';
const b1 = [...a1];  //集合 -> 数组
const b2 = [...a2];  //字符串 -> 字符数组
3)数组、对象的复制
const a1 = [1, 2, 3], b1 = {name: 'zhao', age: 32};
const a2 = [...a1];  //复制数组
const b2 = {...b1};  //复制对象
4)数组、对象的合并
const a1 = [1, 2], a2 = [2, 3]
[...a1, ...a2];  //[1, 2, 2, 3]
[...a1, 2, 3];  //[1, 2, 2, 3]
const c1 = {name: 'zhao', age: 32}, c2 = {name: 'qian', major: 'maths'}
{...c1, ...c2};  //{name: 'qian', age: 32, major: 'maths'}
{...c1, name: 'qian', major: 'maths'}
5)用在函数的形参前表示可变参数;
function f(...names) {
	//names等价于数组
}
6)结合部分解构
const props = {name: 'zhao', age: 30, major: 'maths'};
const {name, ...other} = props;  //name: 'zhao', other: {age: 30, major: 'maths'}


>>箭头函数
1, 基本形式
const f1 = (a) => { return a*2; }
const f2 = a => { return a*2; }  //只有一个参数时, 可以省略()
const f3 = a => a*2		//函数体只有一条语句时, 可以省略{}
const f4 = a => ({age: a})  //如果返回对象, 必须用()包裹起来
const f5 = () => () => console.log('hello');  //返回函数的函数
2, 箭头函数中的this
箭头函数中this没有自身的作用域, 它会向外查找最近的外层作用域;
var o1 = {
	age: 20,
	say: function(){
		console.log(this.age);  //此处的 this == o1 
	}
}
var o2 = {
	age: 20, 
	say: () => {
		console.log(this.age);  //此处的 this == window
	}
}


>>类
1, 类中的成员包括静态属性、静态方法、实例属性、构造方法、原型方法等;
class Demo {
	static a = 1;  //静态属性
	b = 2;  //实例属性
	constructor(value){  //构造方法
		this.c = value;  //实例属性  
	}
	static f1() {  //静态方法
		//...
	}
	f2() {  //原型方法
		//...
	}
	f3 = () => {  //实例方法
		//...
	}
}
注: 类中的方法默认是定义在原型上的; f3的写法是作为实例属性, 所以定义在类的实例上;
es6中的class底层就是函数实现;
2, 通过extends实现继承
class Person { 
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}
	say() {
		console.log('My name is ' + this.name + ', I am ' + this.age + 
			' years old.');
	}
	walk() {
		console.log(this.name + ' is walking.');
	}
}
class Student extends Person {
	constructor(name, age, major) {
		super(name, age);
		this.major = major;
	}
	say() {
		console.log('My name is ' + this.name + ', I am ' + this.age + 
			' years old, I am majoring ' + this.major);
	}
	learn() {
		console.log(this.name + ' is learning.');
	}
}


>>模块
1, es6通过import与export来导入和导出模块, 可以导入和导出函数、对象以及各种类型的变量等;
//util.js
let age = 32;
let fn = function() {  //... }
class Demo { //... }
export { age, fn, Demo }  //导出
//test.js
import { age, fn, Demo } from './util.js';  //导入
2, as
给导出或导入的名称起别名, 比如导出时隐藏模块内部的变量, 或解决导入不同模块时名称重复的问题;
import { myName as name } from './util.js';
export { myName as name };
3, export default
一个模块中 export default 只能有一个, 导入时可以不加 {}, 且可以使用任意变量名来接收;
4, import React, {Component} from 'react';
说明'react.js'文件中分别使用了默认暴露与分别暴露的形式, 形如
export class Component {
	//...
}
export default React;


>>ES6中函数、对象、数组新增的功能
1, 函数
1)默认参数
function fn(name, age=20) { //... }
es5中的做法:
function add(a, b) {
	a = a || 10;
	b = b || 20;
	return a + b;
}
es6中的做法:
const add = (a = 10, b = 20) => a + b;
2)不定参数
function fn(...args) { //... }  
es6中...args代替了es5中的arguments;
3)高阶函数
如果一个函数的参数或者返回值也为函数, 则该函数称为高阶函数;
常见的高阶函数: Promise, setTimeout, 数组的方法(如arr.filter, arr.forEach)
4, 对象
1)属性和方法都可以简写
const name = 'zhao', age = 32;
const person = {
	name, 
	age, 
	say() {
		//...
	}
}
2)属性的计算值
const prop = 'name';
const o1 = {
	[prop]: 'zhao',
	['age'+1]: 32
};
3)拓展运算符(...)写在对象前面, 可进行对象的复制和合并;
const o2 = {...o1};  //复制
const o3 = {...o1, ...o2};  //两个对象合并
const o3 = {...o1, name: 'qian', major: 'maths'};  //对象与其他属性的合并
5, 数组
1)Array.of() 
let a = Array.of(1, 2, 4);  //等价于 new Array()
2)Array.from()
用于将类数组、字符串、Set、Map等可迭代对象转化为数组;
var a1 = Array.from([1, 2, 3], n => n*n);  //[1, 4, 9]
var a2 = Array.from('hello');  //字符串->字符数组
var a3 = Array.from(new Set([1, 2, 1, 3, 1, 4]));  //[1, 2, 3, 4], 可用于数组的去重
3)扩展运算符(...)写在数组前面, 可进行数组的复制与合并;
const a2 = [...a1];  //复制
const a3 = [...a1, ...a2];  //两个数组的合并
const a3 = [...a1, 4, 5];  //数组与其他值的合并


>>Map和Set类型
1, Map
1)Map与Object的区别
Map的键可以是字符串、对象、函数等任意类型, Map的键值对个数可以从size属性获取, 
Map不会像Object那样可能产生对象上的键名与原型链上的键名相冲突的问题;
Map通过set()和get()函数来设置和获取值;
2)定义Map
var map = new Map();
var s1 = 'zhao'; map.set(s1, 30);  
var s2 = {}; map.set(s2, 40); 
var s3 = function(){}; map.set(s3, 50);
var s4 = NaN; map.set(s4, 60);
map.get({});  //undefined, 因为{}与{}是不同的对象
map.get(Number('abc'));  //60, 虽然NaN和自己都不相等, 但对于Map来说没有区别
map.has('zhao');  //判断map中存在指定的键
3)遍历Map
有两种遍历方式:
//for...of
for(let [k, v] of map) { //... }
for(let k of map.keys()) { //... }
for(let v of map.values()) { //... }
//forEach
map.forEach(function(value, key) { //... });
4)Map与Array的转换
var a1 = [['zhao', 25], ['qian', 32]];
var m1 = new Map(a1);  //m1: {'zhao'=>25, 'qian'=>32}
var a2 = Array.from(m1);  //a2: [['zhao', 25], ['qian', 32]]
5)Map的克隆
var m1 = new Map([['zhao', 25], ['qian', 32]]];  //注意传入的是二维数组
var m2 = m1; //m2与m1指向同一个实例
var m3 = new Map(m1);  //m3生成新的实例
6)Map的合并
var m1 = new Map([['zhao', 23], ['qian', 30]]);
var m2 = new Map(['zhao', 26], ['sun', 32], ['li', 38]);
var merged = new Map([...m1, ...m2]);  //如果有重复的键, 后面的值会覆盖前面的值
merged.size  //4 通过size属性来取得Map的大小
2, Set
1)Set存储的值唯一, Set的大小也是通过size属性来获得;
var set = new Set();
set.add(1);
set.add({x: 1, y: 2});
set.add({x: 1, y: 2});
set.size  //3 两个对象是不同的引用, 所以视为不同的元素;
set.has('zhao');  //判断set中是否存在指定的元素
2)Set与Array的转换
var a = [1, 2, 3, 2];
var s1 = new Set(a);  //s1: {1, 2, 3}
var b = [...s1];  
3)String转Set
var set = new Set('hello');  //set: {'h', 'e', 'l', 'o'}
4)Set的作用
//数组去重
var set = new Set([1, 2, 3, 3, 3]);
[...set];  //[1, 2, 3]
//进行交并补运算
var a = new Set([1, 2, 3]);
var b = new Set([2, 3, 4]);
var union = new Set([...a, ...b]);
var intersect = new Set([...a].filter(x => b.has(x)));
var diff = new Set([...a].filter(x => !b.has(x)));


>>Symbol
1, 新的原始数据类型Symbol, 表示独一无二的值, 一般用来定义对象的唯一属性名;
let a = Symbol('kk')  //字符串作为Symbol的描述
typeof a == 'symbol'  //true
Symbol('kk') == Symbol('kk');  //false
2, Symbol作为对象的属性名
var o1 = {}; o1[a] = 'zhao';  o1  //{Symbol(kk): 'zhao'}
var o2 = {[a]: 'zhao'};
Object.defineProperty(o3, a, {value: 'zhao'}); 


>>异步操作
1, Promise
new Promise((resolve, reject) => {
	let flag = Math.random()
	if(flag >= 0.5) {
		resolve('big enough')  //成功的时候调用resolve()
	} else {
		reject('too small')  //失败的时候调用rejecct()
		//throw new Error('too small')  等价
	}
}).then(res => {  //处理成功的逻辑
	console.log(res)
}).catch(err => {  //处理失败的逻辑
	console.log(err)
})
2,async await
async放在函数前表示该函数是一个异步操作, await后面的值自动转换为Promise对象;
async函数里可以包含多个异步操作, 等所有await执行完, 再执行then操作;
async function f() {
	let s = await 'hello world';  //异步操作1(假设)
	let data = await s.split(' ');  //异步操作2
	let flag = Math.random()
	if(flag >= 0.5) {  //模拟成功
		return data;
	} else {  //模拟失败
		throw new Error('请求数据失败');
		return await Promise.reject('请求数据失败');  //或者
	}
}
f().then(res => {
	console.log(res);  //['hello', 'world']
}).catch(err => {
	console.log(err);  //'请求数据失败'
});









