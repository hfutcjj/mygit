*********************************JavaScript*********************************************
>>javascript六种数据类型：
原始类型: boolean, number, string, undefined, null;
对象: object;

>>isNaN()
判断一个变量是否是数字类型;

>>javascript没有块级作用域；
for(var i = 0; i < 10; i++){
	//...
}
console.log(i); //10

>>连续赋值的陷阱
function foo(){
	var a = b = 1;
}
foo();
console.log(typeof a); //'undefined'
console.log(typeof b); //'number'
这里的b隐式的创建为一个全局变量，应该改为:
var a = 1, b = 1;

>>try...catch
//抛出基本类型如字符串
try{
	throw 'test';
}catch(ex){
	console.log(ex);
}finally{
	console.log('finally');
}
//抛出对象
try{
	throw new Error('test');
}catch(ex){
	console.log(ex.message);
}finally{
	console.log('finally');
}
注：finally语句可有可无, 无论是否抛出异常，finally都会被执行;

//for...in
var obj = {x: 1, y: 2};
for(var p in obj){
	//...
}
注：使用for...in时要注意，
1, 属性顺序不确定;
2, 属性标签enumerable为false时不会出现;
3, 属性受原型链的影响;

>>with
with可以关联一个对象到当前作用域。
with(document.forms[0]){
	console.log(name.value);
}
注: with语句有以下缺点：
1，可读性差；
2，让JS引擎优化更难；
3，严格模式下被禁用；
4，可被变量定义代替；
使用变量定义来代替，如下：
var form = document.form[0];
console.log(form.name.value);

>>对象的创建
1, 对象字面量
var obj = {x: 1, y: 2};
2, 构造函数
function foo(){this.x = 1; this.y = 2;}
foo.prototype.z = 3;
var obj = new foo();
3, Object.create(o);
该方法创建了一个以o为原型的空对象;

>>读对象的属性前要判断对象是否存在
var yz, obj = {};
if(obj.y){
	yz = obj.y.z;
}
上面的程序段可以简写如下：
var yz = obj && obj.y && obj.y.z;

>>对象属性的标签
1, 四个静态标签和两个读写的方法:
configurable, writable, enumerable, value;
get, set;
2, Object.defineProperty()
//给对象添加一个属性，并给该属性指定相关标签
var person = {};
Object.defineProperty(person, 'name', {
	enumerable: true,
	value: 'zhao'
});
注：用Object.defineProperty()方法添加属性，默认情况下该属性的标签都为false；
而用对象字面量的方式添加属性，属性的标签默认为true；
3, Object.defineProperties()
//给对象添加多个属性，并指定标签
var person = {};
Object.defineProperties(person, {
	title: {value: 'fe', enumerable: true},
	corp: {value: 'baba', enumerable: true},
	salary: {value: 10000, enumerable: true, writable: true}
});
4, Object.getOwnPropertyDescriptor()
//取对象的某个属性的所有标签，返回结果为一个对象
Object.getOwnPropertyDescriptor(person, 'salary');
//Object{value: 10000, writable: true, enumerable: true, configurable: false}
5, Object.getOwnPropertyDescriptors()
//取对象的所有属性的所有标签，返回结果为一个对象
Object.getOwnPropertyDescriptors(person);
//Object{title: {...}, corp: {...}, salary: {...}}
6, get/set方法
1)通过对象字面量来定义get/set方法
var man = {
	name: 'Bosn',
	_age: null,
	get age(){
		if(this._age == undefined){
			return new Date().getFullYear() - 1988;
		}else{
			return this._age;
		}	
	},
	set age(val){
		if(!isNaN(val) && val > 0 && val < 150){
			this._age = val;
		}else{
			throw new Error('Incorrect val = ' + val);
		}
	}
};
man.age; //32
man.age = 100;
man.age; //100
man.age = 'abc'; //error:Incorrect val = abc
2)通过Object.defineProperties()方法来定义get/set方法
var person = {};
Object.defineProperties(person, {
	title: {value: 'fe', enumerable: true},
	corp: {value: 'baba', enumerable: true},
	salary: {value: 10000, enumerable: true, writable: true},
	luck: {
		get: function(){
			return Math.random() > 0.5 ? 'good' : 'bad';
		}
	},
	promote: {
		set: function(level){
			this.salary *= 1 + level*0.1;
		}
	}
});
person.salary; //10000
person.promote = 2;
person.salary; //12000

>>对象的序列化
1, JSON.stringify(obj)
将对象序列化为字符串
2, JSON.parse(str)
将json字符串解析为对象
2, 可以通过toJSON来定制序列化的过程
var obj = {
	x: 1,
	y: 2,
	o: {
		o1: 1,
		o2: 2,
		toJSON: function(){
			return this.o1 + this.o2;
		}
	}
};
JSON.stringify(obj); //'{"x":1,"y":2,"o":3}'

>>对象转换为基本类型的过程
首先查找对象的valueOf()方法，如果valueOf()方法不存在或者返回对象，
则继续查找toString()方法，如果toString()方法也不存在或者返回对象，
则报错；

>>String对象
1, 常用方法
1)charAt()
指定位置的字符
2)indexOf()/lastIndexOf()
指定的字符第一次出现的位置
var s = 'hello,world';
s.indexOf('o'); //4
s.indexOf('o', 5); //7
s.lastIndexOf('o'); //7
3)substring()
提取指定起止的子字符串
4)substr()
提取指定数目的子字符串
var s = 'hello,world';
s.substring(2, 6); //'llo,'
s.substr(2, 6); //'llo,wo'
5)search()
查找指定子串的位置，不存在则返回-1
'aaa123bbb'.search('123'); //3
'aaa123bbb'.search(/\w\d/); //2
6)replace()
对指定的子串进行替换
'a1b1c1'.replace('1', 'X'); //'aXb1c1'
'a1b1c1'.replace(/1/g, 'X'); //'aXbXcX'
7)split()
字符串分割
var s = 'hello,world';
s.split(','); //['hello', 'world']
s.split(''); //['h', 'e', 'l', 'l', 'o', ',', 'w', 'o', 'r', 'l', 'd']
s.split('', 5); //['h', 'e', 'l', 'l', 'o']
'a1b2c3d4'.split(/\d/); //['a', 'b', 'c', 'd', '']
8)match()
正则匹配
var r = 'a1b2c3d4'.match(/(\w)\d/);
r; //['a1', 'a', index: 0]
var r = 'a1b2c3d4'.match(/(\w)\d/g);
r; //['a1', 'b2', 'c3', 'd4']

>>Math对象
1, 常用方法
1)Math.floor(), Math.ceil(), Math.round();
2)Math.random();
返回介于[0, 1)之间的小数;
注；四舍五入到指定小数点位数用 toFixed();
var a = 3.146;
a.toFixed(2); //3.15

>>Date对象
1, 创建Date对象
new Date(); //当前时间
new Date('October 13, 1975 11:13:00');
new Date(75, 10, 13, 11, 13, 0);
2, 获取与设置
d.getFullYear()/d.setFullYear();
d.getMonth()/d.setMonth(); //月份从0开始计算
d.getDate()/d.setDate();
d.getHours()/d.setHours();
d.getMinutes()/d.setMinutes();
d.getSeconds()/d.setSeconds();
d.getDay(); //星期只有获取，没有设置函数
举例：
d.setDate(d.getDate()+2);
3, 时间戳(单位是毫秒)
d.getTime();
d.setTime();
举例: 
d.setTime(d.getTime()+24*60*60*1000); //将时间设置为一天后

>>数组的创建
1, 数组字面量
var arr = [1, 2, 4];
2, 构造函数
var arr = new Array(1, 2, 4);

>>常用的数组方法
1, Array.isArray()
判断一个对象是否为数组；
注意该方法属于Array构造器的方法，其他方法为Array.prototype的方法；
2，arr.indexOf()，arr.lastIndexOf()
查找元素在数组中的下标，如果不存在则返回-1;
也可以指定查找的起始位置；
3, arr.push()
将元素添加到数组尾部，返回数组的长度
4, arr.pop()
删除数组的最后一个元素，并返回该元素
5，arr.unshift()
将元素添加到数组头部，返回数组的长度
6，arr.shift()
删除数组的第一个元素，并返回该元素
7，arr.join()
将数组元素以指定分隔符连接成字符串，如果不指定分隔符，默认以逗号分隔；
8，arr.reverse()
数组逆序，注意该方法为本地方法，会修改原数组
9，arr.sort()
默认按字符串的顺序来排序，如果需要按数字的顺序或者要排序对象，需要自定义函数来排序；
该方法也是本地方法，会修改原数组；
10，arr.concat()
数组连接, 该方法不会改变原数组
var arr = [1, 2, 3];
arr.concat([10, 11], 13); //[1, 2, 3, 10, 11, 13]
11, arr.slice(start, end)
返回数组片段
12，arr.splice()
数组拼接，返回被删除的元素组成的数组，该方法为本地方法，会修改原数组
var arr = [1, 2, 3, 4];
var b= arr.splice(1, 2, 'a', 'b'); //[1, 'a', 'b', 4]
b; //[2, 3]
13, arr.forEach()
遍历数组
var arr = [1, 2, 3];
arr.forEach(function(x, index, a){
	console.log(x + '|' + index + '|' + (a === arr));
});
//1|0|true
//2|1|true
//3|2|true
14, arr.map()
数组映射，该方法不修改原数组
var arr = [1, 2, 3];
var b= arr.map(function(x){
	return x + 10;
});
b; //[11, 12, 13]
arr; //[1, 2, 3]
15, arr.filter()
数组过滤，该方法不修改原数组
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var b = arr.filter(function(x, index){
	return x % 3 === 0;
});
b; //[3, 6, 9]
arr; //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
16, arr.every()
判断数组中的所有元素满足某个条件
17，arr.some()
判断数组中是否存在元素满足某个条件

>>函数的创建
1，函数声明
function foo(){}
2, 函数表达式
var foo = function(){}
注：函数声明可以提前调用，而函数表达式不可以；

>>函数的调用方式
1，直接调用
foo();
2, 对象方法
o.method();
3, 构造器
new Foo();
4, call/apply/bind
func.call(o);

>>this
一般情况下，this绑定到调用该函数的对象上；

>>js函数作为一般函数调用和作为构造函数的区别
作为一般函数调用时，如果有return返回值则取返回值，没有则是undefined；
作为构造函数时，如果return一个对象，则返回该对象，如果没有return或者return一个基本类型，则按默认返回this处理;
function f1(){
	this.a = 1;
	return 5;
}
f1(); //5
new f1(); //{a: 1}
function f2(){
	this.a = 1;
	return {b: 2};
}
f2(); //{b: 2}
new f2(); //{b: 2}

>>call/apply
call()和apply()可以将函数中的this绑定到指定的对象
function add(c, d){
	return this.a + this.b + c + d;
}
var o = {a: 10, b: 20};
add.call(o, 1, 2); //33
add.apply(o, [1, 2]); //33
注：call()与apply()的作用一样，区别是call()以扁平化的方式传参，而apply()是以数组的方式传参；

>>bind()
1, 将函数中的this绑定到指定的对象, bind()返回的仍然是一个函数
function f(){return this.a;}
var o = {a: 1};
var g = f.bind(o);
g(); //1
2, currying
科里化，将一个函数拆分成不同的单元；
function add(a, b, c){
	return a + b + c;
}
var f1 = add.bind(null, 100);
f1(1, 2); //103
var f2 = f1.bind(null, 1000);
f2(1); //1101

>>闭包
内部函数包含了外部变量的引用，就是闭包。
function outer(){
	var localVar = 30;
	return function(){
		return localVar;
	}
}
var func = outer();
func(); //30
1, 闭包的常见例子：
1)事件点击
(function(){
	var localData = 'localData here';
	document.addEventListener('click', function(){
		console.log(localData);
	});
})();
2)异步请求的回调
(function(){
	var localData = 'localData here';
	$.ajax({
		url: 'test.php',
		success: function(){
			console.log(localData);
		}
	});
})();
2, 闭包的陷阱
以下程序段是应用闭包常见的陷阱：
document.body.innerHTML = '<div id="div1">aaa</div>' + 
	'<div id="div2">bbb</div><div id="div3">ccc</div>';
for(var i = 1; i < 4; i++){
	document.getElementById('div'+i).addEventListener('click', function(){
		alert(i); //all are 4!
	});
}
可改写为:
for(var i = 1; i < 4; i++){
	(function(k){
		document.getElementById('div'+k).addEventListener('click', function(){
			alert(k);
		});
	})(i);
}
3, 闭包的优点
1)永久保存外层函数的变量；
2)实现封装，避免全局对象的污染：
var person = {};
(function(){
	var name = 'zhao';
	var age = 30;
	person.getName = function(){
		return name;
	};
	person.getAge = function(){
		return age;
	};
})();
或者
var person = function(){
	var name = 'zhao';
	var age = 30;
	return {
		getName: function(){
			return name;
		},
		getAge: function(){
			return age;
		}
	};
}();
或者
var person = new function(){
	var name = 'zhao';
	var age = 30;
	this.getName = function(){
		return name;
	};
	this.getAge = function(){
		return age;
	}
};
4, 闭包的缺点
1)空间浪费
2)内存泄漏
3)性能消耗

>>原型
function Foo(){
	this.x = 1;
}
Foo.prototype.y = 2;
new Foo()的初始结构: 
{
	__proto__: Foo.prototype,
	x: 1
}
Foo.prototype的初始结构:
{
	constructor: Foo,
	__proto__: Object.prototype,
	y: 2
}

>>基于原型的继承
function Person(name, age){ 
	this.name = name;
	this.age = age;
}
Person.prototype.say = function(){
	console.log('My name is ' + this.name + ', I am ' + this.age + 
		' years old.');
};
Person.prototype.walk = function(){
	console.log(this.name + ' is walking.');
};
function Student(name, age, major){
	Person.call(this, name, age);
	this.major = major;
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
Student.prototype.say = function(){
	console.log('My name is ' + this.name + ', I am ' + this.age + 
		' years old, I am majoring ' + this.major);
};
Student.prototype.learn = function(){
	console.log(this.name + ' is learning.');
};
这是最经典的组合式原型继承,
通过Person.call(this, name, age)继承基类的构造函数,
通过Student.prototype = Object.create(Person.prototype)继承基类的原型;
Student的原型链如下：
Student.prototype -> Person.prototype -> Object.prototype -> null;

>>BOM
1, window对象
BOM的核心，window对象指当前的浏览器窗口;
常用方法:
1)open()/close()
var win = window.open([url], [窗口名称], [参数字符串]);
url: http://www.baidu.com 或 test.php;
窗口名称: _blank(在新窗口打开, 默认), _self(当前窗口), _top(顶部窗口);
参数字符串: 'width=600,height=300,top=100,left=100,menubar=yes,toolbar=no,scrollbars=yes,status=yes';
window.close(); //关闭本窗口
win.close(); //关闭指定窗口
2)alert()/confirm()/prompt()
警示框、确认框、输入框;
3)print()
打印当前窗口内容
4)focus()/blur()
将焦点移入指定窗口或从指定窗口移开
5)moveBy()/moveTo(), resizeBy()/resizeTo(), scrollBy()/scrollTo()
移动窗口、调整窗口尺寸、滚动窗口内容;
6)setTimeout()/clearTimeout(), setInterval()/clearInterval()
计时器
var i = setInterval(function(){
	//...
}, 1000); //时间间隔的单位为毫秒
clearInterval(i);
2, history对象
记录用户浏览过的页面的历史记录，从窗口打开的那一刻开始记录;
history.length; //浏览器历史列表中的url数量
常用方法:
1)back()
前进到前一个页面，相当于go(-1);
2)forward()
后退到后一个页面，相当于go(1);
3)go(n)
跳转到某个具体的页面;
3, location对象
用于解析窗体的url;
举例: http://www.imooc.com:8080/list.php?courseid=8&chapterid=86#mediaid118
常用属性:
1)href //返回完整的url
2)protocol //协议 http
3)hostname //主机名 www.immoc.com
4)port //端口号 8080
5)host //主机名+端口号 www.imooc.com:8080
6)pathname //路径 list.php
7)search //查询字符串 ?courseid=8&chapterid=96
8)hash //锚 #mediaid118
常用方法:
1)assign()
加载新的文档
2)reload()
重新加载当前文档
3)replace()
用新的文档替换当前文档
4, navigator对象
包含浏览器的相关信息;
常用属性:
1)userAgent //用户代理，客户端发送给服务器的user-agent头部的值
2)appName //浏览器的名称
3)appVersion //浏览器的版本信息
4)appCodeName //浏览器代码名的字符串表示
5)platform //浏览器运行的操作系统信息
5, screen对象
用户的屏幕信息;
常用属性:
1)width/height //屏幕的宽度与高度
2)availWidth/availHeight //屏幕的可用宽度与可用高度
3)colorDepth //颜色位数

>>各种对象的尺寸
1, offsetParent
布局中设置了position属性(relative、absolute、fixed)的父容器，从最近的父节点开始查找，
一直到document.body;
2, 盒子的宽度与高度
box.offsetWidth;
box.offsetHeight;
3, 盒子的左边距和上边距
box.offsetLeft;
box.offsetTop;
4, 盒子滚动条的偏移距离
box.scrollLeft;
box.scrollTop;
5, 窗口显示区域的宽度与高度，不包括滚动条
window.innerWidth;
window.innerHeight;


***********************************************DOM****************************************************
>>DHTML时代，网景和微软的技术分歧很大，浏览器互不兼容，W3C为了统一局面，
开发了DOM，这就是文档对象模型；

>>文档类型
常见的文档类型有HTML和XML，HTML侧重于显示，而XML侧重于保存数据;
文档类型还有由XML扩展出的SVG和MathVG；

>>常用节点的nodeType, nodeName, nodeValue
以简单的HTML文档为例：
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>nodeType, nodeName, nodeValue</title>
</head>
<body>
	<!--This is a comment-->
	<div id="container">This is a text</div>
</body>
</html>
取各常用节点对象：
var divNode = document.getElementById('container');
var attrNode = divNode.attributes[0];
var textNode = divNode.childNodes[0];
var commentNode = document.body.childNodes[1];
var doctypeNode = document.doctype;
var frag = document.createDocumentFragment();
以上常用节点的nodeType, nodeName, nodeValue值总结如下：
1)Element: 1 | DIV | null;
2)Attr: 2 | id | container;
3)Text: 3 | #text | This is a text;
4)Comment: 8 | #comment | This is a comment;
5)Document: 9 | #document | null;
6)DocumentType: 10 | html | null;
7)DocumentFragment: 11 | #document-fragment | null;
注：
1，Document是文档的根节点，它不出现在文档树中，它有两个子节点，即
DocumentType节点和html节点，而html节点是文档树的根元素节点；
2，DocumentFragment不会出现在文档树中，它相当于占位符，当被插入到文档树时，
本身不会被插入，只插入它下面的所有子元素节点，如：
var frag = document.createDocumentFragment();
for(var i = 0; i < 10; i++){
	var li = document.createElement('li');
	li.innerHTML = 'text ' + i;
	frag.appendChild(li);
}
document.getElementById('container').appendChild(frag);

>>DOM常用的属性和方法
1, 常用属性
1)nodeType, nodeName, nodeValue //节点类型、节点名称、节点值
2)attributes //所有属性节点组成的数组
3)parentNode //父节点
4)childNodes //返回子节点的数组
5)firstChild //第一个子节点
6)lastChild //最后一个子节点
7)nextSibling //下一个兄弟节点
8)previousSibling //上一个兄弟节点
2, 常用方法
1)getElementById(), getElementsByName(), getElementsByTagName(), getElementsByClassName()
获取元素节点的方法;
2)getAttribute()/setAttribute()
获取与设置属性的值;
elem.setAttribute('title', 'test'); //等价于elem.title='test';
3)createElement() 
创建一个元素节点
4)createTextNode()
创建一个包含给定文本的文本节点
5)appendChild()
在最后一个子节点之后添加节点
pNode.appendChild(newnode);
6)insertBefore()
在指定的子节点前面插入节点
pNode.insertBefore(newnode, cNode);
7)removeChild()
删除一个指定子节点, 成功则返回被删除的节点，失败则返回null;
pNode.removeChild(cNode);
var rNode = pNode.removeChild(pNode.childNode[1]); //rNode已经脱离节点树，但还在内存中
rNode = null; //彻底删除
8)replaceChild()
替换指定的子节点, 返回被替换节点的引用;
pNode.replaceChild(newnode, cNode);

>>取某个节点下的所有元素节点
var elems = node.getElementsByTagName('*');

>>DOMReady
1, window.onload = function(){
	//...
}
这种方式不仅包含DOMReady，还包含了其他资源的加载，速度最慢；
2, document.addEventListener('DOMContentLoaded', function(){
	//...
});
DOMReady完毕就立即执行，无须等待其他资源的加载，速度最快；
3, $(document).ready(function(){
	//...
});
jquery封装的DOMReady，与第二种方式一样，速度很快；

>>判断节点和文档类型的实现
1, 是否为元素节点
function isElement(elem){
	return !!elem && elem instanceof Node && elem.nodeType == 1;
}
2, 文档是否为HTML
function isHTML(doc){
	return doc.createElement('div').nodeName === 
		doc.createElement('DIV').nodeName;
}
注：在HTML中，元素的nodeName属性返回的元素名都是大写，根据这一点来判断；
属性法容易被攻破，这是通过功能法来判断的；
这个函数需要传入文档节点参数即document来判断；
3, 文档是否为XML
function isXML(doc){
	return doc.createElement('div').nodeName !== 
		doc.createElement('DIV').nodeName;
}
4, 元素是否为HTML的元素
function isHTMLElement(elem){
	if(isElement(elem)){
		return isHTML(elem.ownerDocument);
	}
	return false;
}
注：该方法结合了上面实现的方法，elem.ownerDocument返回当前文档对象，即
elem.ownerDocument === document; //true
5, 元素是否为XML的元素
function isXMLElement(elem){
	if(isElement(elem)){
		return isXML(elem.ownerDocument);
	}
	return false;
}	

>>节点间的包含关系
node1.contains(node2):
var div = document.getElementById('container');
document.contains(div); //true
document.body.contains(div.childNodes[0]); //true
document.doctype.contains(div); //false

>>事件处理
1, 事件冒泡
事件由最具体的元素接收，然后逐级往上传播；
大多浏览器都支持事件冒泡；
2, 添加事件的方式
1)内嵌到HTML元素
<input type="button" id="btn" value="按钮" onclick="showMsg()">
2)DOM0级事件处理程序
var btn = document.getElementById('btn');
btn.onclick = showMsg; //绑定事件
btn.onclick = null; //清空事件
3)DOM2级事件处理程序
btn.addEventListener('click', showMsg, false); //第三个参数默认为false表示冒泡阶段捕获事件
btn.removeEventListener('click', showMsg); //删除绑定的事件
注：通过addEventListener添加的事件，只能通过removeEventListener来删除；
DOM2级事件处理程序的优点是可以为一个事件添加多个事件处理程序;
3, 事件对象
btn.onclick = function(e){
	console.log(e);
};
事件对象的常用属性和方法有
type, target, clientX, clientY, keyCode, stopPropagation(), preventDefault();
4, 常用事件
1)鼠标事件
onclick: 点击某个对象时触发；
ondblclick: 双击某个对象时触发；
onmouseover: 鼠标移入某个元素时触发；
onmouseout: 鼠标移出某个元素时触发；
onmouseenter: 鼠标进入某个元素时触发；
onmouseleave: 鼠标离开某个元素时触发；
onmousedown: 鼠标按下时触发；
onmouseup: 鼠标抬起时触发；
onmousemove: 鼠标移动时触发；
onwheel: 鼠标滚轮滚动时触发；
oncontextmenu: 点击鼠标右键时触发；
2)键盘事件
onkeydown: 键盘的键按下时触发；
onkeyup: 键盘的键放开时触发；
onkeypress: 按字符键时触发；
注：onkeydown触发任意按键，而onkeypress只触发可显示的字符键；
例如捕获回车键，就不能用keypress事件；
3)框架/对象事件
onresize: 浏览器窗口大小改变时触发；
onabort: 图像的加载被中断时触发；
onload: 元素加载完时触发；
onerror: 当加载文档或图片发生错误时触发；
onscroll: 文档滚动时触发；
onpageshow: 用户访问页面时触发；
onunload: 用户退出页面时触发；
4)表单事件
onfocus: 元素获得焦点时触发；
onblur: 元素失去焦点时触发；
onchange: 元素内容改变时触发；
oninput: 元素获取用户输入时触发；
onsubmit: 提交按钮时触发；
onreset: 重置按钮时触发；
onselect: 文本被选中时触发；
5)拖动事件
ondrag: 元素正在拖动时触发；
ondragend: 用户完成元素拖动时触发；
6)多媒体事件
onplay: 在视频/音频播放时触发
onended: 在视频/音频播放结束时触发
onpause: 在视频/音频暂停时触发


>>XMLHttpRequest原生实现ajax
var xhr = new XMLHttpRequest();
//GET请求
xhr.open('GET', 'test.php?username=zhao', true); //第三个参数默认为true表示异步请求
xhr.send();
//POST请求
xhr.open('POST', 'test.php');
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('name=zhao&age=30');
//处理响应
xhr.onreadystatechange = function(){
	if(xhr.readyState == 4 && xhr.status == 200){
		//xhr.getResponseHeader(); 取得某个响应头信息
		//xhr.getAllResponseHeaders(); 取得所有响应头信息
		//xhr.responseText
	}
};
注：原生方式实现ajax，用post请求发送表单数据时，必须用setRequestHeader()方法来设置请求头，不然会报错；
而用jquery方式时，就不用设置；

>>readyState属性的取值
0：open还没有调用，请求未初始化；
1：open已经调用，服务器连接已建立；
2：请求已接收，也就是接收到头信息了；
3：请求处理中，也就是接收到响应主体了；
4：请求完成，响应就绪；

>>jquery实现ajax
1, ajax()
$.ajax({
	url: 'test.php',
	type: 'post',
	data: {
		name: 'zhao',
		age: 30
	},
	dataType: 'json',
	success: function(result, status, xhr){
		//...
	},
	error: function(xhr, status, error){
		//...
	}
});
2, get()
$.get('test.php?name=zhao', function(data){
	//...
});
3, post()
$.post('test.php', {
	name: 'zhao',
	age: 30
}, function(data){
	//...
});


***************************************jQuery****************************************
>>jquery对象与DOM对象的转换
1, DOM对象转换为jquery对象
var div = document.getElementById('container');
var jdiv = $(div);
2, jquery对象转换为DOM对象
var jdiv = $('div');
var div = jdiv[0]; //通过数组下标
var div = jdiv.get(0); //通过get()方法
注：通过下标[0]或者.get(0)获取的是DOM元素，而通过.first()获得仍然是jquery对象;

>>jquery选择器
1, 基本选择器
$('p')  //元素选择器
$('#container')  //id选择器
$('.container')  //类选择器 
$('div, p')  //组合选择器
$('*')  //通用选择器
注: js中获取所有节点集合：document.getElementsByTagName('*');
2, 层级选择器
$('div>p') //直接子元素p
$('div p') //所有后代p
$('div+p') //紧跟其后的第一个兄弟p
$('div~p') //后面的所有兄弟p
3, 属性选择器
$('[attribute']) //具有指定属性
$('[attribute1][attribute2]') //具有多个指定属性
$('[attribute="value"]') //属性等于指定值
$('[attribute!="value"]') //属性不等于指定值
$('[attribute^="value"]') //属性值以value开头
$('[attribute$="value"]') //属性值以value结尾
$('[attribute*="value"]') //属性值包含value串
$('[attribute~="value"]') //属性值包含value单词
4, 位置选择器
$('div:first') //第一个
$('div:last') //最后一个
$('div:eq(index)') //= index
$('div:gt(index)') //> index
$('div:lt(index)') //< index
$('div:even') //偶数(下标从0开始)
$('div:odd') //奇数
$(':first-child') //是第一个子元素
$(':last-child') //是最后一个子元素
$(':only-child') //是唯一的子元素
$(':nth-child(n)') //是第n个子元素，n从1开始，这与':eq(index)'不同
$(':nth-last-child(n)') //是倒数第n个子元素
5, 表单选择器
$(':input') //匹配所有input, textarea, select和button元素, 注意与$('input')的区别
$(':text') //文本框，等价于'[type="text"]', 下同
$(':password') //密码框
$(':radio') //单选框
$(':checkbox') //复选框
$(':submit') //提交按钮
$(':reset') //重置按钮
$(':button') //所有按钮
$(':image') //图像域
$(':file') //文件域
$(':enabled') //可用的表单元素
$(':disabled') //不可用的表单元素
$(':checked') //选中的单选或复选框
$(':selected') //选中的下拉列表项
6, 其他选择器
$('div:not(selector)') //否定
$(':root') //文档的根元素
$(':animated') //正在执行动画的
$(':parent') //含有子元素或文本的元素
$(':empty') //与':parent'相反
$(':contains(text)') //包含指定文本的元素
$(':has(selector)') //包含指定选择器的元素
$(':visible') //显示的元素
$(':hidden') //隐藏的元素(1,display: none; 2,type="hidden"的表单元素; 3,width和height设为0)
$(this) //把js的上下文对象this封装成jquery对象

>>属性
1, attr('name') //获取属性值
2, attr('name', 'value') //设置属性值
3, prop('name') //获取属性值
4, prop('name', 'value') //设置属性值
5, removeAttr('name') //移除属性

>>文本与值
1, html() //获取第一个元素的html内容
2, html('value') //设置所有匹配元素的html内容
3, html(function(index, value){}); //通过函数返回值设置匹配元素的html内容
4, text() //获取所有元素的合并文本
5, text('value') //设置所有匹配元素的text内容
6, text(function(index, value){}); //通过函数返回值设置匹配元素的text内容
7, val() //获取第一个表单元素的值
8, val('value') //设置所有匹配表单元素的值
9, val(function(index, value){}); //通过函数返回值设置匹配表单元素的值
注: val()只能用在表单元素，而html()和text()不能用于表单元素;
html()和val()只能获取匹配集合中第一个元素的值，而text()获取匹配集合所有元素的值;

>>类
1, addClass('name') //元素添加一个或多个类
2, addClass(function(index, curClass){}) //通过函数返回值给元素添加类
3, removeClass('name') //元素删除一个或多个类，参数为空则删除所有类
4, removeClass(function(index, curClass){}) //通过函数返回值删除元素的类
5, toggleClass('name') //切换类名，有则删除，没有则添加
6, toggleClass(function(index, curClass){}) //通过函数返回值切换类

>>样式
1, 获取
css('color') //获取单个样式属性的值
css(['font-size', 'backgroundColor']) //获取多个样式属性值，传递数组，返回对象
2, 设置
css('font-size', '20px') //设置单个样式属性值
css('width', function(index, value){
	return parseInt(value) + 50 + 'px';
}); //通过函数返回值设置样式属性
css({
	'font-size': '20px',
	'backgroundColor': gray,
	'border': '1px solid red'
});	//通过对象设置多个样式属性
注: css()方法支持驼峰写法与大小写混搭的写法，而js的style只支持驼峰写法;
css('width', 50) 与 css('width', '50px') 的效果一样;

>>存储数据
1, 通过H5提供的data-前缀属性
<ul>
	<li data-animal-type="鸟类">喜鹊</li>
	<li data-animal-type="鱼类">金枪鱼</li>
	<li data-animal-type="蜘蛛">蝇虎</li>
</ul>
可以通过js动态修改，也支持CSS选择器进行样式设置;
2, 通过jquery的data()方法
data(key, value) //存数据
data(key) //取数据
removeData(key) //删除数据
存数据是把数据绑定到内部的DOM对象上;

>>add()
给jquery合集对象中增加新的元素，参数可以是字符串、DOM对象以及jquery对象;
$('li').add('<p></p>');
$('li').add(document.createElement('p'));
$('li').add($('<p></p>'));

>>创建节点
$('<div class="item">我是一段文本</div>');

>>插入节点
1, a.append(b) === b.appendTo(a) //在a的内部后面追加b
可以接受HTML字符串、DOM元素、或者jquery对象, 也可以接受多个参数;
$('.content').append(s);
$('.content').append(elem);
$('.content').append($(s));
$('.content').append(s1, s2);
2, a.prepend(b) === b.prependTo(a) //在a的内部前面添加b
3, a.before(b) === b.insertBefore(a) //在a的外部前面添加b
4, a.after(b) === b.insertAfter(a) //在a的外部后面添加b
注: $('li').appendTo('div')会将页面上的li元素移动到div里面，如果要复制，可以用
$('li').clone().appendTo('div');

>>删除节点
1, empty() //清空，仅移除子元素
$('.test').empty()
2, remove() //移除，自身及后代全部删除，包括绑定的事件
此方法可接受一个选择器参数，表示仅删除匹配的元素
$('p').remove();
$('p').remove(':contains("3")');
$('p:contains("3")').remove(); //等价
$('p').filter(':contains("3")').remove() //等价
3, detach() //删除, 参数同remove()
与remove()不同，通过detach()删除的元素，上面绑定的数据和事件还在;
var p = $('p').detach();
$('body').append(p); 

>>节点的复制、替换、包裹
1, clone() //只克隆结构，事件和绑定的数据丢失
clone(true) //结构、事件与数据都克隆
2, a.replaceWith(b) == b.replaceAll(a)
参数可以是字符串、DOM节点或者是jquery对象;
返回被替换掉的jquery对象;
3, wrap() //将匹配元素用指定参数包裹起来, 返回包裹之前的原始jquery对象
$('p').wrap('<div></div>')
4, unwrap() //删除匹配元素的父级

>>遍历
1, children() //返回子元素的集合
children(selector) //返回符合指定选择器的子元素的集合
2, find(selector) //查找符合条件的后代的集合
find()必须传入参数，如果要查找所有后代，则使用 find('*');
3, parent() //父元素
4, parents() //所有祖先集
parents(selector) //满足条件的祖先集
5, closest(selector) //从自身开始往上查找，找到第一个匹配的祖先元素
parents(selector)与closest(selector)的区别:
前者从父元素开始查找，返回所有满足条件的祖先元素;
后者从自身开始查找，返回第一个满足条件的祖先元素;
6, next() //下一个兄弟元素
7, prev() //上一个兄弟元素
8, siblings() //所有兄弟元素
9, filter() //过滤
filter(selector)是从自身的合集中进行筛选;
find(selector)是从后代中进行筛选;
10, index() //索引
返回参数对象在jquery合集对象中的索引，没有则返回-1;
参数可以为空，则表示jquery合集对象在同辈中的位置;
参数也可以为DOM元素或者jquery对象，则表示参数对象在jquery合集对象中的索引;
<ul>
	<a>a link</a>
	<li id="test1">1</li>
	<li id="test2">2</li>
	<li id="test3">3</li>
</ul>
$('li').index(); //1
$('li').index(document.getElementById('test3')); //2
$('li').index($('#test3')); //2
注: 因为jquery对象是个合集，所以有些方法虽然看上去不需要参数，如
parent(), next(), prev()等，但也可以传入参数对合集对象进行筛选，如
parent(':last'), next(':contains("text")')等;

>>鼠标事件
1, click 与 dblclick
$('button').click(); //不带参数, 用程序触发按钮单击
$('div').click(function(e){ //带参数，回调函数定义事件响应
	//...
});
2, mousedown 与 mouseup
$('div').mouseup(function(e){
	alert(e.which); 
});
e.which表明是哪个鼠标键的动作，1--左键，2--中键，3--右键;
3, mousemove
//鼠标移动
4, mouseover 与 mouseout
//鼠标移入移出, 这两个事件会冒泡给祖先元素
5, mouseenter 与 mouseleave
//鼠标移入移出，这两个事件不会冒泡给祖先元素
6, hover
接收两个回调函数作为参数，相当于同时定义了mouseenter与mouseleave两个事件;
$('div').hover(mouseenterFn, mouseleaveFn);
7, focusin 与 focusout
//元素或元素内的子元素获得和失去焦点的事件
如输入框获得焦点时改变其父div的背景颜色
<div>
	<label>username: <input type="text"></label>
</div>
$('div').focusin(function(){
	$(this).css('background-color', 'yellow');
}).focusout(function(){
	$(this).css('background-color', '#fff');
});

>>表单事件
1, focus 与 blur
//表单框获得与失去焦点事件
注: focus与focusin的区别
focus只在元素本身产生，不会冒泡到父元素，而focusin会冒泡到父元素；
blur与focusout也是一样。
<div>
	<label>username: <input type="text"></label>
</div>
$('div').focusin(function(){ //有效
	alert('focusin事件冒泡到父元素div');
});
$('div').focus(function(){ //无效
	alert('focus事件不会冒泡到父元素div');
});
2, change
//表单控件值的改变
<input>文本输入框和<textarea>值的改变，当失去焦点后触发change事件;
单选按钮、复选框和下拉选择框，当用鼠标做出选择时，立即触发change事件;
$('input').change(function(e){
	$('#result').html(e.target.value);
});
3, select
//表单框中的文本选中事件
4, submit
//提交事件 
可以在表单提交之前进行一些验证，可通过 e.preventDefault() 或 return false 
来阻止浏览器的默认提交行为;

>>键盘事件
1, keydown 与 keyup
//键盘的按下与松开事件
$('input').keyup(function(e){
	alert(e.keyCode);
});
2, keypress
//键盘点击事件
注: keydown/keyup能捕获所有按键，而keypress只能捕获可打印的按键;
输入当前按键值只能通过keyup实现;

>>事件绑定与解绑
1, on()
//绑定事件
可以传入参数，参数会自动作为事件对象的data属性，即 e.data
$('div').on('click', callback);
$('div').on('click', 6, function(e){
	alert(e.data); //6
});
$('div').on('click', {name: 'zhao'}, function(e){
	alert(e.data.name); //'zhao'
});
2, off()
//事件解绑
$('div').off('click'); //删除click事件
$('div').off(); //删除所有事件
3, 事件委托
把事件绑定到祖先元素上，对下面的子元素进行事件委托;
<div>
	<button>btn</button>
</div>
$(document).on('click', 'div', function(e){
	alert('click');
});
当在button上点击时，事件通过冒泡到达div时才处理;
事件委托的好处：
1)通过祖先给下面满足选择器条件的元素统一绑定事件;
2)当添加新的元素，无须为其重新绑定事件，只要满足委托条件，事件自动生效;

>>事件对象
1, e.type //事件类型
2, e.target //事件触发的原始DOM对象
3. e.currentTarget //事件冒泡时的当前DOM对象，等于this
4, e.pageX/e.pageY //鼠标在当前页面的坐标，不随滚动条变化
5, e.clientX/e.clientY //鼠标相对视口的坐标
6, e.which //鼠标事件则表示哪个鼠标键，键盘事件则代表keyCode
7, e.keyCode //键盘按键码
8, e.preventDefault() //阻止浏览器的默认行为
9, e.stopPropagation() //阻止事件冒泡
注: target 与 currentTarget 的区别：
target是触发事件的原始DOM对象，不会变化;
而currenTarget是冒泡过程中的当前DOM对象，是会变化的，等同于this;

>>trigger() 与 triggerHandler()
触发事件可以由用户交互触发，也可以由程序触发，就是用这两个函数;
两者的区别：
1)trigger()会引起事件的默认行为，而triggerHandler()不会;
2)trigger()会触发匹配的所有元素，而triggerHandler()只触发第一个元素;
3)trigger()触发的事件会冒泡，而triggerHandler()不会冒泡;
//html
<div>
	<button>btn1</button>
	<button>btn2</button>
</div>
<input type="button" value="trigger">
<input type="button" value="triggerHandler">
//绑定事件与触发事件
$('div').click(function(e){
	alert('div click');
});
$('button').click(function(e){
	alert(e.target.innerHTML + ' click');
});
$('input:first').click(function(e){ //演示trigger触发
	$('button').trigger('click');
});
$('input:last').click(function(e){ //演示triggerHandler触发
	$('button').triggerHandler('click'); 
});

>>自定义事件
可以通过on绑定自定义事件，然后通过trigger()调用;
$('div').on('myFn', function(){
	alert('This is a customize event.');
});
$('div').trigger('myFn'); //触发自定义事件
自定义事件还可以传递参数;
$('div').on('myFn', function(event, param1, param2){
	alert(param1 + param2);
});
$('div').trigger('myFn', [1, 2]);

>>显示与隐藏
1, show(speed, callback) 
显示，speed可为 slow / fast / 毫秒, callback 为动画执行结束会调用的函数;
show(); //直接显示
show('slow'); //渐显
show(1000, function(){
	alert('渐显完成');
});

2, hide(speed, callback)
隐藏，参数同show();
show()与hide()方法通过同时改变元素的宽度、高度和透明度来实现动画；
3, toggle(speed, callback)
自动在show()与hide()之间进行切换;

>>滑动
1, slideUp(speed, callback)
上滑，参数同show();
slideUp()与slideDown()方法是通过仅改变元素的高度来实现动画;
2, slideDown(speed, callback)
下滑，参数同slideUp();
3, slideToggle(speed, callback)
上滑与下滑自动切换;

>>淡入淡出
1, fadeOut(speed, callback)
淡出, 参数同show()
fadeOut()与fadeIn()方法是通过仅改变元素的透明度来实现动画;
当透明度变为0时，元素从页面的布局中消失;
2, fadeIn(speed, callback)
淡入, 参数同fadeOut()
3, fadeToggle(speed, callback)
淡入淡出自动切换;
4, fadeTo(speed, opacity, [callback])
淡入淡出到指定透明度，前两个参数必须，第三个回调函数可选;
fadeOut()是将opacity从0变到1，fadeIn()是将透明度从1变到0;

>>自定义动画
1, animate(styles, [duration, easing, callback])
第一个参数属性组是必须的，后面的三个参数可选;
duration-动画的持续时间;
easing-动画的速度函数;
callback-动画完成后的回调函数;
属性组里的属性值必须是带有数字的，才能运用动画效果;
属性组里的属性值可以取下面这些值:
500, '500px', '+=100px', 'show/hide/toggle';
$('div').animate({
	left: 50,
	width: '50px',
	opacity: 'show',
	fontSize: '10em',
}, 500);
$('div').animate({
	left: '+=50px'
}, 'slow');
2, animate(styles, [options])
把更多可选的参数放到对象中，可以对动画的更多选项进行控制;
3, stop(stopAll, goToEnd)
当一个元素上添加了多个动画，即动画队列;
stopAll与goToEnd默认都为false;
$('div').animate({height: 300}, 5000);
$('div').animate({width: 300}, 5000);
$('div').animate({opacity: 0.3}, 5000);
$('div').stop(); //只会停止第一个动画，第二个第三个继续
$('div').stop(true); //停止第一个、第二个和第三个动画
$('div').stop(true, true); //停止动画，直接跳到第一个动画的最终状态

>>ajax方法
1, load()
load(url, [data], [callback]);
对象方法，给对象加载内容
$('div').load('test.txt', function(response, status, xhr){
	//加载完成后执行的回调函数
	//response: 加载的内容
	//status: 请求的状态，如success或error
	//xhr: XMLHttpRequest
});
2, $.getJSON()
$.getJSON(url, [data], [callback]);
加载JSON文件，返回json对象, 如
$.getJSON('test.json', function(data, status, xhr){
	$.each(data, function(index, field){
		//通过$.each遍历返回的data对象
	};
});
3, $.getScript()
$.getScript(url, [callback]);
加载并执行指定url的js代码，完成后执行callback回调，如
$.getScript('test.js', function(){
	//todo
});
4, $.get()
$.get(url, [data], [callback], [dataType]);
使用GET方法请求服务器中的php文件，在回调函数中处理返回的结果;
dataType可为text、xml、html、script、json、jsonp等;
$.get('test.php', function(data){
	//一般data返回的是json串，除非指定dataType为'json'
});
5, $.post()
$.post(url, [data], [callback], [dataType]);
使用POST方法请求服务器中的php文件，在回调函数中处理返回的结果;
$.post('test.php', {name: 'zhao', age: 30}, function(data){
	//data = JSON.parse(data);
});
6, $.ajax()
最强大的ajax方法，其他ajax方法都使用这个方法, 常见的配置参数:
$.ajax({
	url: 'test.php',
	type: 'post',
	data: {name: 'zhao', age: 30},
	dataType: 'json',
	success: function(data, status, xhr){
		//请求成功时的回调
	}, 
	error: function(xhr, status, error){
		//请求失败时的回调
	}
});
7, $.ajaxSetup()
配置ajax请求的默认选项, 后面的ajax请求对应的选项如果没设置则采用这个默认值;
$.ajaxSetup({
	dataType: 'json',
	success: function(data){
		//process data
	}
});
$('btn1').click(function(){
	$.ajax({url: 'test1.php'});
});
$('btn2').click(function(){
	$.ajax({url: 'test2.php'});
});
8, ajaxStart(), ajaxStop()
用于在ajax请求之前和之后调用;
$(document).ajaxStart(function(){
	$('#wait').show();
});
$(document).ajaxStop(function(){
	$('#wait').hide();
});

>>常用的jquery工具类函数
1, each()
1)作为对象方法, 遍历jquery合集对象
$('li').each(function(index, element){
	if(index % 2 == 0){
		$(this).css('color', 'red');
	}
});
2)作为类方法, 用来统一处理数组和对象
$.each(array, function(index, element){});
$.each(object, function(index, element){});
如果回调函数返回false, 则结束遍历;
$.each([1, 3, 5, 7, 9], function(index, elem){
	if(elem > 5) return false;
	console.log(elem);
}); //1 3 5
2, $.extend()
1)合并对象;
$.extend([deep], target, [object1], [object2]);
$.extend(v1, v2); //合并v2和v1，合并后的值保存到v1
$.extend(true, v1, v2); //深复制
var v = $.extend({}, v1, v2); //合并v2和v1, 返回合并后的对象, 不改变v1和v2
举例如下
var v1 = {
	apple: 0,
	banana: {weight: 52, price: 100},
	cherry: 97
};
var v2 = {
	banana: {price: 200},
	orange: 100 
};
$.extend(v1, v2); 
v1; //{apple: 0, banana: {price: 200}, cherry: 97, orange: 100}
$.extend(true, v1, v2);
v1; //{apple: 0, banana: {weight: 52, price: 200}, cherry: 97, orange: 100}
var v = $.extend({}, v1, v2);
v; //浅复制的合并
2)给全局jquery添加新方法;
如果仅接受一个参数，则意味着target被省略，此时target就是jquery本身，
可以通过这个方法为jquery添加新的方法;
(function($){
	$.extend({
		maxNum: function(v1, v2){
			return v1 > v2 ? v1 : v2;
		}
	})
)(jQuery);
$.maxNum(2, 5); //5
3, $.fn.extend()
$.fn是jquery的原型对象, $.prototype === $.fn;
该方法为jquery的原型添加新的属性和方法，这些方法可在jquery实例对象上调用;
(function($){
	$.fn.extend({
		fn: function(){
			//...
		},
		gn: function(params){
			//...
		}
	})
)(jQuery);
$('div').fn();
f('div').gn(value);
4, $.param()
序列化数组或对象;
var v = {name: 'zhao', age: 30, city: 'hefei'};
$.param(v); //name=zhao&age=30&city=hefei
5, serialize()
序列化表单;
$('form').serialize(); //username=zhao&age=30
注: serialize()用于表单的序列化，而param()用于对象和数组;
serialize()可将表单序列化为字符串传递到后台处理：
$.post('test.php', $(this).serialize(), function(data){});
6, serializeArray()
序列化表单，结果保存为数组;
$('form').serializeArray(); //[{name: 'username', value: 'zhao'},{name: 'age', value: 30}]
通过serializeArray()方法得到的数组需要经过处理，才能传递到后台;
举例:
//html
<form id="myform">
	用户名: <input type="text" name="username"><br>
	密码: <input type="password" name="password"><br>
	性别: <input type="radio" name="gender" value="1">男
		<input type="radio" name="gender" value="2">女<br>
</form>
<button id="btn">格式化表单数据</button>
//js
$('#btn').click(function(){
	var arr = $('#myform').serializeArray();
	var datas = [];
	arr.forEach(function(item){
		datas[item.name] = item.value;
	});
	$.post('test.php', datas, function(data){});
});
注: 上面的处理大可不必，可直接采用如下形式:
$.post('test.php', $(this).serialize(), function(data){});


