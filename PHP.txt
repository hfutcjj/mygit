>>三个环境
开发环境(dev)
测试环境(test)
生产环境(prod)

>>PHP语言的特点
服务器端语言；脚本语言；跨平台；免费；

>>转换成布尔值为false的几种情形
0, 0.0, '0', '', false, [] -> false 
这些值用empty()得到的结果都为true;

>>常量
1, 常量的定义
define('PI', 3.14);
const PI = 3.14;
注: define()定义的常量是全局的，不受命名空间影响; 而const定义的常量是在当前的命名空间下;
2, 判断常量是否已定义
defined('PI'); //true or false
3, 常量的分类
1)系统常量
__FILE__, __LINE__, __DIR__, __FUNCTION__, __CLASS__, __TRAIT__, 
__METHOD__, __NAMESPACE__,
PHP_VERSION, PHP_OS;
2)用户自定义常量

>>字符串
1, 单引号与双引号
单引号将里面的变量原样输出，而双引号会解析里面的变量;
单引号只解析\\与\'两个转义符，而双引号能解析所有转义符;
2, 可以用{}来明确变量的界限，将变量扩成一个整体来解析;
$name = 'zhao';
echo "my name is {$name}s";
3, php中的字符串是可改变的;
可以通过数组下标的形式对字符串进行本地的增删改查;
$name = 'zhao';
$name[1] = '*';
$name; //'z*ao'
4, 其他类型转换成字符串
1)隐式转换
echo输出任何类型，都会转换成字符串;
true->1, false->''; 
null->'';
resource->Resource id#数字;
数组->'Array', 同时报警告;
对象->致命错误, 需要用魔术方法__tostring()来将对象转换成字符串;
2)显式转换
临时转换，不改变原变量的类型:
$b = (string)$a;
$b = strval($a);
永久转换，改变变量本身的类型:
settype($a, 'string');
5, 字符串转换成其他类型
(int)'3.2abc'->3.2, (float)'3.2abc'->3.2;
(bool)''->false, (bool)'0'->false, (bool)' '->true;
6, 字符串函数
1)判断是否是字符串
is_string('hello'); //true
2)字符串的长度
strlen('hello'); //5
strlen('中国人'); //9, 以字节为单位
mb_strlen('中国人'); //3, 以字符为单位
3)字符与对应的ascii码的相互转换
ord($c); //字符->ascii码
chr($n); //ascii码->字符
4)字符串截取
substr('abcdef', 1, 3); //'bcd'
substr('abcdef', 1); //'bcdef'
substr('abcdef', -1, 1); //'f'
substr('我是中国人', 6, 9); //'中国人', 按字节截取
mb_substr('我是中国人', 2, 3); //'中国人', 按字符截取
5)字符串查找
strpos()返回第一次出现的索引，没找到则返回false, 可选的参数表示查找的位置;
strrpos()从右边开始查找;
strpos('hello,world', 'o'); //4
strpos('hello,world', 'o', 5); //7
strpos('hello,world', '*'); //false
strrpos('hello,world', 'o'); //7
6)字符串比较
比较两个字符串的大小，小返回<0，相等返回0，大于则返回>0;
strcmp('aa', 'bb');  //-1
7)去掉首尾的空格
trim(' *^hello^^*  '); //'*^hello^^*'
trim('*^hello^^*', '*^'); //'hello'
ltrim(' hello '); //'hello '
rtrim(' hello '); //' hello'
8)大小写转换
strtolower('Hello'); //'hello'
strtoupper('Hello'); //'HELLO'
ucfirst('hello,world'); //'Hello,world', 首字母大写
9)将字符串分割成数组
explode('|', 'one|two|three|four'); //['one', 'two', 'three', 'four']
explode('|', 'one|two|three|four', 2); //['one', 'two|three|four']
10)字符串替换
str_replace('o', '*', 'hello world'); //'hell* w*rld'
str_replace('\\', '/', dirname(__FILE__)); //'D:/web/www'
11)子串出现的次数
substr_count('This is a test', 'is'); //2
12)重复字符串
str_repeat('hi', 3); //'hihihi'
13)反转字符串
按字节反转，只能用于英文字符串;
strrev('hello'); //'olleh'
14)过滤html标记
去掉字符串中的html标记, 可选的第二个参数表示需保留的标记
$s = '<div><span>hello</span> <a href="#">baidu</a></div>';
strip_tags($s); //'hello baidu'
strip_tags($s, '<a>'); //'hello <a href="#">baidu'
strip_tags($s, '<span><a>'); //'<span>hello</span> <a href="#">baidu</a>'
15)随机打乱一个字符串
str_shuffle('hello'); //'leolh'
15)按指定的长度分割字符串，默认为1
str_split('hello'); //['h', 'e', 'l', 'l', 'o']
str_split('hello', 3); //['hel', 'lo']
str_split('我是中国人', 3); //['我', '是', '中', '国', '人']

>>日期与时间
1，获取与设置时区
默认时区是UTC, 获取时区有两种方法: 
1)ini_get('date.timezone');
2)date_default_timezone_get();
设置时区有三种方法：
1)修改PHP的配置文件，将date.timezone修改为中国的时区
Asia/Shanghai或PRC；
2)通过ini_set()函数设置
ini_set('date.timezone', 'PRC'); 或
ini_set('date.timezone', 'Asia/Shanghai');
3)通过date_default_timezone_set()函数设置
date_default_timezone_set('PRC'); 或
date_default_timezone_set('Asia/Shanghai');
注：设置时区的第一种方法对所有脚本都有效，后两种方法只对当前脚本有效；
ini_get()与ini_set()还可以设置PHP的其他配置选项；
2, date(string $format, int $timestamp)
获取格式化的本地时间，第二个参数可省略，默认为当前时间;
date('Y-m-d H:i:s'); //当前时间
date('Y-m-d H:i:s', time()+24*3600); //一天后的时间
3, time()
返回当前的时间戳, 单位为秒;
4, microtime(bool $flag=false)
返回微秒级的时间戳，默认返回'microsec sec'格式的字符串，
参数为true则返回小数格式;
5, 转换成指定时间的时间戳
1)mktime(hour, minute, second, month, day, year)
获取指定时间的时间戳，参数可从后往前依次省略，默认为当前时间单位;
mktime(0, 0, 0, 6, 1, 1990); //1990年6月1日零点的时间戳
2)strtotime(string $str)
常用参数有 'now', '+2 years 3 months 1 day'等;
6, checkdate(month, day, year)
检验指定的日期是否有效;
注：php时间戳与js时间戳的区别:
php通过 time() 返回的时间戳单位为秒;
而js通过 new Date().getTime() 返回的时间戳单位为毫秒;

>>函数
1, 函数的分类
1)系统函数: 字符串、数学、数组、日期时间....
2)用户自定义函数;
2, 函数名
php的函数名默认是不区分大小写的，自定义的函数名最好是动词开头，如getExt, uploadFile等;
php不支持函数重载，如果两个函数名相同，则报重复定义错误;
可以在定义函数前判断函数是否存在，使用function_exists()，
if(!function_exists('myFn')){
	function myFn(){
		//...
	}
}
3, 返回值
php的函数只能有0或1个返回值，如果要返回多个值，可以返回数组或对象;
php的函数可以返回任意类型的值, 如果没有明确的返回值，则默认返回null;
4, 函数注释
php常用的函数注释:
/*
 *按照需求创建指定的表格
 *@param number $rows
 *@param number $cols
 *@return string
 */
 function createTable($rows, $cols){
	//...
 }
5, 变量作用域
1)局部变量
函数内定义的变量就是局部变量，局部变量又分为动态变量和静态变量;
动态变量在函数执行完就立即释放，而静态变量则保存到静态内存中;
function test(){
	static $a = 0;
	echo $a++;
}
test(); //0
test(); //1
test(); //2
2)全局变量
函数内默认不能使用外部定义的全局变量，可按下面这样使用
$g_name = 'Lily';
function test(){
	//方法一: global $g_name;
	//方法二: $GLOBALS['g_name'];
}
6, 强类型参数
为参数列表中的参数指定类型，如果传入的实参类型不匹配，将会抛出TypeError异常；
支持的类型：
bool, float, int, string, array, callable, class name, interface name;
7, 可变数量参数
实现方法1：
func_num_args();  //传入的参数个数
func_get_arg(i);  //传入的第i个参数
func_get_args();  //传入的参数组成的数组
实现方法2：
function fn(...$a){
	//$a是传入的参数组成的数组
}	
8, 值传递和引用传递
PHP默认都是按值传递, 而JS中的数组和对象都是按引用传递的;
function test(array $a){
	$a[1] = 888;
}
$arr = [1, 2, 3];
test($arr);
print_r($arr);  //[1, 2, 3]
如果需要改变参数本身，则改为按引用传递:
function test(array &$a){
	//...
}
9, 可变函数
变量名后有圆括号，PHP将寻找与变量值相同的函数名，并且调用它；
function get_apple(){
	return 'apple';
}
function get_orange(){
	return 'orange';
}
function get_fruit($fruit){	//工厂模式
	$fname = 'get_'.$fruit;
	return $fname();
}
10, 回调函数
回调函数就是调用函数的时候将另外一个函数的名称当做参数传递进去，
并且在函数体中进行调用;
1)系统函数应用回调函数的例子
$a = array(1, 2, 3, 4);
function test($x){return $x*2;}
$b = array_map('test', $a);
$b; //[2, 4, 6, 8]
或者直接用匿名函数的形式来回调，与js的形式一样,
$b = array_map(function($i){
	return $i*2;
}, $a);
2)用户自定义函数应用回调函数的例子
function study($name){echo $name.' is studying';}
function play($name){echo $name.' is playing';}
function doWhat($funcName, $name){
	$funcName($name);
}
11, 文件包含
1)require, require_once
//require 'common.php'
//require('common.php')
用require包含文件，如果文件不存在，则报致命错误，程序终止执行;
require_once只包含一次，可防止重复定义;
2)include, include_once
用include包含文件，如果文件不存在，只报警告，程序继续执行;

>>类与对象
1, 继承, 访问控制, static关键字
继承一个类用extends关键字;
可用$this访问自身的非静态属性和非静态方法, 如 $this->name, $this->getAge();
可用self, static访问自身的静态属性, 如 self::$nation, static::$nation;
在类外访问静态属性只能用类名，如 Person::$nation;
静态方法只能访问静态属性;
可用parent访问父类的方法, 如 parent::__construct(), parent::info();
class Person{ //父类
	public $name;
	private $age;
	public static $nation = 'China'; //静态属性
	public function __construct($name, $age){
		$this->name = $name;
		$this->age = $age;
	}
	public function getAge(){
		return $this->age;
	}
	public function info(){
		echo 'My name is '.$this->name.'. I am '.$this->age.' years old.';
	}
	public static function changeNation($nation){ //静态方法
		self::$nation = $nation;
	}
}
class Student extends Person{ //子类
	public $major;
	public function __construct($name, $age, $major){
		parent::__construct($name, $age); //调用父类构造函数
		$this->major = $major;
	}
	public function info(){
		echo 'My name is '.$this->name.'. I am '.$this->getAge().' years old.'.
			' I am majoring in '.$this->major;
	}
}
注: php只支持单继承，不支持多继承;
2, 对象的比较
当两个对象的所有属性都相等时, ==返回true;
而当两个变量是同一个对象的引用时, ===才返回true;
3, 对象的序列化
对象的序列化一般用json_encode(), 转换为易读的json串;
而serialize()方法将对象转换为一个难读的字符串;
4, 对象的销毁
当没有任何引用指向对象时，对象就会销毁, 或者程序运行结束，对象自动销毁；
注意以下两种方式的区别:
1)$p1 = new Person('zhao', 30);
$p2 = $p1; 
$p1 = null; //此时对象不会销毁，因为还有$p2指向对象
2)$p1 = new Person('zhao', 30);
$p2 = &$p1;
$p1 = null; //此时对象销毁，$p2是$p1的别名
5, final关键字
final修饰类名表示该类不能被继承, 如 final class Person{};
final修饰方法表示该方法不能被重写，如 final public function getAge(){};
6, 接口
接口用interface定义, 接口只包含方法的的声明，接口不能实例化对象;
类实现接口用implements，类要实现接口中定义的方法;
接口之间也可以用extends继承;
判断某个对象是否属于某个类或接口，可以用instanceof, 如 $obj instanceof ICanEat, $obj instanceof Human;
interface ICanEat{ //接口
	public function eat($food);
}
class Human implements ICanEat{ //实现接口
	public function eat($food){
		echo 'Human eating '.$food;
	}
}
class Animal implements ICanEat{
	public function eat($food){
		echo 'Animal eating '.$food;
	}
}
interface ICanWork extends ICanEat{ //接口继承
	public function work();
}
class Worker implements ICanWork{
	public function eat($food){
		echo 'Worker eating '.$food;
	}
	public function work(){
		echo 'Worker working';
	}
}
注: php不支持类的多继承，但支持接口的多继承，即一个接口可以继承多个接口，如
interface C extends A, B{
	//...
}
7, 多态
同一接口的不同实现, 或者父类的方法在子类中的不同实现, 就叫多态;
可以把对不同子类的调用统一当成接口来处理;
function toEat($obj, $food){
	if($obj instanceof ICanEat){
		$obj->eat($food);
	}
}
$boy = new Human();
$dog = new Animal();
toEat($boy, 'apple');
toEat($dog, 'orange');
8, 抽象类
抽象类介于接口与具体类之间，允许有一部分方法没有定义;
抽象类用abstract class定义, 抽象类里没实现的方法前面也要加abstract关键字;
抽象类也不能实例化对象;
abstract class ACanEat{
	abstract public function eat($food);
	public function breath(){
		echo 'breath use the air';
	}
}
class Human extends ACanEat{
	public function eat($food){
		echo 'Human eating '.$food;
	}
}
class Animal extends ACanEat{
	public function eat($food){
		echo 'Animal eating '.$food;
	}
}
9, 魔术方法
1)__toString()
把对象当做字符串时自动调用;
2)__invoke()
把对象当做函数时自动调用;
3)__call(), callStatic()
也称为PHP的方法重载;
当访问对象不存在的方法时，__call()会被自动调用;
当访问对象不存在的静态方法时，__callStatic()会被自动调用;
这两个方法接收两个参数，第一个参数是方法名称，第二参数是方法接收的参数组成的数组;
4)__get(), __set(), __isset(), __unset()
也称为PHP的属性重载;
不可访问属性包括未定义的属性和定义为private或protected的属性;
给不可访问属性赋值时，自动调用__set();
读取不可访问属性时，自动调用__get();
不可访问属性调用isset()时，自动调用__isset();
不可访问属性调用unset()时，自动调用__unset();
5)__clone()
用clone关键字复制对象时自动调用, 默认的__clone()会--复制属性，可以在自定义的
__clone()方法里覆盖某些需要更改的属性，不需要更改的属性还会按默认的自动复制;
该方法不接受任何参数;
class Test{
	private $data = array();
	public static $cloneCount = 0;
	public function __toString(){
		return 'this is a test';
	}
	public function __invoke($x){
		echo 'use object as function with param '.$x;
	}
	public function __call($name, $args){
		echo 'calling '.$name.' with params: '.implode(',', $args);
	}
	public static function __callStatic($name, $args){
		echo 'calling static '.$name.' with params: '.implode(',', $args);
	}
	public function __get($name){
		if(isset($this->data[$name])){
			return $this->data[$name];
		}else{
			return null;
		}
	}
	public function __set($name, $value){
		$this->data[$name] = $value;
	}
	public function __isset($name){
		return isset($this->data[$name]) ? true : false;
	}
	public function __unset($name){
		if(isset($this->data[$name])){
			unset($this->data[$name]);
		}
	}
	public function __clone(){
		self::$cloneCount++;
	}
}
$obj = new Test();
echo $obj; //$obj.__toString()
$obj(3); //$obj.__invoke(3)
$obj->run('zhao', 30); //$obj.__call('run', ['zhao', 30])
Test::runStatic('zhao', 30); //$obj.__callStatic('runStatic', ['zhao', 30])
$obj->name = 'zhao'; //$obj.__set('name', 'zhao')
echo $obj->name; //$obj.__get('name')
echo isset($obj->name); //$obj.__isset('name')
unset($obj->name); //$obj.__unset('name');
$obj2 = clone $obj; //$obj.__clone()
10, 类的自动加载
最新版本的php通过spl_autoload_register()函数来实现类的自动加载;
spl_autoload_register(function($className){
	require $className.'.php';
});
$p = new Person();
当遇到没有定义的类，会自动加载与类名称一致的文件;
老版的php通过实现系统函数__autoload来实现类的自动加载;
function __autoload($className){
	require $className.'.php';
}
$p = new Person();
11, 后期静态绑定
在类中访问静态属性和静态方法可以用self或static, self与static的区别在于static可以后期静态绑定;
class Person{
	public static function eat(){
		echo 'Person eat';
	}
	public static function test1(){
		self::eat();
	}
	public static function test2(){
		static::eat();
	}
}
class Student extends Person{
	public static function eat(){
		echo 'Student eat';
	}
}
Student::test1(); // 'Person eat'
Student::test2(); // 'Student eat'
12, trait特性
PHP7引入trait关键字是为了解决以前只能单继承的问题;
//trait的定义跟类是一样的
trait A{ 
	public $name = 'zhao';
	public function f1(){
		echo 'Name: ';
	}
}
trait B{
	public $age = 30;
	public function f2(){
		echo 'Age: ';
	}
}
class Test{
	//引入trait，使用use导入
	use A, B;
	public function f(){
		$this->f1();
		echo $this->name;
		$this->f2();
		echo $this->age;
	}
}
$obj = new Test();
$obj->f(); //'Name: zhaoAge: 30'

>>php操作mysql
1, mysqli扩展
现在操作数据库一般用mysqli扩展和PDO，mysqli扩展的特点:
有基于面向对象和面向过程的两套处理方式;
支持预处理语句;
支持事务;
2, 检测mysqli扩展是否开启
1)phpinfo();
2)检测扩展是否已加载
extension_loaded('mysqli'); //true
3)检测函数是否存在
function_exists('mysqli_connect'); //true
4)得到当前已经开启的扩展
get_loaded_extensions(); //array(...)
3, 面向对象的mysqli
1)建立连接, 打开指定的数据库
$conn = new mysqli('localhost', 'root', 'password', 'test');
//$conn = new mysqli('localhost', 'root', 'password');
//$conn->select_db('test');
if($conn->connect_errno){
	die('Connect Error: '.$conn->connect_error);
}
注: connect_errno是错误编号，如果连接成功该属性为0, connect_error是错误信息;
$conn是一个对象，包含服务端、客户端和本次连接的各种属性和方法;
也可以不指定数据库，后面的sql语句在表前加所属数据库名, 如
$sql = "select * from test.user";
2)设置客户端字符集
$conn->query('set names utf8');
//$conn->set_charset('utf8');
3)执行sql语句
$conn->query($sql); //执行单条sql语句
$conn->multi_query($sql); //执行多条sql语句
对于select/show/desc查询，执行成功返回mysqli_result对象，失败返回false;
对于其他sql语句的查询，执行成功返回true, 失败返回false;
4)插入、更新、删除数据
$sql = "insert/update/delete";
$r = $conn->query($sql); //$r为true或false
if($r){
	//$conn->insert_id --本次插入的第一条数据的id
	//$conn->affected_rows --受影响记录的条数
}else{
	//errno --错误号, error --错误信息
	echo 'Error '.$conn->errno.': '.$conn->error;
}
5)查询数据
$sql = "select id, username, age from user";
$r = $conn->query($sql); //$r为mysqli_result对象或false
if($r && $r->num_rows > 0){
	//方法一: 返回所有结果
	//返回结果为二维数组，默认参数为MYSQLI_NUM
	$rows = $r->fetch_all(MYSQLI_NUM/MYSQLI_ASSOC/MYSQLI_BOTH);
	//方法二: 每次返回一条结果
	$row = $r->fetch_row(); //一维索引数组
	$row = $r->fetch_assoc(); //一维关联数组
	$row = $r->fetch_array(); //一维混合数组
	$row = $r->fetch_object(); //返回对象
	while($row = $r->fetch_assoc()){
		//...
	}
}else{
	echo '查询错误或者结果集中没有数据';
}
6)预处理语句
预处理语句用于插入的例子:
$sql = "insert into user(name, age) values (?, ?)";
//准备预处理语句，返回mysqli_stmt对象
$stmt = $conn->prepare($sql);
//绑定参数, s--字符串, i--整数, d--浮点数
$name = 'zhao';
$age = 30;
$stmt->bind_param('si', $name, $age);
//执行预处理语句
$r = $stmt->execute();
if($r){
	//$stmt->insert_id 
	//$stmt->affected_rows 
}else{
	echo 'Error '.$conn->errno.': '.$conn->error;
}
预处理语句用于查询的例子:
$sql = "select id, name, age from user where id > ?";
$stmt = $conn->prepare($sql);
$id = 10;
$stmt->bind_param('i', $id);
$r = $stmt->execute();
if($r){
	//绑定结果集中的值到变量
	$stmt->bind_result($id, $name, $age);
	//遍历结果集
	while($stmt->fetch()){
		echo "ID: $id, name: $name, age: $age.<br>";
	}
}
使用预处理语句的优点:
服务器只在第一次解析查询，后面就节约了解析与编译的开销;
只有参数发送到服务器，而不是整个查询语句，这减少了网络流量;
安全性提高，防sql注入攻击;
7)事务处理
$conn->autocommit(false); //先关闭自动提交，默认是true
$s1 = "update account set money = money - 200 where id = 1";
$r1 = $conn->query($s1);
$affect1 = $conn->affected_rows;
$s2 = "update account set money = money + 200 where id = 2";
$r2 = $conn->query($s2);
$affect2 = $conn->affected_rows;
if($r1 && $affect1>0 && $r2 && $affect2>0){
	$conn->commit(); //提交
	echo '转账成功';
	$conn->autocommit(true); //开启自动提交
}else{
	$conn->rollback(); //回滚
	echo '转账失败';
}
$conn->close();
注: 使用事务前要先关闭自动提交，关闭了自动提交必须通过$conn->commit()提交才能真正执行;
8)关闭数据库
$conn->close();
4, 面向过程的mysqli
//连接数据库
$conn = mysqli_connect('localhost', 'root', 'password', 'test') or 
	die(mysqli_connect_errno().':'.mysqli_connect_error());
//设置字符集
mysqli_set_charset($conn, 'utf8');
//执行插入
$sql = "insert into user(name, age) values ('zhao', 30)";
$r = mysqli_query($conn, $sql);
if($r){
	//mysqli_insert_id($conn)
	//mysqli_affected_rows($conn)
}else{
	echo mysqli_errno($conn).':'.mysqli_error($conn);
}
//执行更新和删除
$sql = "update user set age = age + 10 where id = 20;";
$sql .= "delete from user where id = 30";
$r = mysqli_multi_query($conn, $sql);
var_dump($r);
//预处理语句
$sql = "insert into user(name, age) values (?, ?)";
$stmt = mysqli_prepare($conn, $sql);
$name = 'zhao';
$age = 30;
mysqli_stmt_bind_param($stmt, 'si', $name, $age);
$r = mysqli_stmt_execute();
var_dump($r);
//执行查询
$sql = "select id, name, age from user";
$r = mysqli_query($conn, $sql);
if($r && mysqli_num_rows($r) > 0){
	while($row = mysqli_fetch_assoc($r)){
		echo "ID: {$row['id']}, name: {$row['name']}, price: {$row['price']}<br>";
		//$rows[] = $row;
	}
}else{
	echo '查询错误或者结果集中没有数据';
}
//关闭连接
mysqli_close($conn);

>>php常用的系统函数
1, 字符串函数
2, 日期时间函数
3, 数学函数
1)abs(): 绝对值
2)floor(): 向下取整
3)ceil(): 向上取整
4)round(): 四舍五入, 可指定精度
round(3.14159); //3
round(3.14159, 2); //3.14
5)rand(): 返回随机整数
rand(); //0到getrandmax()之间
rand(1, 100); //1到100之间，包括1和100
6)mt_rand(): 同rand()一样，效率更高
7)min(): 最小值，可传入若干参数，也可传入数组
min(2, 3, 1, 6); //1
min([2, 3, 1, 6]); //1
8)max(): 最大值
4, 数组函数
1)count(): 数组元素的个数
2)in_array(): 判断元素是否在数组中
in_array('b', ['a', 'b', 'c']); //true
3)array_keys(): 返回数组的所有键名组成的数组
4)array_values(): 返回数组的所有值组成的数组
$a = ['name'=>'zhao', 'age'=>30, 'city'=>'hefei'];
array_keys($a); //['name', 'age', 'city']
array_values($a); //['zhao', 30, 'hefei']
5)implode()(同名join()): 将数组拼接成字符串, 与explode()相反
implode(',', ['one', 'two', 'three']); //'one,two,three'
6)array_merge(): 数组合并, 如果索引相同则覆盖
array_merge(['name'=>'zhao', 30], ['name'=>'qian', 40]); //['name'=>'qian', 30, 40]
7)array_reverse(): 反转数组
8)array_flip(): 交换数组的键和值
array_flip(['name'=>'zhao', 30]); //['zhao'=>'name', 30=>1]
9)array_push(): 数组后面插入值, 得到数组元素的个数
10)array_pop(): 数组后面删除元素，返回删除的元素值
11)array_shift(): 数组前面删除元素，返回删除的元素值
12)array_unshift(): 数组前面插入值, 得到数组元素的个数
13)sort(): 排序，用于索引数组，对关联数组应用sort()也返回索引数组
14)rsort(): 与sort()相反
15)ksort(): 按索引排序
16)krsort(): 与ksort()相反
17)asort(): 按值排序
18)arsort(): 与asort()相反
5, 判断变量
1)is_bool(): 判断是否是布尔类型
2)is_float(): 判断浮点型
3)is_integer(): 判断整型
4)is_object(): 判断对象
5)is_array(): 判断数组
6)is_string(): 判断字符串
7)is_resource(): 判断资源
8)is_scalar(): 判断标量(整型、布尔型、浮点型、字符串型)
9)is_null(): 判断变量是否为null
10)is_numeric(): 判断是否数字或数字字符串
11)gettype(): 获得数据类型
12)settype(): 改变数据类型
13)isset(): 变量是否存在
14)unset(): 销毁变量
15)empty(): 变量是否为空('', 0, '0', NULL, false)
6, 文件操作函数
1)scandir(): 读取一个文件夹内的所有文件，返回所有文件名组成的数组
2)file_exists(): 判断文件夹或文件是否存在
3)is_dir(): 判断是否是文件夹
4)is_file(): 判断是否是文件
5)fopen(): 打开一个文件资源
6)fclose(): 释放一个文件资源
7)mkdir(): 创建一个文件夹, 如果路径已存在则会报错
8)rmdir(): 移除文件夹
9)unlink(): 删除文件
10)rename(): 重命名文件
11)copy(): 复制文件
12)filesize(): 文件大小, 以字节为单位
13)filectime(): 文件创建时间, 返回时间戳
14)filemtime(): 文件最后修改时间
15)file_get_contents(): 从一个指定文件读取内容, 传入文件路径, 返回字符串
16)file_put_contents(): 将指定的字符串写入到文件
17)fgetc(): 读取一个字符
18)fgets(): 读取一行
19)fread(): 读取指定长度的字节
20)fwrite(): 写入内容到文件
7, 其他函数
1)error_reporting(E_ALL): 设置错误级别
2)ini_set('display_errors', 1); 设置系统参数
3)define(): 定义常量
4)defined(): 检测常量是否定义
5)json_encode(): 对变量进行JSON编码
6)json_decode(): 对JSON格式的字符串进行解码
7)base64_encode(): 对数据进行base64加密
8)base64_decode(): base64解密

>>命名空间
1, 解决两类问题
防止命名冲突; 为长标识符名创建别名;
2, 受命名空间约束的代码: 类、接口、函数、常量;
命名空间必须在所有代码之前声明;
3, 同一个文件中可定义多个命名空间(不提倡);
#test.php
namespace MyProject {
	const CONNECT_OK = 1;
	class Connection{/* ... */}
	function connect(){/* ... */}
}
namespace { //全局空间
	session_start();
	$a = MyProject\connect();
	echo MyProject\Connection::start();
}
4, 命名空间下类/函数/常量的引用
1)相对命名空间
new Foo(); --> currentnamespace\Foo;
new subnamespace\Foo(); --> currentnamespace\subnamespace\Foo;
2)全局命名空间
new \currentnamespace\Foo();
举例
#file1.php
namespace My\subnamespace;
function strlen(){}
#file2.php
namespace My;
include 'file1.php'
function strlen(){}
//调用
strlen(); //My\strlen
subnamespace\strlen(); //My\subnamespace\strlen
\subnamespace\strlen(); //subnamespace\strlen, 没有定义此命名空间则报错
\strlen(); //全局strlen
5, 命名空间下动态访问的陷阱
动态访问时字符串不会按相对于当前命名空间进行解析;
namespace My;
class Person(){
	public function say(){}
}
$obj = new Person(); //可以
$s = 'Person';
$obj = new $s(); //不可以, 会访问全局\Person
$s = 'My\Person';
$obj = new $s(); //可以, 等价于 new Person();
6, __NAMESPACE__常量 和 namespace关键字
__NAMESPACE__常量是当前命名空间的字符串;
namespace关键字表示当前命名空间，相当于类中的self，但不是字符串;
访问上例中My命名空间下的Person类的几种方式:
1)$obj = new Person();
2)$obj = new \My\Person();
3)$obj = new namespace\Person();
4)$s = 'My\Person';
$obj = new $s();
5)$s = __NAMESPACE__.'\Person';
$obj = new $s();
7, 导入和别名
1)导入命名空间、类、函数和常量
namespace foo;
use My\Full\NSname; //与use My\Full\NSname as NSname相同
use My\Full\Classname as Another; //导入类并设置别名
use function My\Full\functionName; //导入函数，要用use function
use const My\Full\CONSTNAME; //导入常量，要用use const
2)use可以在一行中导入多个
use My\Full\Classname as Another, My\Full\NSname;
3)导入和动态名称
use My\Full\Classname as Another;
$obj = new Another(); //My\Full\Classname
$s = 'Another';
$obj = new $s(); //new \Another(), 因为字符串是完全限定的
8, 全局空间
如果没有定义命名空间，则是全局空间;
namespace A\B\C;
function fopen(){ //这个函数是A\B\C\fopen
	/*....*/
	$f = \fopen(...); //调用全局的fopen函数
	return $f;
}
9, 类的解析与函数/常量的不同之处
类只解析到所属命名空间，如果不存在则报错;
而函数和常量如果所属命名空间中不存在，则会到全局空间中查找;
namespace A\B\C;
class Exception extends \Exception{}
$a = new Exception('hi'); //$a是类A\B\C\Exception的一个对象
$b = new \Exception('hi'); //$a是全局类Exception的一个对象
$c = new ArrayObject(); //报错, 当前命名空间不存在ArrayObject类
$d = strlen('hello'); //当前命名空间不存在, 到全局空间查找strlen
$e = __FILE__; //当前命名空间不存在, 到全局空间查找__FILE__

>>异常处理
try{
	throw new Exception('this is a error');
}catch(Exception $e){
	echo $e->getMessage(); //'this is a error
	echo $e->getFile(); //发生异常的文件
	echo $e->getLine(); //发生异常的行
}

>>设计模式
1, 单例模式
将构造函数和__clone方法都设置为private，不允许在外部创建与复制对象，只能通过定义的静态方法返回一个对象;
class Test{
	private static $obj = null;
	private function __construct(){
	
	}
	private function __clone(){
	
	}
	public static function getInstance(){
		if(empty(self::$obj)){
			self::$obj = new Test();
		}
		return self::$obj;
	}
}
$o = Test::getInstance();
2, 工厂模式
//具体类
class Apple{

}
//工厂类，具体实例统一从工厂类里定义的方法返回
class Fruit{
	public static function factory(){
		return new Apple();
	}
}
$o = Fruit::factory();

>>站点配置
更改配置文件，需要重启服务器才能生效;
1, 自定义网站根目录(httpd.conf)
目录结构:
xampp--------------------------集成开发包
	htdocs---------------------集成开发包的默认网站根目录
		tp---------------------下载的tp框架放到默认网站根目录下
			public-------------tp的公共目录
				index.php------tp的入口文件
				test-----------测试目录
					test.html--测试文件
修改服务器的配置文件，以xampp集成包为例，修改apache的配置文件httpd.conf，位于
xampp/apache/conf/httpd.conf:
DocumentRoot "E:/xampp/htdocs/tp/public"
<Directory "E:/xampp/htdocs/tp/public">
在url中输入localhost即可访问tp的默认模块;
在url中输入localhost/test/test.html即可访问测试文件;
注: tp框架也可以不用放到xampp/htdocs目录下，只要把DocumentRoot定位到tp框架的public目录即可;
2, 多站点配置
需要三个步骤:
1)自定义网站根目录(如果无须更改根目录, 这一步可以省略)
xampp/apache/conf/httpd.conf:
DocumentRoot "F:/Demo"  
<Directory "F:/Demo">
2)定义域名
xampp/apache/conf/extra/httpd-vhosts.conf:
<VirtualHost *:80>
	DocumentRoot "F:/Demo/test01"
	ServerName test01.com
</VirtualHost>
<VirtualHost *:80>
	DocumentRoot "F:/Demo/test02"
	ServerName test02.com  
</VirtualHost>
3)设置域名解析
C:/Windows/System32/drivers/etc/hosts(用管理员权限打开才能更改):
127.0.0.1 localhost  //原文件中有
127.0.0.1 test01.com 
127.0.0.1 test02.com //这两行是需要添加的
以上三步设置完成，重启服务器，在url中输入test01.com/a.php就可以访问;
3, 修改端口号
apache默认80端口号，可以将其修改为8080;
xampp/apache/conf/httpd.conf:
Listen: 8080
ServerName localhost: 8080
以后在url中要输入localhost:8080/test/test.php才能访问；

>>无限级分类
1，递归实现，以pid表示
建一个字段pid表示父级id;
递归操作中如何保存结果:
1)$GLOBALS['result'];
2)使用引用参数；
//从指定pid一直递归查到最底层
function getList($pid=0, &$result=array(), $depth=0){
	$depth += 2;
	$sql = "select * from t where pid = $pid";
	$r = $conn->query($sql);
	if($r && $r->num_rows > 0){
		while($row = $r->fetch_assoc()){
			$row['name'] = str_repeat('&nbsp;', $depth).'|--'.$row['name'];
			$result[] = $row;
			getList($row['id'], $result, $depth);
		}
	}
	return $result;
}
3)static $result = array();
//从指定id一直查到最顶层
function getList($id){
	static $result = array();
	$sql = "select * from t where id = $id";
	$r = $conn->query($sql);
	if($r && $r->num_rows > 0){
		$row = $r->fetch_assoc();
		getList($row['pid']);
		$result[] = $row;
	}
	return $result;
}
2，以全路径实现
建一个字段path，把所有祖先的id按序排列，如path: '1,2,4'(不包括父级id);
//从指定path一直递归查到最底层
function getList2($path=''){
	$result = array();
	$sql = "select id, name, path, concat(path, ',', id) fullpath from area 
	  where path like "."'$path%'"." order by fullpath";
	$r = $conn->query($sql);
	if($r && $r->num_rows > 0){
		while($row = $r->fetch_assoc()){
			$depth = count(explode(',', trim($row['fullpath'], ',')));
			$row['name'] = str_repeat('&nbsp;&nbsp;', $depth).'|--'.$row['name'];
			$result[] = $row;
		}
	}
	return $result;
}
//从指定id一定查到最顶层
id->fullpath;
$sql = "select * from t where id in (fullpath) order by id";

>>简单验证码制作
1，captch.php  //生成数字字母验证码
session.start();
//生成底图
$image = imagecreatetruecolor(100, 30); //生成底图，默认黑色背景
$bgcolor = imagecolorallocate($image, 255, 255, 255); //白色背景
imagefill($image, 0, 0, $bgcolor); //用白色背景填充
$captch_code = ''; //用来保存验证码
//生成验证码字符序列
for($i = 0; $i < 4; $i++){
	$fontsize = 6; //字体大小
	$fontcolor = imagecolorallocate($image, rand(0,100), rand(0,100), rand(0,100)); 
	$data = 'abcdefghijkmnpqrstuvwxy3456789'; 
	$fontcontent = substr($data, rand(0, strlen($data)-1), 1);
	$captch_code .= $fontcontent; 
	$x = ($i*100/4) + rand(5,10);
	$y = rand(5,10);
	imagestring($image, $fontsize, $x, $y, $fontcontent, $fontcolor); //绘制字符串
}
$_SESSION['authcode'] = $captch_code;
//生成点干扰元素
for($i = 0; $i < 200; $i++){
	$pointcolor = imagecolorallocate($image, rand(50,200), rand(50,200), rand(50,200));
	imagesetpixel($image, rand(1,99), rand(1,29), $pointcolor); //绘制点
}
//生成线干扰元素
for($i = 0; $i < 3; $i++){
	$linecolor = imagecolorallocate($image, rand(80,200), rand(80,200), rand(80,200));
	imageline($image, rand(1,99), rand(1,29), rand(1,99), rand(1,29), $linecolor); //绘制线
}
//输出
header('Content-Type:image/png'); //必须设置header信息
imagepng($image); //输出验证码图片
2，test.php //前端页面
//校验部分
<?php
if(isset($_REQUEST['authcode'])){
	session_start();
	if(strtolower($_REQUEST['authcode']) == $_SESSION['authcode']){
		echo '输入正确';
	}else{
		echo '输入错误';
	}
	exit();
}
?>
//前端表单页面，点击验证码图片可自动刷新
<form method="post" action="test.php">
	<div>验证码图片: <img border="1" src="captch.php" width="100" height="30" onclick="this.src='captch.php'"></div>
	<div>请输入图片中的内容: <input type="text" name="authcode" value=""></div>
	<div><input type="submit" value="提交"></div>
</form>
3, captch_image.php //生成图片验证码
session_start();
$table = ['pic01'=>'人', 'pic02'=>'天', 'pic03'=>'狗', 'pic04'=>'猫']; //素材库: 图片->值
$index = rand(1, 4);
$_SESSION['authcode'] = $table['pic0'.$index];
$filename = __DIR__.'\\image\\pic0'.$index.'.jpg';
$content = file_get_contents($filename);
header('Content-Type:image/jpg');
echo $content;


>>php中操作json的函数
1，json_encode()
将php变量转换成json串;
$rs = array();
$rs['result'] = 1;
$rs['msg'] = '成功';
$rs['data'] = array(
	array('name'=>'zhao', 'age'=>30),
	array('name'=>'qian', 'age'=>32),
	array('name'=>'sun', 'age'=>26)
);
$json = json_encode($rs);
$rs; //'{"result":1,"msg":"\u6210\u529f","data":[{"name":"zhao","age":30},{"name":"qian","age":32},{"name":"sun","age":26}]}'
2，json_decode(string $json, bool $assoc=false)
将json串解析成php变量，第二个参数默认为false会将json串解析成对象，为true则转换成关联数组;
$json = '{"name": "zhao", "age": 30}';
$r1 = json_decode($json);
$r2 = json_decode($json, true);
print_r($r1); //stdClass Object([name]=>zhao [age]=>30)
print_r($r2); //Array([name]=>zhao [age]=>30)
注：数组串解析成索引数组；
对象串默认解析为php对象，参数为true则解析为关联数组；

>>php二维数组json转换实例
$a = array(
	array('name'=>'zhao', 'age'=>30),
	array('name'=>'qian', 'age'=>40)
);
$b = json_encode($a);  
echo $b; //[{"name":"zhao","age":30},{"name":"qian","age":40}]
$c = json_decode($b); 
print_r($c); //Array ( [0] => stdClass Object ( [name] => zhao [age] => 30 ) [1] => stdClass Object ( [name] => qian [age] => 40 ) )
$d = json_decode($b, true); 
print_r($d); //Array ( [0] => Array ( [name] => zhao [age] => 30 ) [1] => Array ( [name] => qian [age] => 40 ) )  


>>php中正则表达式
1, php中正则表达式的定义
$reg = '/(\w)\d/'; //要用引号括起来
$reg = '/\w\d/i'; //忽略大小写
$reg = '/\w\d+?/'; //懒惰模式
2, php中正则相关的方法
1), preg_match($reg, $s, $match)
正则匹配，只匹配第一次，返回匹配的次数，即0和1;
匹配的结果放在参数$match中, $match是一维数组;
$r = preg_match('/(\w)\d/', 'a1b2c3d4', $match);
$r; //1
$match; //['a1', 'a']
2), preg_match_all($reg, $s, $matches)
正则匹配，全文匹配, 返回匹配的次数，即0,1,2....;
匹配的结果放在参数$matches中，$matches是二维数组;
$r = preg_match_all('/(\w)\d/', 'a1b2c3d4', $matches);
$r; //3
$matches; //[['a1', 'b2', 'c3', 'd4'], ['a', 'b', 'c', 'd']]
3), preg_replace($reg, $rep, $s)
正则替换, 返回替换后的结果;
$r = preg_replace('/\d/', 'X', 'a1b2c3d4');
$r; //'aXbXcXdX'
$r = preg_replace('/(\w+) (\d+), (\d+)/i', '$3, $1 $2', 'April 15, 2014');
$r; //'2014, April 15'
注：php的preg_replace是替换所有匹配的字符串;
str_replace是php的字符串函数，是preg_replace()的子集;
4), preg_split($reg, $s);
正则分割
$r = preg_split('/\d/', 'a1b2c3d4');
$r; //['a', 'b', 'c', 'd', '']
注：explode()是php的字符串函数，是preg_split()的子集;
5), preg_quote($s)
对字符串中的正则元字符进行转义，这个函数不是很常用;
$r = preg_quote('.\{');
$r; //'\.\\\{'


>>MVC简介
模型(model)-视图(view)-控制器(controller)
将数据显示与业务逻辑分离;
控制器: 调用模型，并调用视图，将模型产生的数据传递给视图让视图去显示;
模型: 获取数据;
视图: 显示数据;

>>入口程序
单一入口机制: 在一个web应用程序中，所有的请求都指向同一脚本文件, 如
index.php?xxx;
优点: 安全监测, 请求过滤;

>>简易目录规范
mvc
	libs ----------------------------------类库目录
		Controller ------------------------控制器目录
			testController.class.php 
		Model -----------------------------模型目录
			testModel.class.php
		View ------------------------------视图目录
			testView.class.php 
		ORG -------------------------------第三方类库
	config.php ----------------------------配置文件
	common.php ----------------------------公共函数文件
	index.php -----------------------------入口文件
	
>>实现简易MVC
//index.php
//入口文件形式: index.php?controller=控制器名&method=方法名
require_once('common.php');
$controllerAllow = ['test', 'index'];
$methodAllow = ['show'];
$controller = in_array($_GET['controller'], $controllerAllow) ? $_GET['controller'] : 'index';
$method = in_array($_GET['method'], $methodAllow) ? $_GET['method'] : 'show';
C($controller, $method);
//common.php
function C($name, $method){
	$controllerName = $name.'Controller';
	require_once('/libs/Controller/'.$controllerName.'.class.php');
	$obj = new $controllerName();
	$obj->$method();
}
function M($name){
	$modelName = $name.'Model';
	require_once('/libs/Model/'.$modelName.'.class.php');
	$obj = new $modelName;
	return $obj;
}
function V($name){
	$viewName = $name.'View';
	require_once('/libs/View/'.$viewName.'.class.php');
	$obj = new $viewName;
	return $obj;
}
//testController.class.php
class testController{
	public function show(){
		$testModel = M('test');
		$data = $testModel->get();
		$testView = V('test');
		$testView->display($data);
	}
}
//testModel.class.php
class testModel{
	public function get(){
		return 'hello, bing';
	}
}
//testView.class.php
class testView{
	public function show($data){
		echo $data;
	}
}

>>MVC的变形
1, 无Model模式的web开发, 常用于不用操作数据库的静态页面;
2, 无View模式的api接口开发, 常用于开发app接口;
3, Model再分层和Controller再分层;
	

>>tp5目录结构
tp5
	application	//....................应用目录app，我们在这个目录中编程
		index  //.....................一个模块
			controller //.............控制层
			model //..................模型层
			view //...................视图层
		admin //......................另一个模块
		config.php //.................应用的配置文件
		database.php //...............数据库配置
		route.php //..................路由文件
		common.php //.................公共文件，可以将项目的通用函数放到这
		command.php //................用命令行运行php时读取的配置文件
		tags.php //...................应用行为扩展
	public //.........................网站的根目录，对外开放的接口
		index.php //..................入口文件
		static //.....................放置网站的静态文件
			css //....................css文件
			js //.....................js文件
			imgs //...................图片
		favicon.ico //................网站的默认图标
		router.php //.................用于快速启动的配置
		robots.txt //.................给搜索引擎爬取
	thinkphp //.......................tp5的框架
		base.php //...................定义一些常量
		composer.json //..............定义composer的配置文件
		console.php //................控制台的入口文件
		convention.php //.............框架默认的配置文件
		helper.php //.................助手函数
		start.php //..................框架启动文件
		lang //.......................语言包
		library //....................框架的核心
			think //..................核心文件
			traits //.................类库的扩展
		tpl //........................框架默认的一些模板
	extend //.........................第三方类库可以放到这
	runtime //........................运行中的缓存文件
	vendor //.........................安装过程中生成的类库放在这个文件夹
注：php默认将common模块为公共模块，里面放一些公共的方法，所以common模块无法通过浏览器访问，
可以在其他模块的控制器中引入common模块里的方法来调用；
	
>>设置域名绑定
打开apache的配置文件httpd.conf, 添加
<VirtualHost *:80>
    DocumentRoot "/home/www/tp5/public"
    ServerName tp5.com
</VirtualHost>
打开系统文件C:/Windows/System32/drivers/etc/hosts文件, 修改
127.0.0.1 tp5.com

>>隐藏入口文件
localhost/index.php/index/Index/index 简化为 localhost/index/Index/index；
现在的tp版本默认隐藏入口文件，如果没有默认隐藏，可自行百度进行隐藏设置；

>>绑定入口文件
在public/index.php中添加
define('BIND_MODULE', 'admin'); //url: localhost/user/validate
define('BIND_MODULE', 'admin/user'); //url: localhost/validate
define('BIND_MODULE', 'admin/user/validate'); //url: localhost
应用举例，比如给第三方写一个接口，可以在public中新建一个对外的接口，在其中进行入口绑定，不允许
第三方访问访问除API以外的其他模块；
//public/api.php
<?php
define('APP_PATH', __DIR__.'/../application/');
define('BIND_MODULE', 'api');
require(__DIR__.'/../thinkphp/start.php');
第三方访问的url：localhost/controller/method; 访问被限制在API模块内部；

>>路由
1, tp采用单一入口模式访问应用，所有的请求都定位到入口文件, 系统从url参数解析当前请求的
模块、控制器和操作，标准的url访问格式：http://localhost/index.php/模块/控制器/操作;
入口文件默认可隐藏，隐藏后的url格式：http://localhost/模块/控制器/操作;
2, 命名规范: 模块名和操作名必须小写，控制器名和文件名保持一致，首字母大写;
控制器名如果采用驼峰命名，如HelloWorld，默认必须采用hello_world的形式访问，可以修改
配置文件的'url_convert'=>true来支持驼峰访问;
3, 带参数的url
http://localhost/index/Index/index/name/zhao/age/30
http://localhost/index/Index/index?name=zhao&age=30
或 http://localhost/index/Index/index.html?name=zhao&age=30
url会自动寻找同名的参数，参数的先后顺序可以随意;
还可以精简url的参数形式省略参数名，修改配置 'url_param_type'=>1就可以，此时url变成
http://localhost/index/Index/index/zhao/30
4, 自定义路由
修改application/route.app文件；
比如在route.php中新增一项 news/:name=>'index/index/info', 则url由
localhost/index/Index/info/name/zhao 变成 localhost/news/zhao.html;

>>配置
1，只修改框架自带的配置文件
1)惯例配置 
位于thinkphp/convention.php，包含所有的配置选项，一般不修改该文件；
2)项目配置
位于application/config.php，可以修改该配置文件，修改结果会覆盖惯例配置；
3)数据库配置
位于application/database.php，可以在这修改数据库配置，修改结果会覆盖惯例配置；
2，自定义配置文件
修改public/index.php文件, 添加
//定义配置文件目录
define('CONF_PATH', __DIR__.'/../config/');
新建与application同级的文件夹config, 在里面添加配置文件;
配置文件都是以数组的形式返回;
能通过助手函数config()输出所有配置;
1)应用配置
在config文件夹下新建配置文件, 如config.php, database.php, session.php, cookie.php等;
这些配置文件会覆盖惯例配置中的配置项;
应用配置对这个应用有效;
2)模块配置
新建config/index/config.php, 设置index模块的配置项;
新建config/admin/config.php, 设置admin模块的配置项;
模块配置仅对特定模块有效;
3)场景配置
在config/config.php中添加一项: 'app_status'=>'home'或'office';
新建config/home.php, 设置home的配置选项;
新建config/office.php, 设置office的配置选项;
3，动态配置
在控制器的构造函数中或者某个方法中配置; 
Config::set('key', 'value');
config('key', 'value');
注: 开发时一定要设置'app_debug'=>true, 否则错误不显示;

>>Config类与config()助手函数
1, Config类
Config类位于thinkphp/library/think/config/Config.php, 使用Config类需要先导入;
use think\Config;
Config::set('username', 'tangbing');
echo Config::get('username');
echo Config::has('username');
//也可以写成 $res = \think\Config::get();
2, config()助手函数
助手函数位于thinkphp/helper.php文件, 助手函数全局可用，不需要导入;
$res = config('username');
echo config('?username'); //前面加个?号，判断是否存在

>>系统环境变量
Env类位于thinkphp/library/think/Env.php, 使用Env类需要先导入, use \think\Env;
新建与application同级的文件.env配置文件, 在.env文件填写相关环境配置;
.env经常与config文件配合使用，用于开发环境、测试环境与线上环境的切换;
//.env
status=dev
[database]
username=root
password=root
//config/config.php
return [
	'status' => Env::get('app_status', 'dev'); //如果没有设置app_status环境变量，则默认使用第二个参数的值
];
//config/database.php
return [
	'username' => Env::get('database.username', 'root'),
	'password' => Env::get('database.password', 'root');
];
//config/dev.php
return [
	'app_now_status' => 'dev'
];
//config/test.php
return [
	'app_now_status' => 'test'
];
//config/prod.php
return [
	'app_now_status' => 'prod'
];
当不同环境之间切换时，只用修改.env文件;

>>请求对象Request
Request对象处理客户端的数据以及服务器端的环境变量; 需要引入use think\Request;
Request对象封装了$_GET, $_POST, $_REQUEST, $_SESSION, $_COOKIE, $_FILES等全局变量的值;
1, Request对象的几种调用方式
1)$request = request(); //request()助手函数
2)class Index{
	public function index(Request $request){ //自动注入请求对象
		//...
	}
}
3)$request = Request::instance(); //单例模式
$request->param('id');
4)class Index extends Controller{
	public function index(){
		echo $this->request->param('id'); //think\Controller包含request属性
	}
}
5)echo input('session.username'); //input()助手函数获取具体参数值
6)echo session('username'); //session()助手函数获取具体的参数值
2, 获取请求信息
1)获取请求参数
$req->param(); //返回所有请求参数的数组, 不需要区分请求的类型，统一获取
$req->param('name');
$req->param('name', 'zhao'); //第二个参数是默认值
$req->get();
$req->get('name');
$req->post();
$req->cookie();
$req->session();
$req->file();
$req->method(); //请求的类型
$req->url(); //获取当前的url地址，有关url信息的有很多其他方法，具体参考文档
$req->module(); //当前模块
$req->controller(); //当前控制器
$req->action(); //当前操作
$req->routeInfo(); //路由信息
$req->dispatch(); //调度信息
2)使用助手函数input()
input('param.'); //$request->param();
input('param.name'); //$request->param('name');
input('?name');  
input('?param.name'); //同上, $request->has('name');

>>响应对象Response
大多情况下，我们不需要关注Response对象本身，只需要在控制器的方法中返回数据即可；
public function getUserInfo($type = 'json'){
	Config::set('default-return-type', $type);
	$res = [
		'code' => 200,
		'data' => ['name'=>'zhao', 'age'=>30]
	];
	return $res;
	//等价于 return json_encode($res);
}

>>重定向
public function show($name){
	if($name == 'baidu'){
		$this->redirect('http://www.baidu.com');
		//return redirect('http://www.baidu.com'); //等价, 这是使用redirect()助手函数
	}else{
		return $this->fetch();
	}
}

>>命名空间
app命名空间代表application；
think命名空间代表thinkphp/library/think;

>>视图和模板
1, 调用视图
1)使用助手函数view()
//app/index/controller/Index.php
public function index(){
	return view(); //app/index/view/Index/index.html
	return view('main'); //app/index/view/Index/main.html
	return view('page/main'); //app/index/view/Page/main.html
	return view('main', ['name'=>'zhao']); //向页面传递参数
	return view('./../application/index/view/Page/main.html'); //全路径查找(只做演示用)，效果同上
	return view('./page.html'); //public/page.html
}
注：'./page.html'表示public目录下的page.html文件，必须带后缀;
2)使用模板控制器的方法(推荐)
//app/index/controller/Index.php
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
	public function index(){
		return $this->fetch('main'); //参数的意义同view()
	}
}
3)不调用视图，直接输出字符串
$this->assign('name', 'zhao');
$this->display('My name is {$name}');
注: fetch()是调用视图文件, 而display()直接将字符串输出，常用于简单调试;
2, 从控制器向视图传递数据的四种方式
1)直接传参(常用)
//app/index/controller/Index.php
public function index(){
	return $this->fetch('main', ['name'=>'zhao', 'age'=>30]);
}
//app/index/view/index/main.html
<div>Name: {$name}, age: {$age}</div>
2)通过assign()方法(常用)
$this->assign('name', 'zhao');
$this->assign('age', 30);
return $this->fetch('main');
3)$this->view->city = 'hefei';
4)use think\View;
View::share('major', 'maths');
注: 视图模板编译后的文件保存在runtime/temp文件夹中;
3, 更改模板配置
模板配置在惯例配置thinkphp/convention.php里的template键里, 如果要更改模板配置, 
可以把template的值复制到应用配置里，再修改;
4, 字符串替换
模板提供了预定义的字符串替换, 如
__STATIS__: /static //根目录就是入口文件所在的目录，也就是public
__JS__: /static/js
__CSS__: /static/css
也可以自己定义字符串替换:
复制惯例配置中'view_replace_str'=>[], 在其中添加自定义字符串的配置, 如
'view_replace_str'=[
	'__CSS__' => '/front/css,
	'__UPLOAD__' => '/upload'
];
5, 系统变量
视图中可以直接通过$Think来调用系统变量，无须通过控制器传参;
//main.html
{$Think.server.OS} //等价于<?php echo $_SERVER['OS'] ?>
{$Think.session.name}
{$Think.cookie.email}
{$Think.get.id}
{$Think.request.id}
{$Think.const.APP_PATH} 
{$Think.APP_PATH} //同上，获取系统常量
6, 变量调节器
视图中的变量可以使用函数以及运算来对输出进行调节;
{$name|strtoupper}
{$name|substr=0,5} //变量默认为第一个参数
{$name|str_replace='o','*',###} //变量不是第一个参数则用###来占位
{$name|md5|strtoupper} //管道方式
{$a+$b}
7, 变量的默认值
使用default，如果没有从控制器传参，则使用默认值，如果有从控制器传参则使用传参的值;
{$name|default='zhao'}
8, 变量的原样输出
{literal}{$name}{/literal} //原样输出{$name}
9, 模板注释
{/*This is template comment*/} //页面看不到, 查看源代码也看不到
而<!--This is html comment-->从源代码中能看到;
10, 条件判断
<!--if-->
{if $level>=2 and $level<=5}
	<div>This is a normal level</div>
{else}
	<div>The level is not normal</div>
{/if}
<!--switch-->
{switch name="Think.get.level"}
	{case value="1|2"}<div>优秀</div>{/case} //0|1表示0或1
	{case value="3"}<div>良好</div>{/case}
	{case value="4"}<div>及格</div>{/case}
	{default}其他{/default}
{/switch}
注：条件标签还有很多，具体百度;
11, 循环
视图模板的循环有三种形式
<!--foreach方式1(常用)-->
{foreach $arr as $key=>$value}
	<div>{$key}: {$value.name}, {$value.age}</div>
{/foreach}
<!--foreach方式2-->
{foreach name="arr" key="k" item="v"}
	<div>{$k}: {$v.name}, {$v.age}</div>
{/foreach}
<!--for-->
{for start="1" end="10" step="2" name="i"}
	<div>{$i}</div> //step可省略, 默认为1, name可省略, 默认为i
{/for}
<!--volist-->
{volist name="arr" id="value"}
	<div>{$value.name}, {$value.age}</div>
{/volist}
12, 模板的布局
//目录结构
view 
	common 
		header.html --------被包含头模块
		footer.html --------被包含尾模块
		base.html ----------基类模块
	index
		main.html
		page1.html 
		page2.html
	layout.html ------------模板文件
1)模板包含 {include file=""}
//main.html
{include file="common/header"}
<div>This is container.</div>
{include file="common/footer"}
2)模板继承 {extend name=""}
在基模板中设置{block}，然后在继承时重写{block}，其他地方保持不变;
使用{__block__}可以引用基模板中对应name的内容;
//base.html
<div>
	{block name="myname"}This is index/main.{/block}
</div>
//index.html
{extend name="common/base"}
//page1.html
{extend name="common/base"}
<div>
	{block name="myname"}This is index/page1.{/block}
</div>
//page2.html
{extend name="common/base"}
<div>
	{block name="myname"}This is index/page2.{/block}
</div>
3)模板文件layout.html
修改应用配置，增加
'template' => [
	'layout_on' => true,
	'layout_name' => 'layout'
],
这样，控制器所有的视图$this->fetch()都指向view/layout.html文件了;
//layout.html
<div>{__CONTENT__}</div>  //{__CONTENT__}会由具体文件中的内容替换
//main.html
This is main.
//page1.html
This is page1.
//page2.html
This is page2.

>>数据库操作
tp中的数据库操作有三种方式: 
数据库原生查询(SQL查询);
数据库链式查询(查询构造器);
模型的对象化查询;
1, 设置数据库配置
在应用配置中新建database.php文件，将惯例配置中的数据库部分复制过来并修改;
2, 连接数据库的四种方式
//config.php
return [
	'app_debug' 	=> true,
	'my_database' 	=> [
		'type' 		-> 'mysql',
		'hostname'  => '127.0.0.1',
		....
	]
];
//database.php
return [
	'type' 		=> 'mysql',
	'hostname'  => '127.0.0.1',
	....
];
1)use think\Db;
$conn = Db::connect();
2)$conn = Db::connect([
	'type' => 'mysql',
	'hostname' => '127.0.0.1',
	....
]);
等价于 $conn = Db::connect(Config::get('my_database'));
3)$conn = Db::connect('my_database');
4)$conn = Db::connecct('mysql://root:root@127.0.0.1:3306/test#utf8');
参数格式为: tpye://username:password@hostname:port/database#charset;
注：Db::connect()是惰性加载，只在执行query()或execute()方法时才真正连接数据库；
每次调用Db::query()/execute()方法时，都是默认连接database.php里配置的数据库，除非用
$db = Db::connect('db1'); $db->query();
3, 原生操作
//查询
$rs = Db::query('select * from tname where id = $id'); //不安全
$rs = Db::query('select * from tname where id = ?', [$id]); //参数绑定形式
$rs = Db::query('select * from tname where id = :id', ['id'=>$id]]); //占位符绑定形式
$rs = Db::query("desc tname");
$rs = Db::query("show variables like '%char%'");
//执行插入、更新、删除
$rs = Db::execute('insert into tname(name, age) values(?, ?)', ['zhao', 30]);
$rs = Db::execute('update tname set age = age + 1 where name = ?', ['zhao']);
$rs = Db::execute('delete from tname where name = ?', ['zhao']);
$rs = Db::execute('truncate table tname');
注: 1)Db::query()执行读操作，返回二维数组；Db::execute()执行写操作，返回影响的记录数；
2)也支持查询的时候切换数据库, 如
$rs = Db::connect('mysql://root:123456@127.0.0.1:3306/dbname2#utf8')->query('select * from tname');
为了简化代码，通常在配置文件(如application/config.php)中定义好多个数据库的连接配置, 如
'db1'=>[
	//配置参数
],
'db2'=>[
	//配置参数
]
$db1 = Db::connect('db1');
$db2 = Db::connect('db2');
$rs1 = $db1->query('...');
$rs2 = $db2->query('...');
4, 链式操作(查询构造器)
查询构造器的优点是基于PDO实现，对不同的数据库驱动都是统一的语法;
//查询
$db= Db::table('tname'); //等价于Db::name('tname'), 等价于db('tname')
$rs = $db->where(['id'=>3])->select(); //所有记录, 二维数组
$rs = $db->where('id', 3)->find(); //仅第一条记录，一维数组
$rs = $db->where(’id', 3)->value('name'); //一条记录的name字段的值，一个值
$rs = $db->where('id', 3)->column('name'); //所有满足条件的记录的name字段的值，一维数组
$rs = $db->where('age', '>', 20)
		->field('avg(age) as avg_age, level')
		->group('level')
		->order('level desc')
		->limit(2, 10)
		->select(); 
注: 链式操作不分先后，只要在select()方法之前调用就行;
注: table()里的表名含前缀, 而name()不含前缀;
Db::table('tname') 与 db('tname') 等价，后者是助手函数;
注: 如果查询结果为空，select()返回空数组，find()返回null;
注：链式查询可以用buildSql()来得到原生sql语句；
//插入
$db = Db::table('tname');
$rs = $db->insert(['name'=>'zhao', 'age'=>30]); //返回被影响的行数
$rs = $db->insertGetId(['name'=>'zhao', 'age'=>30]); //返回插入的Id
$data = [['name'=>'zhao', 'age'=>30], ['name'=>'qian', 'age'=>32]];
$rs = $db->insertAll($data); //插入多条数据, 返回影响的行数(也就是插入的条数)
//更新
$rs = $db->where('name', 'zhao')->update(['age'=>88]); //返回被影响的行数
$rs = $db->where('name', 'zhao')->setField('age', 99); //更新一个字段的值
$rs = $db->where('name', 'zhao')->setInc('age', 10); //set age = age + 10
$rs = $db->where('name', 'zhao')->setDec('age', 10); //set age = age - 10
//删除
$rs = $db->where(['name'=>'zhao'])->delete(); //返回被影响的行数
注: 更新和删除操作必须传where条件，否则报错;
//分组查询
$rs = $db->field('sid, avg(score) avgScore')->group('sid')->select();
5, 条件构造器
$db->where('name', 'null'); //id=3 或 name is null 的形式
$db->where('id', '>', 3); //=(eq), <>(neq), >(gt), >=(egt), <(lt), <=(elt)
$db->where('id', 'between', '1,10'); //between/between/in/notin, '1,10'/[1,10]
$db->where('id', '>', 1)->where('id', '<', 10); //and
$db->where('id', '>', 1)->whereOr('id, '<', 10); //or
$db->where('id', 'exp', '>1 and <10'); //自定义条件
//原生字符串查询
$db->where('id > 10 and name is not null');
$db->where('id > ? and age < ?', [5, 30]); //参数绑定防止sql注入
$db->where('id > :id and age < :age', ['id'=>5, 'age'=>30]); 
注: 可以用buildSql()来构造原生的sql语句;
6, 事务处理
//回调函数形式
Db::transaction(function(){
	Db::table('user')->insert(['name'=>'hu', 'age'=>20]);
	Db::execute('update tcount set len=len+1');
});
//手动控制事务的提交与回滚
Db::startTrans();
try{
	Db::table('user')->where('name', 'hu')->delete();
	Db::execute('update tcount set len=len-1');
	Db::commit(); //提交事务
}catch(\Exception $e){
	Db::rollback(); //执行失败则回滚事务
}
7, 分块查询
当数据量非常大时，一次性取数据会导致内存开销非常大，可以采用分块查询，如每次取100条数据进行处理：
Db::name('student')->where('status', '>', 0)
	->chunk(100, function($list){
		foreach($list as $val){
			//处理每一条数据
		}
	});
8, tp5对时间查询的支持
在数据表中新增一个表示时间的字段，比如birthday，类型可以是int/datetime/timestamp/string等都可以;
Db::name('student')->whereTime('birthday', '>', '2000-1-1')->select();
Db::name('student')->whereTime('birthday', '>', 'this week')->select();
Db::name('student')->whereTime('birthday', '>', '-2 months')->select();
Db::name('student')->whereTime('birthday', 'between', ['2000-1-1', '2010-1-1'])->select();
Db::name('student')->whereTime('birthday', 'today')->select();
Db::name('student')->whereTime('birthday', 'last week')->select();
9, 多表联合查询
$r = Db::name('student')->alias('s')
	->join('sc', 's.id = sc.sid')
	->join('course c', 'c.id = sc.cid')
	->field('s.name sname, c.name cname, sc.score')
	->select();

>>模型
0, tp5的模型
tp5的模型是ORM(对象-关系映射)的封装；
关系表->模型，记录->模型对象实例，字段->对象属性;
模型是一种对象化操作，不是简单的CURD操作，简单的CURD操作用Db类即可；
Db类的查询默认返回数组，而模型类返回的是当前的模型对象实例；
1, 模型定义
1)模型命名
模型名与数据表的名称一致，遵循驼峰命名法, user->User.php, user_info->UserInfo.php;
namespace app\index\model;
use think\Model;
class User extends Model{
	//...
}
2)模型类的实现
大多数情况下，无须为模型定义任何的属性和方法即可完成基本的操作；
模型会自动对应一个数据表，数据库表前缀+模型类名->数据表名;
模型的命名是驼峰法，转换为表名会自动转换为小写+下划线的表名；
也可以在模型中定义单独的数据表，有两种方式:
a)protected $table = 'think_user'; //包含前缀
b)protected $name = 'user'; //不包含前缀
如果当前的模型类需要使用不同的数据库连接，可以定义模型的connection属性，
protected $connection = [
	//数据库的配置
];
注：一般来说，一个应用的模型都是公用的，不区分模块，所以不必在每个模块下面定义模型；
2, 引入模型的几种方式
1)use app\index\model\User; //推荐
User::get(1)->toArray();
2)use app\index\model\User;
$user = new User(); //实例化
3)use think\Loader;
$user = Loader::model('User'); //通过Laoder类，当模型很多时，无须引入模型
4)$user = model('User'); //model()助手函数
3, 查询
1)$user = new User();
$rs = $user->where('age', '>', 30)->select();
foreach($rs as $v){
	print_r($v->toArray());
}
2)$id = 2;
$rs = $user->get($id); //传入主键作为参数
$rs = $user->get(['email'=>'1234567@qq.com']); //传入数组作为非主键
$rs = $user->getByEmail('1234567@qq.com'); //同上
echo "name: {$rs->name}, age: {$rs->age}";
3)查询多条数据
$list = User::where('id', '<', 5)->select(); 
$list = User::all(); //所有数据
$list = User::all('1,2,3,4,5'); //主键等于1,2,3,4,5其中一个的数据
$list = User::all(function($query){ //通过闭包函数来查询
	$query->where('id', '<', 5)->select();
});
foreach($list as $v){
	print_r($v->toArray());
}
4, 插入
//插入单条数据
1)$user->insert(['name'=>'zhao', 'age'=>30]); 
2)$user = new User();
$user->name = 'zhao';
$user->age = 30;
if($user->save()){
	return '用户['.$user->name.']添加成功';
}else{
	return $user->getError();
}
//插入多条数据
1)$user->insertAll([[...], [...]]); //接收二维数组
2)$list = [[...], [...]];
$user->saveAll($list); 
5, 更新
1)$user->where('id', '5')->update(['age'=>32]);
2)$user = User::get($id);
$user->age += 1;
$user->save();
注：实例化模型后第一次执行save()，默认执行插入操作;
而对查询返回的实例执行save()，默认执行的是更新操作；
6, 删除
1)$user->where('name', 'exp', 'is null')->delete();
2)$user = User::get($id);
if($user){
	$user->delete();
}
7, 聚合操作
$user->count(); //计数
$user->where('age', '>', 30)->count(); //带条件
$user->avg('age'); 
$user->where('age', '>', 30)->avg('age'); 
常用的聚合函数有: count(), max(), min(), sum(), avg()等;
8, 模型读取器和修改器
数据库中User表的字段sex存储的值为0,1,2, 页面输出时自动显示'未知','男','女';
//模型文件 app/index/model/User.php
class User extends Model{
	protected function getSexAttr($val){ //函数名必须为getSexAttr
		return $val==0 ? '未知' : ($val==1 ? '男' : '女');
	}
	protected function getBirthdayAttr($val){ //对读取birthday字段进行格式化
		return date('Y-m-d', $val);
	}
	protected function setBirthdayAttr($val){ //$user->birthday = '1987-07-01'，自动存为时间戳
		return strtotime($val); 
	}
	protected function setPasswordAttr($val, $data){ //第二个参数为包含所有字段值的数组
		return md5($data['email'].$val);
	}
}
//控制器文件 app/index/controller/Index.php
class Index extends Controller{
	public function test1(){
		return User::get(1)->sex; //直接输出'男', '女' 或 '未知'
	}
	public function test2(){
		$user = new User();
		$user->name = 'zhao';
		$user->age = 30;
		$user->birthday = '1989-07-01';
		if($user->save()){
			return '新增成功';
		}else{
			return $user->getError();
		}
	}
}
9, 自动完成
给数据表添加create_time、insert_time、update_time、delete_time等字段，通过修改配置文件或者在
模型中添加方法，就可以对这些字段自动修改，具体参考文档；
10, 软删除
不真正删除数据库中的数据，而是将某个字段置为null或0，表示该条记录不存在;


>>composer
1, 基本概念
composer是PHP的一个依赖管理工具, 我们可以在项目中声明所依赖的外部工具库, 
composer会帮你安装这些依赖的库文件;
2, composer的安装
需要开启openssl配置, 在php.ini中开启extension=php_openssl.dll;
安装composer后，查看是否安装成功:
composer --version
更改Packagist为国内镜像:
composer config -g repo.packagist composer https://packagist.phpcomposer.com
更新composer为最新版本: composer self-update
3, composer的使用
1)在项目的目录下创建一个composer.json文件，文件描述了项目的依赖关系;
文件格式如下: 
{
    "require": {
        "monolog/monolog": "1.2.*"
    }
}
然后cmd进入项目目录, 运行
composer install
2)也可以使用require命令直接安装，不需要添加配置文件;
在项目的目录下运行: 
composer require monolog/monolog
3)update命令
update命令用于更新项目里所有的包, 或某些指定的包:
composer update //更新所有依赖
composer update monolog/monolog 更新指定的包
composer update monolog/monolog symfony/dependecy-injection //更新指定的多个包
composer update monolog/monolog symfony/* //通过通配符匹配包
注: 包能升级的最高版本会受到composer.json里配置的版本的约束;
4)remove命令
remove命令用于移除一个包及其依赖(在依赖没有被其他包使用的情况下);
composer remove monolog/monolog
5)search命令
search命令可以搜索包;
composer search monolog //输出包及其描述信息
6)show命令
show命令可以列出当前项目使用到包的信息;
composer show //列出所有已经安装的包
composer show monolog/* //通过通配符进行筛选
composer show monolog/monolog 显示具体某个包的信息
4, 基本约束
1)精确版本
可以告诉composer安装的具体版本，如1.0.2;
2)范围
通过比较操作符来指定包的范围, 包括: >, >=, <, <=, !=;
>=1.0
>=1.0 <2.0
>=1.0 <1.1 || >=1.2
3)通配符
1.0.*相当于>=1.0 <1.1;









