>>React基本概念
1, React由facebook开发, 是动态构建用户界面的js库, 将数据渲染成html页面;
2, React使用组件化开发方式, 采用声明式编码, 与传统的命令式编码(如jquery)不同;
3, React使用虚拟DOM+优秀的diffing算法, 最小化重绘页面, 尽量减少与真实dom的交互;


>>React基本使用
<div id="box"></div>
<script src="/react.develepment.js"></script>  //引入React全局对象
<script src="/react-dom.develepment.js"></script>  //引入ReactDOM全局对象
<script src="/babel.js"></script>
<script type="text/babel">  //此处一定要写babel
	const vdom = <div><p>Hello world</p></div>  //创建虚拟dom
	ReactDOM.render(vdom, document.getElementById('box'))  //渲染页面
	//ReactDOM.createRoot(document.getElementById('box')).render(vdom)
</script>
注: babel.js的作用: 
1)将es6语法转换成浏览器能识别的es5;
2)将jsx转换成js;


>>虚拟DOM
1, 创建虚拟DOM的两种方式
1)使用JSX
const vdom = <div id="main" className="content"><span>hello world</span></div>
2)使用 React.createElement(标签名, 标签属性, ...标签体)
const vdom = React.createElement('div', {id: 'main', className: 'content'}, 
	React.createElement('span', {}, 'hello world'));
注: JSX就是用来创建虚拟DOM的语法糖, 而虚拟DOM就是一个对象, 如
const vdom = {
	type: 'div',
	props: {
		id: 'main',
		className: 'content',
		children: {
			type: 'span',
			props: {
				children: 'hello world'
			}
		}
	}
}
注: 虚拟DOM的属性比真实DOM要少得多, 所以轻量级;
虚拟DOM是存放在内存中的对象, 最终会被React转换成真实DOM渲染到页面;
2, React元素
React元素就是一个js对象, ReactDOM负责更新DOM来与react元素保持一致;
React元素: const elem = <h1>hello world</h1>;
ReactDOM: const root = ReactDOM.createRoot(document.getElementById('root'));
渲染: root.render(elem);
注: React元素是不可变对象, 一旦被创建，就无法更改它的子元素和属性;
elem.props.className = 'change';  //×
elem.props.style = {color: 'red'};  //×
elem.props.style.color = 'red';  //√
3, 调用组件时, 组件体作为props.children一起传递
组件定义:
function MyLink(props) {
	return (
		<a className="link" {...props} />  //等价于
		<a className="link" {...props} >{props.children}</a>  
	)
}
调用组件:
<Mylink href="..." target="_blank">百度</MyLink>


>>JSX的语法规则
1, react定义的一种类似于XML的JS扩展语法: JS+XML;
2, 定义虚拟DOM时, 不要写引号;
3, 标签中混入js表达式时要用{};
4, 引入类名, 不能用class, 要用className;
5, 使用内联样式, 不能写成字符串, 要写成 style={{color: 'blue'}}, 或 style={myStyle};
6, 根标签只能有一个, 如果有多个标签, 要在最外层包一个<div>或<>;
7, 所有标签都必须闭合, 如 <input />;
8, JSX标签如果以小写开头, 则被转换成html元素, 如果以大写开头, 则视为组件;
注: JSX里的{}, 里面只能包含表达式, 而不能写流程控制语句, 如if等;


>>模块与组件
1, 模块
提供特定功能的js程序, 一般就是一个js文件;
仅拆分js;
2, 组件
用来实现局部功能的代码和资源的集合(html/css/js/image等);
不仅拆分js, 还拆分html, css, image等;
React是面向组件的编程;
3, 作用
简化代码, 提高复用性;


>>两种形式的组件
1, 函数组件
function Hello(props) {
	return <div>hello world</div>
}
2, 类式组件
class Hello extends React.Component {
	render() {
		return <div>hello world</div>
	}
}


>>组件的三大基本属性(类式组件)
1, state
组件一般都是有状态的, 数据驱动行为;
class Hello extend React.Component {
	constructor(props) {
		super(props)
		this.state = {
			isHot: false
		}
	}
	fn() {  //定义在原型链上
		this.setState({
			isHot: !this.state.isHot
		})
	}
	render() {
		return <div onClick={this.fn}>{this.state.isHot ? '太热了' : '很凉快'}</div>
	}
}
该实例存在bug, 会出现fn()里面this的指向问题, 可通过以下几种方式修改:
1)构造函数里增加如下一行, 改变fn()中this指向, 同时将fn定义到实例上:
this.fn = this.fn.bind(this);
2)将fn定义成箭头函数, 箭头函数中的this就等于外层this:
fn = () => {
	this.setState({
		isHot: !this.state.isHot
	})
}
3)在事件绑定时修改fn中的this指向:
<div onClick={this.fn.bind(this)}>...
注: 状态的修改必须通过this.setState()来实现, 且多个状态之间的修改是合并, 而不是替换;
注: constructor()只调用一次, fn()调用n次, render()调用1+n次;
2, props
用来向组件传递数据;
//逐个数据传递
<Hello name="zhao" age=32 />
//批量传递
const p = {name: 'zhao', age: 32}
<Hello {...p} />
注: 组件的props是只读的, 只允许从父组件接收数据, 不允许修改;
3, refs
组件内的标签使用ref来标识自己;
类式组件的refs使用有三种形式:
1)字符串形式(即将废弃)
给组件标签定义ref, 然后就可以通过类的refs属性引用;
<input ref="ip1" />
<input ref="ip2" />
引用: this.refs.ip1.value;
2)回调函数形式
<input ref={c => this.ip1 = c} />  //c就表示input结点
引用: this.ip1.value;
3)createRef形式
this.myRef = React.createRef();  //创建一个容器
<input ref={this.myRef} />  //将input结点本身放入到容器, 一个容器只能存一个结点
引用: this.myRef.current.value;


>>受控表单数据绑定的几种方式(类式组件)
1)state = {username: '', password: ''}
handleChange = (dateType, e) => {
	this.setState({
		[dateType]: e.target.value
	})
}
username: <input type="text" name="username" onChange={e => handleChange('username', e)} />
password: <input type="password" name="password" onChange={e => handleChange{'password', e)} />
2)state = {username: '', password: ''}
handleChange = (dateType) => {  //高阶函数的形式
	return e => {
		this.setState({
			[dateType]: e.target.value
		})
	}
}
username: <input type="text" name="username" onChange={handleChange('username')} />
password: <input type="password" name="password" onChange={handleChange{'password')} />
3)state = {username: '', password: ''}
handleChange = e => {
	this.setState({
		[e.target.name]: e.target.value
	})
}
username: <input type="text" name="username" onChange={handleChange} />
password: <input type="password" name="password" onChange={handleChange} />



>>组件的生命周期
1, 初始化阶段: 由ReactDOM.render()触发--初次渲染
1)constructor()
2)componentWillMount()
3)render() * //常用
4)componentDidMount() * //常用, 一般在这个钩子中做一些初始化的事, 例如: 开启定时器、发送网络请求、订阅消息等;
2, 更新阶段: 由组件内部this.setState()或父组件render()触发
1)shouldComponentUpdate()
2)componentWillUpdate()
3)render()
4)componentDidUpdate()
3, 卸载组件: 由ReactDOM.unmountComponentAtNode()触发
1)componentWillUnmount() * //常用, 一般在这个钩子中做一些收尾的事, 例如: 关闭定时器、取消订阅消息等;


>>通过脚手架的 npx create-react-app demo 命令创建项目, 脚手架会通过webpack创建一个
内置服务器devServer, public文件夹就是这台内置服务器的根路径, 然后就可以通过 
localhost:3000来访问应用;
注: 刷新页面, 某些静态资源会从缓存中取, 按shift键的同时刷新, 则所有资源都从后台重新取, 不走缓存;


>>消息订阅与发布
通过消息订阅与发布, 可以在兄弟组件之间传递数据, 从而更改状态;
1, 下载消息订阅插件
yarn add pubsub-js [--save] 或 npm install pubsub-js [--save]
引入插件
import PubSub from 'pubsub-js';
2, A组件订阅消息
function A() {
	const [data, setData] = useState({ //... });
	useEffect(() => {
		PubSub.subscribe('atguigu', (_, data) => {  //第一个参数为消息名, 此处同'atguigu'所以省略
			setData(preData => {
				return {...preData, ...data}
			});
		};
		return () => {  //组件解挂后取消消息订阅
			PubSub.unsubscribe('atguigu');
		}
	})
}
3, B组件发布消息
function B() {
	PubSub.publish('atguigu', {
		//...传递的数据
	});
}
注: 当B发布'atguigu'消息时, 订阅该消息的A组件就会收到B发布的数据, 从而实现更改状态;


>>请求数据的几种方式
1, XMLHttpRequest
2, jQuery.ajax({
	//...
})
3, axios(url).then(res=>{
	//...
}).catch(err=>{
	//...
});
注: jQuery.ajax()和axios(url)都是对XMLHttpRequest的封装, 而且都是第三方库, 需要先下载后使用;
axios可以避免jQuery.ajax()产生的回调地狱的问题;
4, fetch
fetch(url).then(response => {
	return response.json()  //response.json()也是Promise对象
}).then(res => {
	//...
}).catch(err => {
	//...
});
注: fetch是js的原生方法, 并不是对XMLHttpRequest的封装, 可以直接使用;
5, 使用async...await对.then的优化
async () => {
	try {
		const resp = await fetch(url)
		const data = await resp.json()
		console.log('success: ', data)
	} catch(err) {
		console.log('error: ', err)
	}
}
或者
async () => {
	try {
		const data = await fetch(url).then(res => {
			return res.json()
		}).catch(err => {
			return err
		});
	} catch(err) {
		console.log('error: ', err)
	}
}
注: await只能等待成功的结果, 对于失败的结果使用try...catch处理;


>>react路由
1, SPA(单页应用)
整个应用只有一个页面, 点击链接不会刷新页面, 只做局部更新, 数据通过ajax请求并在前端异步展示;
2, 路由
一个路由就是一个映射关系(key: value), key就是url中的path, value就是一个function或component;
1)后端路由
//如nodejs中注册路由
router.get(path, function(req, res));
2)前端路由
注册路由: <Route path='/test' component={Test}>
工作过程: 当浏览器的path变为/test时, 当前路由组件就会变为Test组件;
注: 前端路由的底层是由window.history实现;
3, 路由的原理
1)点击导航连接引起路径变化;
2)路径的变化被路由器检测到, 进行匹配组件;
4, 使用路由
1)下载路由包, yarn add react-router-dom;
2)引入并使用
import {BrowserRouter, Link, Route} from 'react-router-dom';
<BrowserRouter>
	...
	<Link to="/about">About</Link>  //导航链接
	<Lint to="/home">Home</Link>
	...
	<Route path="/about" component={About}/>  //注册路由
	<Route path="/home" component={Home}/>
</BrowserRouter>
注: react-router-dom是专用于web的路由包;
BrowserRouter是/方式的路由器, 与之对应的HashRouter是#方式的路由器;
5, 一般组件与路由组件
1)写法不同
一般组件: <Demo />
路由组件: <Route path="/demo" component={Demo} />
2)接收到的props不同
一般组件: 写组件标签时传递什么就接收什么;
路由组件: 自动接收到三个固定的属性: history, location, match;
6, <NavLink>
点击导航链接时高亮显式, 使用<NavLink>代替<Link>;
<NavLink activeClassName="active" to="/about">About</Link>
<NavLink activeClassName="active" to="/home">Home</Link>
给.active编写一个高亮的样式;
注: 可以通过自定义组件来封装导航链接组件, 如
function MyNavLink(props) {
	return (
		<NavLink activeClassName="active" {...props} />
	)
}
7, <Switch>
将注册路由列表用<Switch>包裹起来, 就能使Route的path与component进行单一匹配;
8, <Redirect>
当第一次进入页面时, 没有选择任何匹配, 则默认重定向到一个指定的匹配;
<Route path="/about" component={About} />
<Route path="/home" component={Home} />
<Redirect to="/home" />
9, 嵌套路由
在Home文件夹新建两个文件夹News和Message, 作为导航链接Home的子导航链接;
//Home.js
{/* 子导航区 */}
<NavLink activeClassName='focus' to="/home/news">News</NavLink>
<NavLink activeClassName='focus' to="/home/message">Message</NavLink>
{/* 注册路由 */}
<Switch>
	<Route path="/home/news" component={News} />
	<Route path="/home/message" component={Message} />
	<Redirect to="/home/news" />
</Switch>







