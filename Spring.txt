>>Spring IoC
1, Spring框架的核心是IoC和AOP; 
IoC(Inverse of Control)控制反转, 由IoC容器来创建与管理对象, 使用者从IoC容器获取对象;
DI(Dependency Injection)依赖注入是具体技术实现, 在java中利用反射来实现对象注入;
2, 管理bean对象的三种配置方式
1)基于XML配置bean
2)基于注解配置bean
3)基于java代码配置bean
3, 基于XML实现IoC
1)引入Spring依赖 - pom.xml
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.2.6.RELEASE</version>
</dependency>
2)xml配置bean对象 - resources/applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--利用构造函数实例化对象: 默认构造函数-->
    <bean id="apple1" class="com.imooc.spring.ioc.entity.Apple" />
	<!--利用构造函数实例化对象: 带参构造函数-->
	<bean id="apple2" class="com.imooc.spring.ioc.entity.Apple">
		<constructor-arg name="title" value="红富士" />
		<constructor-arg name="origin" value="欧洲" />
		<constructor-arg name="color" value="红色" />
	</bean>
	<!--利用setter给对象赋值(注入静态属性)(会首先调用默认构造函数)-->
	<bean id="sweetApple" class="com.imooc.spring.ioc.entity.Apple">
        <property name="title" value="红富士" />
        <property name="color"  value="红色" />
        <property name="origin" value="欧洲" />
    </bean>
	<!--利用工厂获取对象: 工厂的静态方法(实际中使用较少)-->
	<bean id="apple3" class="com.imooc.spring.ioc.factory.AppleFactory" factory-method="createSweetApple" />
	<!--利用工厂获取对象: 工厂的实例方法(实际中使用较少)-->
	<bean id="factory" class="com.imooc.spring.ioc.factory.AppleFactory" />
	<bean id="apple4" factory-bean="factory" factory-method="createSoftApple" />
	<!--注入对象: 利用构造函数-->
	<bean id="andy" class="com.imooc.spring.ioc.entity.Child">
		<constructor-arg name="name" value="安迪" />
		<constructor-arg name="apple" ref="sweetApple" />
	</bean>
	<!--注入对象: 利用setter-->
	<bean id="lily" class="com.imooc.spring.ioc.entity.Child">
        <property name="name" value="莉莉" />
        <property name="apple" ref="sweetApple" />
    </bean>
</beans>
注: <bean>标签里的id也可以写成name, id只支持一个标识, 而name可支持多个标识, 如 name="apple1 fruit1";
注: id和name都允许在不同配置文件中出现重复, 后加载的覆盖前加载的;
3)java: 从IoC容器获取bean
//加载单个配置文件
ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");  //ApplicationContext对象就表示IoC容器
Apple sweetApple = context.getBean("sweetApple", Apple.class);
//Apple sweetApple = (Apple)context.getBean("sweetApple");
//加载多个配置文件
String[] configLocations = new String[]{"classPath:applicationContext-1.xml", "classPath:applicationContext-2.xml"};
ApplicationContext context = new ClassPathXmlApplicationContext(configLocations);
4)路径表达式
classpath:config.xml  //加载classpath(即target/classes)下的指定文件
classpath:com/imooc/config.xml  //classpath下(不包含jar)的指定包中的文件
classpath*:com/imooc.config.xml  //classpath下(包含jar)的指定包中的文件
classpath:config-*.xml  //classpath下以config开头的文件
classpath:com/**/config.xml  //classPath下com包下包含任何子包里面的config.xml
file:c:/config.xml  //c盘根路径的config.xml
5)注入集合类型
//注入List/Set
<bean id="..." class="...">
	<property name="someList">
		<list>
			<value>具体值</value> <!--List元素为基本类型-->
			<ref bean="beanId"></ref> <!--List元素为对象-->
		</list>
	</property>
</bean>
注: 注入Set只需把list改成set;
//注入Map
<bean id="..." class="...">
	<property name="someMap">
		<map>
			<entry key="k1" value="v1" /> <!--value为基本类型-->
			<entry key="k2" value-ref="beanId" /> <!--value为对象: 引用外部bean-->
			<entry key="k3">
				<bean class="...">
					...
				</bean>
			</entry> <!--value为对象: 内部bean-->
		</map> 
	</property>
</bean>
//注入Properties
<bean id="..." class="...">
	<property name="someProperties">
		<props>
			<prop key="k1">v1</prop>
		</props>
	</property>
</bean>
注: properties的key和value都必须是字符串类型;
在java中获取property的值使用getProperty()函数: 
context.getBean("company", Company.class).getInfo().getProperty("address");
6)查看容器内对象
String[] beanNames = context.getBeanDefinitionNames();
for(String beanName: beanNames){
	//名称: beanName
	//内容: context.getBean(beanName)
	//类型: context.getBean(beanName).getClass().getName()
}
7)IoC容器的销毁
((ClassPathXmlApplicationContext)context).registerShutdownHook();
4, bean对象的作用域及生命周期
<bean id="..." class=".." scope="..." />
1)scope属性清单
singleton  //单例(默认值), 每个容器内全局唯一
prototype  //多例, 每次使用都会创建一个实例
request  //web环境下, 每一次独立请求存在唯一实例
session  //web环境下, 每一个session存在唯一实例
websocket  //每一次WebSocket连接存在唯一实例
2)单例与多例的区别
-----------------------------------------------------------
				singleton			prototype
对象数量	   	全局唯一			存在多个
实例化时机		IoC容器启动时		getBean()或对象注入时
线程安全问题	存在			不存在
执行效率		高					低
------------------------------------------------------------
注: 实际使用中dao、service及controller对象一般都默认为单例;
3)bean的生命周期
<bean id="..." class="..." init-method="init" destroy-method="destroy">
	//...
</bean>
生命周期:
(容器初始化解析XML) -> 对象实例化 -> (为对象注入属性) -> 调用init-method初始化方法 -> (容器初始化完毕) 
	-> 执行业务代码 -> (容器销毁) -> 调用destroy-method方法释放资源 -> (容器销毁完毕)
5, 基于注解实现IoC
注解是将配置信息写在源代码中, 适合轻量级的应用项目;
1)Spring中三类注解
组件类型注解: 声明当前类的功能;
自动装配注解: 根据属性特征自动注入对象;
元数据注解: 更细化的辅助IoC容器管理对象的注解;
2)组件类型注解
@Component: 通用注解, 该注解描述的类将被IoC容器管理并实例化;
@Controller: 语义注解, 说明当前类是MVC应用中的控制器类;
@Service: 语义注解, 说明当前类是Service业务服务类;
@Repository: 语义注解, 说明当前类用于业务持久层, 通常描述对应Dao类;
注: 四种组件类型注解直接放在类名上;
括号内为bean的id, id可省略, 默认为首字母小写的类名;
@Repository("userDao")
public class UserDao{
	//...
}
3)XML配置开启组件扫描
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">
        <!--在IoC容器初始化时自动扫描四种组件注解并完成实例化-->
        <context:component-scan base-package="com.imooc" />
</beans>
4)自动装配注解
按类型装配(不推荐): @Autowired, @Inject;
按名称装配: @Resource(优先按名称, 再按类型只能匹配);
注: 自动装配注解放在属性或setter方法上, 如果放在属性上, 则底层直接给属性赋值, 不再执行setter方法;
@Resource(name="userDao")  //name属性可省略
如果设置了name属性, 则按name在IoC容器中将bean注入;
如果未设置name属性, 则
以属性名作为bean name在IoC容器中匹配bean, 如有匹配则注入;
若按属性名未匹配, 则按类型匹配, 同@Autowired;
使用建议: 在使用@Resource对象时推荐设置name或保持属性名与bean名称一致;
5)元数据注解
为IoC容器管理bean对象提供辅助功能的注解;
@Primary  //按类型装配时出现多个相同类型对象, 拥有此注解对象优先被注入
@PostConstruct  //描述方法, init-method配置的注解版本
@PreDestroy  //描述方法, destroy-method配置的注解版本
@Scope  //设置对象的scope属性
@Value  //为属性注入静态数据
注: @Value的使用:
@Service
public class UserService{
	@Value("imooc.com")
	private String metaData;
}
实际项目中经常把数据写在配置文件中, 分为以下三步:
//添加配置文件: resources/config.properties
metaData=imooc.com
connection.driver=jdbc
connection.user=root
connection.password=123456
//在applicationContext.xml中添加配置用来加载config.properties
<context:property-placeholder location="classpath:config.properties" />
//java程序中使用注解@Value
@Value("${metaData}")
private String metaData;
@Value("${connection.password}")
private String password;
6, 基于Java Config实现IoC
1)优势
完全摆脱XML的束缚, 使用独立java类管理对象与依赖;
可对配置进行集中管理, 避免注解配置的分散化;
可以在编译时进行依赖检查;
2)java config核心注解
@Configuration  //描述类, 说明当前类是配置类, 完全替代xml
@Bean  //描述方法, 方法返回对象将被IoC容器管理, beanId默认为方法名;
@ImportResource  //描述类, 加载静态文件, 可使用@Value注解获取
@ComponentScan  //描述类, 同xml的<context:component-scan>标签
3)实例
//Config.java
@Configuration
@ComponentScan(basePackages="com.imooc")  //扫描其他的组件注解
public class Config {  //当前类是配置类, 用于替代applicationContext.xml
	@Bean
	public UserDao userDao(){  //利用方法创建对象, beanId=方法名
		UserDao userDao = new UserDao();
		return userDao;
	}
	@Bean
	@Scope("prototype")  //可与注解配置搭配使用, 如设置为多例
	@Primary
	public UserService userService(UserDao userDao){  //依赖注入, 先按name注入, name不存在则按类型注入
		UserService userService = new UserService();
		userService.setUserDao(userDao);
		return userService;
	}
}
//SpringApplication.java
ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
7, Spring Test测试模块
1)Spring Test可对JUnit进行整合, 通过Spring Test可在JUnit单元测试时自动初始化IoC容器;
2)整合过程
maven工程依赖spring-test;
利用@RunWith与@ContextConfiguration描述测试用例类;
3)实例
@RunWith(SpringJUnit4ClassRunner.class)  //将junit4的执行权交由Spring Test, 在测试用例执行前自动初始化IoC容器
@ContextConfiguration(locations = {"classpath:applicationContext.xml"})  //说明要加载的配置文件
public class SpringTestor {
	@Resource
	private UserService userService;
	@Test
	public void testUserService(){
		userService.createUser();
	}
}


>>Spring AOP
1, 基本概念
AOP(Aspect Oriented Programming)面向切面编程, 将通用的、与业务无关的功能抽象封装为切面类, 
切面可配置在目标方法的执行前或执行后运行, 做到即插即用;
2, aop的使用步骤
1)在pom.xml中引入ioc与aop依赖
<dependencies>
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
		<version>5.2.6.RELEASE</version>
	</dependency>
	<!--aspectjweaver是spring aop的底层依赖-->
	<dependency>
		<groupId>org.aspectj</groupId>
		<artifactId>aspectjweaver</artifactId>
		<version>1.9.5</version>
	</dependency>
</dependencies>
2)编写切面类与切面方法
public class MethodAspect{  //切面类
	public void printTime(JoinPoint joinPoint){  //切面方法, 必须包含JoinPoint连接点参数
		SimpleDateFormat sdf = new SimpleDateFormat("YYYY-MM-dd HH:mm:ss sss");
		String time = sdf.format(new Date());
		String className = joinPoint.getTarget().getClass().getName();  //获取目标类的名称
		String methodName = joinPoint.getSignature().getName();  //获取目标方法的名称
		System.out.println("--->" + time + ":" + className + "." + methodName);
	}
}
3)在applicationContext.xml中进行aop配置
<!--ioc配置-->
<bean id="methodAspect" class="com.imooc.spring.aop.aspect.MethodAspect"/>
<!--aop配置-->
<aop:config>
	<!--PointCut 切点, 使用execution表达式描述切面的作用范围-->
	<aop:pointcut id="pointcut" expression="execution(public * com.imooc..*.*(..))"></aop:pointcut>
	<!--定义切面类-->
	<aop:aspect ref="methodAspect">
		<aop:before method="printExecutionTime" pointcut-ref="pointcut"/>
	</aop:aspect>
</aop:config>
3, 关键概念
1)Aspect 
切面, 具体的可插拔组件功能类, 通常一个切面只实现一个通用功能;
2)Target Class/Method
目标类、目标方法, 指真正要执行与业务相关的方法;
3)PointCut
切点, 使用execution表达式说明切面要作用在系统的哪些类上;
4)JoinPoint
连接点, 切面运行过程中是包含了目标类/方法元数据的对象;
5)Advice 
通知, 说明具体的切面的执行时机, Spring包含了五种不同类型通知;
4, JoinPoint核心方法
1)getTarget()
获取IoC容器内目标对象;
2)getSignature()
获取目标方法;
3)getArgs()
获取目标方法参数;
Object[] args = joinPoint.getArgs();
System.out.println("--->参数个数: " + args.length);
for(Object arg : args){
	System.out.print(arg + "  ");
}
5, PointCut切点表达式
1)切点表达式描述切面的作用范围;
execution(public * com.imooc..*.*(..)),  可匹配如下具体的方法:
public void com.imooc.spring.ioc.service.UserService.createUser(形参1, 形参2);
public * com.imooc..*Service.*(..)可匹配如UserService等以Service结尾的类的任意方法;
void com.imooc..*.*(..)可匹配没有返回值的方法;
* com.imooc..*.*()可匹配没有参数的方法;
* com.imooc..*.*(String, *)可匹配只有两个参数并且第一个参数为String类型的方法;
* com.imooc..*Service.create*(..)可匹配以Service结尾的类并且以create开头的方法;
其中, * - 通配符, .. - 包通配符, (..) - 参数通配符; 
public可省略, 默认为public;
6, AOP通知
AOP有五种通知类型
1)Before Advice  //前置通知, 目标方法运行前执行;
<aop:before method="doBefore" pointcut-ref="pointcut"/>
2)After Advice  //后置通知, 目标方法运行后执行, 类似于finally;
<aop:after method="doAfter" pointcut-ref="pointcut"/>
注: 后置通知无法获取目标方法的返回值或内部抛出的异常, 如果需要必须使用下面两种通知类型;
3)After Returning Advice  //返回后通知, 目标方法返回数据后执行;
//切面方法
public String doAfterReturning(JoinPoint joinPoint, Object ret){
	System.out.println("<---触发返回后通知, 返回值: " + ret);
}
//配置
<aop:after-returning method="doAfterReturning" pointcut-ref="pointcut" returning="ret"/>
注: 返回后通知, 切面方法需提供第二个参数用来接收目标方法的返回值;
4)After Throwing Advice  //异常通知, 目标方法抛出异常后执行;
//切面方法
public void doAfterThrowing(JoinPoint joinPoint, Throwable th){
	System.out.println("<---触发异常通知, 异常: " + th.getMessage());
}
//目标方法
public void createUser(String username){
	if(username.equals("zhao")){
		throw new RuntimeException("用户已存在");
	}
}
//配置
<aop:after-throwing method="doAfterThrowing" pointcut-ref="pointcut" throwing="th"/>
5)Around Advice  //环绕通知, 自定义通知执行时机, 可决定目标方法是否运行;
//切面方法
public Object check(ProceedingJoinPoint pjp){  //ProceedingJoinPoint是JoinPoint的升级版, 在原有功能外, 还可以控制目标方法是否执行
	//方法执行前的操作
	long stime = new Date().getTime();
	//执行目标方法, 返回目标方法的返回值
	Object ret = pjp.proceed();
	//方法执行后的操作
	long etime = new Date().getTime();
	System.out.println("方法的执行时间: " + (etime-stime) + "毫秒");
	return ret;
}
//配置
<aop:around method="check" pointcut-ref="pointcut"/>
注: 环绕通知的功能最强大, 可完成前面四种基本通知的操作;
7, aop的注解形式
1)pom.xml中增加相关依赖
2)applicationContext.xml中开启IoC组件扫描以及启用AOP注解模式
<context:component-scan base-package="com.imooc" />
<aop:aspectj-autoproxy />
3)在切面类和切面方法中使用注解
@Component  //标记切面类为组件
@Aspect  //切面类的注解
public class MethodChecker{
	@Around("execution(* com.imooc..*Service.*(..))")  //环绕通知的注解, 参数为切点表达式
	public Object check(ProceedingJoinPoint pjp){
		//....
	}
}
注: 其他几种通知的注解分别为: @Before, @After, @AfterReturning, @AfterThrowing;
8, aop的实现原理
1)代理模式-静态代理
代理模式是指通过代理对象来对原有对象(委托类的对象)的功能进行扩展;
静态代理是值必须手动创建代理类的代理模式;
//UserService(接口)
public interface UserService{
	public void createUser();
}
//UserServiceImpl(实现类)
public class UserServiceImpl implements UserService{
	public void createUser(){
		System.out.println("执行创建用户业务逻辑");
	}
}
//UserServiceProxy(代理类)
public class UserServiceProxy implements UserService{
	private UserService userService;  //持有委托类的对象
	public UserServiceProxy(UserService userService){	//通过带参构造函数实例化委托类对象
		this.userService = userService;
	}
	public void createUser(){  //对委托类的目标方法进行功能扩展
		System.out.println("当前时间: " + new Date());
		userService.createUser();
	}
}
注: 可以嵌套使用代理模式;
2)JDK动态代理
根据接口的结构自动生成代理类, 来对目标方法进行扩展;
3)Spring AOP基于代理类实现功能动态扩展, 有两种形式:
目标类实现了某接口, 通过JDK动态代理实现功能扩展;
目标类没有实现接口, 通过CGLib组件实现功能扩展;


>>Spring JDBC
1, JdbcTemplate是Spring JDBC的核心类, 提供数据CRUD方法;
Spring JDBC是对JDBC轻量级的封装, 比Mybatis的执行效率要高;
2, Spring JDBC的使用步骤
1)maven工程引入spring-jdbc依赖;
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.2.6.RELEASE</version>
</dependency>
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-jdbc</artifactId>
	<version>5.2.6.RELEASE</version>
</dependency>
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
	<version>8.0.27</version>
</dependency>
2)applicationContext.xml中配置DataSource数据源;
<!--(Datasource)数据源-->
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
	<property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
	<property name="url" value="jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true"/>
	<property name="username" value="root"/>
	<property name="password" value="123456"/>
</bean>
<!--IoC: JdbcTemplate-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
	<property name="dataSource" ref="dataSource"/>
</bean>
<!--IoC: Dao-->
<bean id="employeeDao" class="com.imooc.spring.jdbc.dao.EmployeeDao">
	<property name="jdbcTemplate" ref="jdbcTemplate"/>
</bean>
3)在dao中注入JdbcTemplate对象, 实现数据CRUD;
public class EmployeeDao{
	private JdbcTemplate jdbcTemplate;
	//省略getter/setter
	public Employee findById(int eno){
		String sql = "select * from employee where eno = ?";
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{eno}, new BeanPropertyRowMapper<Employee>(Employee.class));
        return employee;
	}
}
3, JdbcTemplate的数据查询方法
1)queryForObject()  //查询单条数据
String sql = "select * from employee where eno = ?";
Employee employee = jdbcTemplate.queryForObject(sql, new Object[]{1001}, new BeanPropertyRowMapper<Employee>(Employee.class));
2)query()  //查询多条数据
String sql = "select * from employee where dname = ?";
List<Employee> list = jdbcTemplate.query(sql, new Object[]{"研发部"}, new BeanPropertyRowMapper<Employee>(Employee.class));
3)queryForList()  //将查询结果作为Map进行封装
String sql = "select eno as empno, salary as sal from employee where dname = ?";
List<Map<String, Object>> map = jdbcTemplate.queryForList(sql, new Object[]{"研发部"});
4, JdbcTemplate的数据写入方法
数据的插入、更新、删除等写操作统一使用update()函数;
1)数据插入
String sql = "insert into employee(eno, ename) values (?, ?)";
jdbcTemplate.upadte(sql, new Object[]{1001, "zhao"});
2)数据更新
String sql = "update employee set salary = salary + ? where eno = ?";
int count = jdbcTemplate.update(sql, new Object[]{500, 1001});  //返回更新的数据条数
3)数据删除
String sql = "delete from employee where eno = ?";
int count = jdbcTemplate.update(sql, new Object[]{1001});  //返回删除的数据条数
5, 编程式事务
1)编程式事务是指通过代码手动提交与回滚事务;
SpringJDBC通过TransactionManager事务管理器实现事务控制, commit/rollback;
2)编程时事务的步骤
//applicationContext.xml
<!--IoC: 事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource" />
</bean>
<!--IoC: service中注入事务管理器属性-->
<bean id="employeeService" class="com.imooc.spring.jdbc.service.EmployeeService">
	<property name="employeeDao" ref="employeeDao"/>
	<property name="transactionManager" ref="transactionManager"/>
</bean>
//EmployeeService.java
public EmployeeService{
	private EmployeeDao employeeDao;
	private DataSourceTransactionManager transactionManager;
	//省略getter/setter
	public void batchImport(){
        //事务默认的标准配置
        TransactionDefinition definition = new DefaultTransactionDefinition();
        //开始一个事务
        TransactionStatus status = transactionManager.getTransaction(definition);
        try {
            //....
            transactionManager.commit(status); //事务提交
        } catch (Exception e) {
            transactionManager.rollback(status); //事务回滚
            e.printStackTrace();
        }
    }
}
6, 声明式事务
1)声明式事务是指通过配置形式自动实现事务控制, 本质就是AOP环绕通知;
当目标方法执行成功时, 自动提交事务; 当目标方法抛出运行时异常时, 自动回滚事务;
2)声明式事务的步骤
//pom.xml中加入aop的依赖
//applicationContext.xml中的配置
配置声明式事务需要三个步骤, 完整的applicationContext.xml如下:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--数据源-->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url"
                  value="jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    <!--IoC: JdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>
	<!--IoC: Dao-->
    <bean id="employeeDao" class="com.imooc.spring.jdbc.dao.EmployeeDao">
        <property name="jdbcTemplate" ref="jdbcTemplate"/>
    </bean>
	<!--IoC: Service-->
    <bean id="employeeService" class="com.imooc.spring.jdbc.service.EmployeeService">
        <property name="employeeDao" ref="employeeDao"/>
    </bean>
    <!--第一步: IoC: 事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!--第二步: 事务通知配置-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="batchImport" propagation="REQUIRED"/>
			<tx:method name="batch*" propagation="REQUIRED"/>  <!--使用通配符*来匹配多个方法-->
			<tx:method name="find*" propagation="NOT-SUPPORTED" read-only="true"/> <!--表示对该类方法不使用事务-->
			<tx:method name="*" propagation="REQUIRED"/> <!--其他方法-->
        </tx:attributes>
    </tx:advice>
    <!--第三步: 定义声明式事务的作用范围-->
    <aop:config>
        <aop:pointcut id="pointcut" expression="execution(* com.imooc..*Service.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut"/>
    </aop:config>
</beans>
7, 事务传播方式
1)事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式;
2)配置方式
XML: <tx:method name="..." propagation="REQUIRED"/>
注解: @Transactional(propagation=Propagation.REQUIRED)
3)事务传播的七种类型
事务传播有七种类型, 80%以上的场景都使用默认的"REQUIRED";
REQUIRED(默认): f1(f2, f3), 以f1的事务来运行, f2和f3要么都完成, 要么都不完成;
REQUIRES_NEW: f1(f2, f3), f2和f3的事务独立运行;
NOT_SUPPORTED: 以非事务方式运行, 一般用于查询操作;
8, 注解配置声明式事务
//applicationContext.xml中的配置
<!--省略: DataSource数据源、IoC:jdbcTemplate, IoC:事务管理器-->
<Context:component-scan base-package="com.imooc"/>  <!--开启组件扫描-->
<tx:annotation-driven transaction-manager="transactionManager"/>  <!--启用注解形式声明式事务-->
//Service
@Service
@Transactional
public class EmployeeService{
	@Resource
	private EmployeeDao employeeDao;
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void importJob1(){
		//....
	}
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	public void importJob2(){
		//....
	}
}
注: @Transactional注解放在类上, 表示将声明式事务应用于该类的所有方法, 默认事务传播为REQUIRED;
放在方法上, 表示仅适用于该方法; 方法注解覆盖类注解;


>>Spring MVC
1, idea中将普通maven工程配置成web工程的步骤
1)File -> Project Structure -> Facets -> + -> 在右边的配置面板将两个目录设置为: 
	E:\java\workspace\test\src\main\webapp\WEB-INF\web.xml 与
	E:\java\workspace\test\src\main\webapp;
2)Edit Configuration -> + -> Tomcat Server -> 右边的配置面板进行相关配置;
2, Spring MVC的配置步骤
1)maven中引入spring-webmvc依赖
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-webmvc</artifactId>
	<version>5.1.9.RELEASE</version>
</dependency>
2)web.xml配置DispatcherServlet
<servlet>
	<servlet-name>springmvc</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<!--在IoC容器启动时要加载的配置文件-->
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext.xml</param-value>
	</init-param>
	<load-on-startup>0</load-on-startup> 
</servlet>
<servlet-mapping>
	<servlet-name>springmvc</servlet-name>
	<url-pattern>/</url-pattern>
</servlet-mapping>
注: DispatcherServlet是Spring MVC最核心的对象, 用于拦截http请求, 并根据请求的url调用与之对应的controller方法;
配置load-on-startup是在web应用启动时自动创建Spring IoC容器, 并初始化DispatcherServlet, 如果不设置load-on-startup, 则在第一次请求url时初始化DispatcherServlet;
<url-pattern>/</url-pattern>会匹配到/login这样的路径型url, 不会匹配到*.jsp这样的后缀型url;
<url-pattern>/*</url-pattern>会匹配到当前文件夹下所有的路径型url与后缀型url;
一般情况下DispatcherServlet只需要处理后台服务器的请求, 不需要处理静态页面, 所以, 建议使用/;
3)applictionContext配置mvc标记

4)开发Controller控制器


















