>>Go的特点
静态类型、编译型语言、开源;
脚本化的语法;
运行效率高, 开发高效, 部署简单;
原生支持并发;


>>Go的应用
服务器编程, 如处理日志、数据打包、虚拟机处理、文件系统等;
分布式系统, 如数据库代理器、中间件等;
网络编程, 如Web应用、API应用等;
云平台;


>>Go语言命令行工具
1, go build
将源码文件(.go)编译成可执行文件(.exe);
2, go run
编译并运行源码文件(.go);
3, go install
用于编译并安装代码包或源码文件;
安装代码包会在当前工作区的pkg/<平台相关目录>下生成归档文件;
安装命令源码文件会在当前工作区的bin目录下生成可执行文件;
4, go get
用来动态获取远程代码包;
5, go env
查看go的环境变量;


>>go get 从github下载内容失败的解决方案
修改代理环境变量:
go env -w GOPROXY=https://goproxy.cn,direct


>>go.mod file not found的解决方案
1, 开启go modules功能
在命令行输入: go env -w GO111MODULE=on
初始化Go module
进入项目目录输入: go mod init [xxx]  //xxx代表文件夹名, 如test
2, 直接在项目目录下新建go.mod文件
//go.mod
module test
go 1.18


//类型声明与类型别名
1)类型声明
type A int
var i A = 5
fmt.Printf("%T" i)  //main.A
2)类型别名
type A = int
var i A = 5
fmt.Printf("%T", i)  //int


>>Unicode与UTF-8
Unicode是字符集, 也就是给每个字符一个固定的编号, 字符集有ascii与Unicode;
而UTF-8是编码规则, 就是以某种形式对字符编号进行编码;


>>格式化输出
fmt.Printf("%s", s)
常用的格式符如下:
%d / %b / %o / %x(X): 整型的十进制 / 二进制 / 八进制 /十六进制;
%c / %s: 字符 / 字符串;
%f: 浮点数;
%p: 指针(十六进制方式显式);
%v: 按值的本来值输出;  //%+v 打印时会增加字段名
%T: 变量的类型;
%U: Unicode字符;


>>package
1, package声明必须放在第一行, 名称一般与目录名称一致;
要生成go语言可执行程序, 必须要有main的package包, 且该包下必须有main()函数;
同一个路径下只能存在一个package, 一个package可以拆成多个源文件;
2, 代码包的初始化函数: init();


>>import
1, 导入源码文件所依赖的包;
不得导入源码文件没有用到的包, 否则会报错;
2, 两种形式:
import "package1"
import "package2"
或
import (
	"fmt"
	"test/sub1"
	"test/sub2"
)
3, 如果一个包被多次导入, 只导入一次;
4, 导入包和main包的执行顺序
main包依赖包B, 包B依赖包A:
A中常量初始化 -> A中变量初始化 -> 执行A中init()函数 ->
B中常量初始化 -> B中变量初始化 -> 执行B中init()函数 ->
main中常量初始化 -> main中变量初始化 -> 执行main中init()函数 -> 执行main()函数;
5, 导入的包起别名
import my "test/sub1"
6, 导入的包加_
import _ "test/sub1", 表示仅执行导入包中的init()函数, 而不能调用其中的函数;
常用来注册包里的引擎;
7, 导入的包加.
import . "test/sub1", 调用其中的函数时可以省略包名, 不推荐;
8, 举例
package main
import (
	"fmt"
	"test/sub1"
	my "test/sub2"
)
func init(){
	fmt.Println("main.init()")
}
func main(){
	sub1.A()
	my.B()
	fmt.Println("main.main()")
}


>>数据类型
1, 数值类型
1)整型
int8, int16, int32, int64, uint8, uint16, uint32, uint64
2)浮点类型
float32, float64
3)复数类型
complex64, complex128
4)其他
byte(=uint8), int(=int32或int64), uint(=uint32或uint64),
rune(=int32), uintptr(无符号整型, 用于存放一个指针)
注: byte可表示一个ascii字符, 如 
var ch byte = 65 或 var ch byte = '\x41';
2, 布尔类型
bool
3, 字符串类型(编码统一为"UTF-8")
string
注: 使用reflect.TypeOf(a)可以得到a的数据类型;
使用unsafe.Sizeof(a)可以得到变量a所占的字节数; 
布尔类型占1个子节, 字符串类型占4个子节;
声明基本类型时未初始化, 则默认为类型零值;
4, 派生类型
指针类型(Pointer),
数组类型,
结构化类型(struct),
Channel类型(chan),
函数类型(func),
切片类型(slice),
接口类型(interface),
Map类型(map)


>>字符串
1, go中的字符串是不可变的字节序列, 字符串统一使用UTF-8编码;
2, 可使用``来定义多行字符串, 里面的内容原样输出, 如转义符失效;
3, 字符串的长度
s := "胡c"
len(s)  //4, 字节数
utf8.RuneCountInString(s)  //2, 字符数
4, 遍历每一个字符
ascii字符串遍历直接使用下标, Unicode字符串遍历使用for...range;
1)遍历英文字符串
s := "hello"
for i := 0; i < len(s); i++ {
	fmt.Printf("%c: %d\n", s[i], s[i])
}
2)遍历Unicode字符
s := "赵a钱b孙c"
for _, v := range s {
	fmt.Printf("%c: %d\n", v, v)
}
5, 查找子串出现的位置
s := "hello world"
strings.Index(s, "o")  //4
strings.LastIndex(s, "o")  //7
注: 查找的位置索引是子节位置, 如果不存在则返回-1
6, 字符串的不可变性
如果要修改字符串, 需要先将字符串转换为[]byte;
s := "hello"
bs := []byte(s)
bs[2] = '*';
newS := string(bs)


>>变量
1, 变量声明
1)同一行声明多个变量和赋值
var a, b, c int = 1, 2, 3 或 a, b, c := 1, 2, 3
注: 声明变量时可以省略类型, go语言会自动推断;
注: 全局变量的声明必须使用var, 局部变量可以省略;
像 a := 3 的方式只能用在函数体内作为局部变量;
2)变量可以分组声明
var (
	a int,
	b bool,
	c string = "hello"
)
3)匿名变量 _
_变量相当于垃圾桶, 给其赋值相当于丢弃, 如 a, _, b := 1, 2.0, "hello";
2, Go中不存在隐式转换, 类型转换必须是显式的, 如 b := float32(a);
3, 变量的可见性规则
大写字母开头的变量是公有变量, 即其他包可以读取;
小写字母开头的变量是私有变量;

>>两数交换
a, b = b, a


>>常量
1, 常量初始化
const NATION string = "中国" (显式),
const NATION = "CHINA" (隐式, 也叫无类型常量)
常量也可以通过内置函数来定义(只能通过内置函数, 使用自定义函数会报错):
const a, b = len(NATION), reflect.TypeOf(NATION)
2, 特殊常量iota
iota在第一次遇到const时为0, 以后每次加1;
const (
	a = iota  //0
	b = iota * 2  //2
	c = iota  //3
)
注: iota只能被赋值给常量, 不能在其他地方使用;


>>模拟枚举
go语言中没有枚举类型, 可以模拟枚举:
type Fruit int
const (
	Apple Fruit = iota
	Orange
	Banana
)
当类型需要显式为字符串时, go语言会自动寻找String()方法进行调用;
func (f Fruit) String() string {
	switch f {
		case Apple:
			return "Apple"
		case Orange:
			return "Orange"
		case Banana:
			return "Banana"
	}
	return "NONE"
}
fmt.Printf("%T, %d, %s", Apple, Apple, Apple)


>>运算符
算术运算符、关系运算符、逻辑运算符、赋值运算符、按位运算符;
注: go语言中只有后置自增自减, 没有前置自增自减;


>>控制语句
1, 条件语句
1)if, else, if else
go语言中没有elseif语句;
2)switch
switch语句分为表达式switch和类型switch;
2, 循环语句
go语言中的循环语句只有一种, 就是for;
1)基本语法
for i:=1; i<=10; i++ {
	fmt.Println("hello")
	time.Sleep(1*time.Second)
}
2)for { //... }
相当于 for true { //... }
3)遍历
a := []string{"苹果", "香蕉", "例子"}
for key,value := range a {
	fmt.Println(key, value)
}
for _, value := range a {
	fmt.Println(key, value)
}
3, goto, break, continue
1)goto
goto One
fmt.Println("中间代码块")
One:
	fmt.Println("this is One")
2)break用于结束当前循环; 
continue用于进入循环的下一个计数;
break后跟标签, 比如可以跳出最外层循环:
outerLoop:
	for i := 0; i < 10; i++ {
		for j := 0; j <= i; j++ {
			if j == 5 {
				break outerLoop
			}
		}
	}



>>数组
1, 数组定义
var a = [3]int{2, 4, 6}
len(a)  //数组的长度
注: 如果只声明一个数组而没有赋值, 则数组元素默认为类型的零值;
a := [3]int{1, 2}  //[1, 2, 0]
a := [...]int{1, 2, 3}
a := [3]int{1: 5, 2: 8}  //[0, 5, 8]
2, 比较两个数组是否相等
使用 == 或 != 来比较两个数组是否相等, 只能同类型的数组比较;
a := [3]int{1, 2}
b := [...]int{1, 2, 0}
a == b  //true
3, 遍历数组
for k, v := range a {
	//...
}
4, 数组是值类型
a := [3]int{1, 2, 3}
b := a  //数组可以直接赋值
b[1] = 888
a  //{1, 2, 3}
5, 多维数组
a := [2][3]int{{1, 2, 3}, {3, 4, 5}}
a := [2][3]int{1: {3, 4, 5}}
a := [2][3]int{1: {0: 3, 1: 4, 2: 5}}


>>切片
go语言中, 数组是值类型, 而切片是引用类型, 切片的名称相当于一个指针;
1, 声明切片
var strList []string  //strList == nil 为 true
var iList []int
var iList = []int{}  //空切片, iList == nil 为false
a := make([]int, 2, 10)  //动态构造切片, 指定切片类型、大小和容量
注: 使用make来定义切片是重新分配内存区域, 而使用a[m:n]这种操作并不分配内存, 而是将切片指向原来的底层数组或底层切片;
2, 每个切片都有一个底层数组;
a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
b := a[3:6}  //[4, 5, 6]
c := b[1:cap(b)]  //[5, 6, 7, 8, 9, 10]
a[:5]  //从开始位置切
a[3:]  //一直到结束位置
a[:]   //整个切
b[0:0]  //将切片置为空: []
len(b)  //长度: 3
cap(b)  //容量: 7
reflect.TypeOf(a)  //[10]int
reflect.TypeOf(b)  //[]int
b := a[min:max:bound]  //第三个参数表示切片容量不超过bound下标的位置
注: 修改切片的元素会同时修改底层数组
3, 内置函数append
slice = append(slice, 22, 33, 44)
append新增元素可以超过原切片的容量, 会自动更换底层数组;
a := []int{1, 2}
a = append(a, 5, 6)  //向切片末尾添加元素 [1, 2, 5, 6]
a = append(a, []int{5, 6}...)  //以切片的方式添加 [1, 2, 5, 6]
a = append([]int{5, 6}, a...)  //向切片的开头添加 [5, 6, 1, 2]
a = append(a[:i], append([]int{999}, a[i:]...)...)  //在第i个位置插入999
注: append()函数的第一个参数必须是切片类型;
4, 内置函数copy
var c = []int{0, 0, 0}
copy(c, b)  //c复制b
按照较小个数的那个切片进行复制, 返回实际复制的元素个数;
注: 整体赋值与copy的区别: 
整体赋值是浅复制, 改变一个切片会影响到另一个;
而copy是深复制, 改变一个切片不会影响到另一个;
5, 删除切片中的元素
go语言中没有直接删除元素的方法;
//删除前n个元素
a = a[n:]
//删除后n个元素
a = a[:len(a)-n]
//删除中间index索引的元素
a = append(a[:index], a[index+1:]...)


>>Map
1, Map的基本操作
emps := map[string]int{"zhao": 30, "qian": 26, "sun": 28}
a := emps["zhao"]
a, ok := emps["zhao"]  //ok为false表示key不存在
emps["cao"] = 88  //向map中添加键值对, 无则添加, 有则修改
delete(emps, "cao")  //删除键值对, 无key也不会报错
注: value可以为复杂类型, 如切片 a := make(map[string][]int)
2, 可以用for...range来遍历Map
for k, v := a {
	fmt.Printf("%s: %d\n", k, v)
}


>>通道Channel
1, Channel用于在不同Goroutine之间传递类型化的数据, 是并发安全的, 而其他数据类型都不是并发安全的;
chan T  //声明
ch1 := make(chan string, 5)  //声明通道类型的变量并为其赋值, 第二个参数表示通道的长度
ch1 <- "value1"  //向通道发送数据
value := <- ch1  //从通道接受数据
value, ok := <- ch1  //ok为false表示通道已关闭
close(ch1)  //关闭通道
注: 向已满通道发送数据, 或从空通道接受数据, 都会引起阻塞;
2, 缓冲通道与非缓冲通道
ch := make(chan string, 5)  //缓冲通道
ch := make(chan string, 0)  //非缓冲通道
3, 双向通道, 发送通道, 接受通道
ch := make(chan int, 5)  //双向通道
type Receiver <- chan int  //接受通道
var receiver Receiver = make(chan int, 5)
type Sender chan <- int  //发送通道
var sender Sender = make(chan int, 5)


>>函数
1, 函数定义
func fn(a int, b int) int { return a + b }
func fn(a int, b int) (r int) { 
	r = a + b
	return 
}
func fn(a int, b int) (c int, d int){ //返回多个结果
	c = a + b
	d = a - b
	return 
}
2, 匿名函数
//将匿名函数赋值给变量
var f1 = func(a int, b int) int {
	return a + b
}
//匿名函数直接调用
var r = func(a int, b int) int {
	return a + b
}(4, 6)
3, 闭包
func Accumulate(value int) func() int {
	return func() int {
		value++
		return value
	}
}
accumulate := Accumulate(1)
accumulate()  //2
accumulate()  //3
4, 可变参数
可变参数变量是一个包含所有参数的切片;
func fn(args ...interface{}) {  //args的类型为: []interface{}
	for _, v := range args {
		fmt.Printf("%T, %v\n", v, v)
	}
}
调用:
1)扁平化传递多个参数
fn(6, "hello", 2.0, true, Person{"zhao", 30})
2)传递切片, 需要在切片后面添加...
param := []interface{}{6, "hello", 2.0, true, Person{"zhao", 30}}
fn(param...)
注: 传递param表示传递的是param变量本身, 而param...表示将切片内容拆开成扁平化的多个元素;


>>结构体
1, 实例化
结构体的定义只是一种内存布局的描述, 只有当实例化时, 才会真正分配内存;
//基本的实例化形式
type Point struct {  //定义
	X, Y int
}
var p Point  //实例化  {0, 0}
p.X = 2
p.Y = 6
2, 结构体指针
p := new(Point)  //类型: *main.Point
p.X = 2  //指针类型仍然可以像普通类型一样使用.来访问成员
p.Y = 6  //底层自动转换 (*p).Y
p2 := &Point{}  //取地址实例化
p2 := &p1 
注: 取地址实例化是最广泛的一种结构体实例化方式;
3, 初始化
1)使用键值对形式
type People struct {
	name string
	child *People
}
relation := &People{
	name: "爷爷",
	child: &People{
		name: "爸爸",
		child: &People{
			name: "我",
		},
	}
}
注: 结构体成员中只能包含本结构体的指针类型, 非指针类型则报错;
2)使用列表形式
p1 := Point{2, 4}
使用列表形式必须初始化所有字段, 且顺序一致;
4, 匿名结构体
ins := struct {
	字段1 类型1
	字段2 类型2
}
msg := &struct {  //定义部分
	id int 
	data string 
}{  //值初始化部分
	1024, 
	"hello",
}
5, 嵌入结构体
type Person struct {
	Name string
	Age int
}
type Student struct {
	Person
	Major string
}
s1 := Student{
	Person{"zhao", 26},
	"Maths",
}
var s2 Student  //实例化Student也会自动实例化Person: {{"", 0}, ""}
s2.Name = "qian"
s2.Age = 28
s2.Major = "Maths"
fmt.Printf("%T, %v", s1, s1)  //main.Student, {{"zhao", 26}, "Maths"}
6, 模拟构造函数重载
go语言没有提供构造函数相关的机制, 用户根据需求将参数使用函数传递给结构体;
type Cat struct {
	Color string
	Name string
}
func NewCatByName(name string) *Cat {
	return &Cat{
		Name: name
	}
}
func newCatByColor(color string) *Cat {
	return &Cat{
		Color: color
	}
}
7, 方法
go的方法是作用在接收器上的一个函数;
接收器可以是任何类型(除了接口类型), 也就是说任何类型都可以定义方法, 比如基本类型的别名类型、函数类型等;
接收器分为指针类型接收器和非指针类型接收器, 区别在于是否能修改结构体的字段;
8, 为任意类型添加方法
type MyInt int
func (m MyInt) IsZero() bool {
	return m == 0
}
func (m MyInt) Add(other int) int {
	return other + int(m)
}
9, 继承: 内嵌结构体
1)结构体可以包含匿名字段, 即只有字段的类型, 此时类型就可以当名字使用;
Go语言没有继承, 可以通过结构体的内嵌或组合来模拟继承;
type innerS struct {
	in1 int
	in2 int
}
type outerS struct {
	a int
	b float32
	int
	innerS
}
func main() {
	o1 := new(outerS)
	o1.b = 2.1
	o.int = 3
	o.in1 = 6
	o.in2 = 8
	o2 := outerS{1, 2.0, 5, interS{6, 8}}
}
注: 访问内嵌结构体的字段, 可以使用详细的字段进行一层层访问, 也可以直接访问, 如 o.innerS.in1, 或 o.in1;
2)使用内嵌结构体模拟继承
type Walking struct{}
func (w *Walking) Walk(){
	fmt.Println("I can walk")
}
type Flying struct{}
func (f *Flying) Fly(){
	fmt.Println("I can fly")
}
//通过组合来实现继承关系
type Bird struct {
	Walking
	Flying
}
int main() {
	b := new(Bird)
	b.Walk()
	b.Fly()
}


>>接口
1, 如果一个任意类型T的方法集为一个接口类型的方法集的超集, 则称类型T实现了此接口类型;
type Walker interface{
	Walk() error
}
type Person struct {}
func (p Person) Walk() error {
	fmt.Println("Person can walk")
	return nil
}
var walker Walker = Person{}
walker.Walk()
当一个类型实现了接口, 就可以把该类型变量赋值给接口类型的变量;
注: Go语言中实现接口是隐式的, 叫做非侵入式设计; 
2, 可以通过本类型和嵌入的类型来共同实现一个接口, 避免代码冗余;
type Service interface {  //定义接口
	Start()
	Log(string)
}
type Logger struct {}  //Logger实现接口的Log()方法
func (g *Logger) Log(s string) {}
type GameService struct {  //GameService实现接口的Start()方法, 同时通过内嵌Logger类型实现Log()方法
	Logger
}
func (g *GameService) Start() {}
var s Service = new(GameService)
s.Start()
s.Log("hello")
3, nil
nil只能被赋值给指针或者接口;
只有显式地将nil赋值给接口时, 接口才等于nil, 如
var w *Walker = nil
w == nil  //true
如果不是显式的将nil赋值给接口, 那么接口将不等于nil, 如
var p *Person = nil  
var w Walker = p  //*Person实现了Walker接口
p == nil  //false
4, 类型断言
1)x.(T)
var x interface{} = 10
value, ok := x.(int)  //10 true
value, ok := x.(string)  // "" false
2)x.(type)
只能用于switch结构中;
switch x.(type) {
	case int:
		//...
	case string: 
		//...
	default:
		//...
}
5, 接口的嵌套
type Writer interface {
	Write(p []byte) (n int, err error)
}
type Closer interface {
	Close() error
}
type WriteCloser interface {
	Writer
	Closer
}
如果一个类型同时实现了Writer和Closer接口, 则表示该类型实现了WriteCloser接口;


>>指针
1, 声明指针变量, 默认为nil, 而通过new()得到的指针变量, 其指向一块内存区域, 所以不等于nil;
var p *int  //p == nil
var p = new(int)  //p != nil
2, go语言中的指针不能进行算术运算;


>>字符串和其他类型的转换
1, 字符串与整型的转换
//整型->字符串
i := 10
s := strconv.Itoa(i)
//字符串->整型
s := "10"
i, err := strconv.Atoi(s)  //err不为nil表示转换失败
2, Parse系列用于将字符串转换成其他基本类型
b, err := strconv.ParseBool(s)  //string->bool
i, err := strconv.ParseInt(s, base, bitSize)  //string->int
i, err := strconv.ParseUint(s, base, bitSize)  //string->uint
f, err := strconv.ParseFloat(s, bitSize)  //string->float32/float64
3, Format系列用于将其他基本类型转换成字符串
strconv.FormatBool(), strconv.FormatInt(), strconv.FormatUint(), strconv.FormatFloat()分别
用于将布尔类型、整型、无符号整型、字符型等转换成字符串;


>>sync.Map
线程安全的Map
var m sync.Map  //无须初始化, 直接使用, sync.Map不能使用make()创建
m.Store("zhao", 30)  //保存键值对, 键和值都以interface{}类型保存
m.Load("zhao")  //取值
m.Delete("zhao")  //删除对应的键值对
m.Range(func(k, v interface{}) bool {  //遍历, 使用回调函数
	fmt.Println(k, v)
	return true  //返回true则继续下一次迭代, false则立即结束
})  
注: sync.Map比Map有一些性能损失, 所以在非并发情况下, 应该使用Map;


>>列表List
列表是链表实现, 其中保存的元素类型可以不同;
//初始化列表
var m list.List
或者 m := list.New()
//插入元素
m.PushBack("canon")  //尾部添加
m.PushFront(67)  //头部添加
elem := m.pushBack("fist")  //尾部添加并返回元素指针
m.InsertAfter("high", elem)  //在元素elem之后添加
m.InsertBefore("noon", elem)  //在元素elem之前添加
m.Remove(elem)  //删除elem元素
//遍历列表
for i := m.Front(); i != nil; i = i.Next() {
	fmt.Println(i.Value)
}


>>defer
1, defer语句在函数结束或程序异常退出时执行, 当有多个defer语句时, 后面的先执行;
//例: 延迟并发解锁
var (
	values = make(map[string]int)
	lock sync.Mutex  //互斥锁
)
func readValue(key string) int {
	lock.Lock()
	defer lock.Unlock()
	return values[key]
}


>>错误处理
go语言没有像类似java语言中的异常处理机制, 而是在函数中返回一个错误接口error, 调用者须对这个返回值是否等于nil进行判断;
1, error接口
type error interface {
	Error() string
}
2, 自定义一个错误
var err = errors.New("this is an error")
//例: 自定义除数为0的错误
var myerr = errors.New("这是除数为零的错误")
func div(a, b int) (int, error) {
	if b == 0 {
		return 0, myerr
	}
	return a / b, nil
}
func main() {
	fmt.Println(div(1, 0))  //0 这是除数为零的错误
}


>>异常处理: 宕机(panic)与恢复(recover)
1, 有些错误只能在运行时才能被检查, 如数组越界、空指针引用等, 这些运行时错误会引起宕机;
2, 手动触发宕机
panic("crash")
3, 在宕机时触发延迟执行语句
func main() {
	defer fmt.Println("宕机前要做的事情1")
	defer fmt.Println("宕机前要做的事情2")
	panic("宕机")
}
//输出如下
宕机后要做的事情2
宕机后要做的事情1
panic: 宕机	
4, panic相当于throw, recover相当于catch


>>通过内存缓存来提升性能
1, 普通的斐波那契数列生成
func fibonacci(n int) (res int) {
	if n == 1 || n == 2 {
		res = 1
	} else {
		res = fibonacci(n-1) + fibonacci(n-2)
	}
	return
}
2, 通过内存缓存改进后的斐波那契生成
const LIMIT = 100
var cache [LIMIT]uint64
func fibonacci(n int) (res int) {
	if cache[n] != 0 {  //检查数组中是否已知斐波那契n
		res = cache[n]
		return 
	}
	if n == 1 || n == 2 {
		res = 1
	} else {
		res = fibonacci(n-1) + fibonacci(n-2)
	}
	cache[n] = res  //将生成的斐波那契n保存到数组
	return
}
注: 优化后的性能提升无数倍;


>>json
go语言中json的序列化和反序列化需要通过[]byte类型来中转;
1, json.Marsha1()  //序列化
type Person struct {
	Name string
	Age int `json:"age"`
}
p := Person{"zhao", 30,}
temp, err := json.Marsha1(p)  //temp是[]byte类型
s := string(temp)  //json串
注: `json:"age"`表示序列化json时给字段换一个名字;
`json:""`标签(Tag)的使用有以下几点:
1)FieldName int `json:"myName"`): 表示在json串里使用myName作为键名;
2)FieldName int `json:"myName,omitempty"`: 表示在json串里使用myName作为键名, 如果该字段为空则省略;
3)FieldName int `json:",omitempty"`: 表示使用默认键名, 如果该字段为空则省略;
4)FieldName int `json:"-"`: 表示在json串忽略该字段;
2, json.Unmarsha1()  //反序列化
s := `{"Name": "zhao", "Age": 30}`
ptr := new(Person)
err := json.Unmarsha1([]byte(s), ptr)  //ptr就是指向对象的指针


>>排序
1, 自定义排序
需要自定义类型来实现sort.Interface接口, 需要实现三个方法:
type MyStringList []string
func (m MyStringList) Len() int { 
	return len(m)
}
func (m MyStringList) Less(i, j int) bool {
	return m[i] < m[j]
}
func (m MyStringList) Swap(i, j int) {
	m[i], m[j] = m[j], m[i]
}
names := MyStringList{"java", "go", "python", "js", "c++", "php",}
sort.Sort(names)  //通过sort.Sort()函数来对切片序列进行排序
2 常见基本类型的快速排序
1)字符串的排序
方式一:
names := sort.StringSlice{"java", "go", "python", "js", "c++", "php",}  //字符串切片
sort.Sort(names)
方式二: 
直接使用sort.Strings(names)对字符串切片进行排序;
names := []string{  //直接定义字符串切片
	//...
}
sort.Strings(names)
2)整型的排序
使用sort.IntSlice整型切片然后sort.Sort(), 或者使用sort.Ints()快速排序;
3)浮点数的排序
使用sort.Float64Slice浮点切片然后sort.Sort(), 或者使用sort.Float64s()快速排序;
3, 对结构体切片进行排序
1)自定义排序规则
type Hero struct{
	Name string
	King int
}
type Heros []*Hero 
然后让Heros实现sort.Interface接口;
names := Heros{
	//...
}
sort.Sort(names)
2)快速排序 sort.Slice()
函数原型如下:
func Slice(slice interface{}, less func(i, j int) bool)
使用:
sort.Slice(heros, func(i, j int) bool{
	if heros[i].Kind != heros[j].Kind {
		return heros[i].Kind < heros[j].Kind
	}
	return heros[i].Name < heros[j].Name
})


>>内建方法
1, make与new
用于创建slice、map、chan这三种类型, 返回类型的引用;
1)创建切片
s := make([]int, 3)
s := make([]int, 3, 10)
s[0] = 2
s[1] = 4
s[2] = 6
fmt.Printf("%T, %v", s, s)  //[]int, [2, 4, 6]
注: make切片时必须传入第二个参数指明切片的长度, 可选的第三个参数表示初始容量;
2)创建map
m := make(map[string]int)
m["zhao"] = 26
m["qian"] = 22
m["sun"] = 25
fmt.Printf("%T, %v")  //map[string]int, map[qian:22, sun:25, zhao:26]
3)创建channel
ch := make(chan int)  //没有缓存的chan
ch := make(chan int, 3)  //缓存数量为3的chan
4)new
返回指定类型的指针, 可以给任意类型分配内存;
2, append, copy, delete
append与copy应用于slice, 而delete应用于map;
1)append
s := make([]int, 3)
s = append(s, 1)
s = append(s, 6, 7, 8)  //s: [0, 0, 0, 1, 6, 7, 8]
2)copy
a := []int{1, 2, 3}
b1 := make([]int, 2)
copy(b1, a)  //b1: [1, 2]
b2 := make([]int, 4)
copy(b2, a)  //b2: [1, 2, 3, 0]
3)delete
m := map[string]int{"zhao": 24, "qian": 26, "sun": 22,}
delete(m, "qian")  //m: map[zhao:24, sun:22]
3, panic与recover
相当于抛出异常与捕获异常;
func f1() {  //手动触发panic
	fmt.Println("enter f1")
	panic(errors.New("occur a panic"))
	fmt.Println("quit f2")
}	
func f2() {  //宕机恢复
	if p := recover(); p != nil {
		fmt.Printf("Fatal error: %s\n", p)
	}
}
func main() {
	defer f2()
	fmt.Println("enter main")
	f1()
	fmt.Println("quit main")
}
输出如下:
enter main
enter f1
Fatal error: occur a panic
注: defer f2()一定要放在panic()前面, 否则执行不到recover()程序就崩溃了;
4, len, cap, close
len用于string, array, slice, map, chan这几种类型;
cap用于array, slice, chan这几种类型;
close只用于chan类型;
s := make([]int, 3, 10)  //len(s): 3, cap(s): 10
ch := make(chan int, 4)  //len(ch): 0, cap(ch): 4
defer close(ch)


>>并发
协程(goroutine) + 协程间通信(channel) + 协程同步(sync.waitgroup)
1, 协程
func main() {
	go f1()
	go f2()
	time.Sleep(time.Second)  //主程序结束前有足够时间让协程执行完毕
}
2, 协程间通信--channel
1)多个协程之间通过channel通信;
2)select
select语句中的case关键字只能后跟通道的发送或者接收操作;
ch1 := make(chan int, 2)
ch2 := make(chan string, 1)
ch1 <- 2
ch1 <- 6
ch2 <- "zhao"
for {
	select {
		case n := <- ch1:
			fmt.Println("ch1: ", n)
		case n := <- ch2:
			fmt.Println("ch2: ", n)
		default:
			fmt.Println("通道里已没有数据")
	}
}
注: 如果当前多个通道有数据, select会随机选择一个通道case执行;
e, ok := <- ch  //如果ch没数据则阻塞, 如果ch已关闭则ok为false;
3, 协程同步
主协程等待其他协程执行完再结束: 系统工具 sync.WaitGroup
Add(delta int)  //添加计数
Done()  //移除一个计数, 等价于Add(-1)
Wait()  //阻塞直到所有任务完成
举例:
var wg sync.WaitGroup
func tast(i int) {
	//defer wg.Done()
	fmt.Println("task...", i)
	//...
	wg.Done()
}
func main() {
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go task(i)
	}
	wg.Wait()
}
4, 举例
1)模拟多个顾客抢购鸡蛋
func main() {
	var wg sync.WaitGroup
	var ch = make(chan int, 10)  
	for i := 1; i <= 10; i++ {  //将10个鸡蛋放入channel
		ch <- i
	}
	for i := 1; i <= 100; i++ {  //100个顾客并发抢购鸡蛋
		wg.Add(1)
		go func(n int) {  //单个抢鸡蛋的协程
			select {
				case egg := <- ch:
					fmt.Printf("第%d个顾客抢到第%d个鸡蛋\n", n, egg)
				default:
					fmt.Printf("当前第%d个顾客, 鸡蛋已抢完\n", n)
			}
			wg.Done()
		}(i)
	}
	wg.Wait()
}
2)生产者-消费者
var chan = make(chan int, 10)
func producer(n int) {  //生产者
	ch <- n
	fmt.Println("生产:", n)
}
func consumer() {  //消费者
	fmt.Println("消费:", <- ch)
}
func main() {
	for i := 1; i <= 10; i++ {
		go producer(i)
		go consumer()
	}
}


>>go module(go的模块与依赖管理)






















