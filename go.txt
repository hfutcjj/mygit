>>Go的特点
静态类型、编译型语言、开源;
脚本化的语法;
运行效率高, 开发高效, 部署简单;
原生支持并发;


>>Go的应用
服务器编程, 如处理日志、数据打包、虚拟机处理、文件系统等;
分布式系统, 如数据库代理器、中间件等;
网络编程, 如Web应用、API应用等;
云平台;


>>Go语言命令行工具
1, go build
将源码文件(.go)编译成可执行文件(.exe);
2, go run
编译并运行源码文件(.go);
3, go get
用来动态获取远程代码包;
4, go env
查看go的环境变量;


>>linux下安装go
1, 安装
进入官网下载.gar.gz安装包, 解压缩到/usr/local目录下:
tar -zxf go1.18.1.linux-amd64.tar.gz -C /usr/local
解压后得到go目录, 命令行进入go目录, 输入bin/go version, 显式版本号则安装成功;
2, 设置
4个环境变量需要设置: PATH, GOROOT, GOPATH, GOBIN;
需要设置到某一个profile文件中(/etc/profile或~/.bash_profile);
export GOROOT=/usr/local/go
export GOPATH=~/golib:~/goproject
export GOBIN=~/gobin
export PATH=$PATH:$GOROOT/bin:$GOBIN


>>基本结构
package main  //程序所属包
import "fmt"  //导入依赖包
const NATION string = "CHINA"  //常量定义
var name string = "imooc"  //全局变量的声明与赋值
type imoocInt int  //一般类型声明
type Person struct {  //结构声明
}
type IWalk interface {  //接口声明
}
func say(){  //函数定义
	fmt.Println("hello bing")
}
func main(){  //入口函数
	fmt.Println("this is first demo")
}


>>package
1, package声明必须放在第一行, 名称一般与目录名称一致;
要生成go语言可执行程序, 必须要有main的package包, 且该包下必须有main()函数;
同一个路径下只能存在一个package, 一个package可以拆成多个源文件;
2, 代码包的初始化函数: init();


>>import
1, 导入源码文件所依赖的包;
不得导入源码文件没有用到的包, 否则会报错;
2, 两种形式:
import "package1"
import "package2"
或
import (
	"fmt"
	"test/sub1"
	"test/sub2"
)
3, 如果一个包被多次导入, 只导入一次;
4, 导入包和main包的执行顺序
main包依赖包B, 包B依赖包A:
A中常量初始化 -> A中变量初始化 -> 执行A中init()函数 ->
B中常量初始化 -> B中变量初始化 -> 执行B中init()函数 ->
main中常量初始化 -> main中变量初始化 -> 执行main中init()函数 -> 执行main()函数;
5, 导入的包起别名
import my "test/sub1"
6, 导入的包加_
import _ "test/sub1", 表示仅执行导入包中的init()函数, 而不能调用其中的函数;
常用来注册包里的引擎;
7, 导入的包加.
import . "test/sub1", 调用其中的函数时可以省略包名, 不推荐;
8, 举例
package main
import (
	"fmt"
	"test/sub1"
	my "test/sub2"
)
func init(){
	fmt.Println("main.init()")
}
func main(){
	sub1.A()
	my.B()
	fmt.Println("main.main()")
}


>>数据类型
1, 数值类型
1)整型
int8, int16, int32, int64, uint8, uint16, uint32, uint64
2)浮点类型
float32, float64
3)复数类型
complex64, complex128
4)其他
byte(=uint8), int(=int32或int64), uint(=uint32或uint64),
rune(=int32), uintptr(无符号整型, 用于存放一个指针)
2, 布尔类型
bool
3, 字符串类型(编码统一为"UTF-8")
string
注: 使用reflect.TypeOf(a)可以得到a的数据类型;
使用unsafe.Sizeof(a)可以得到变量a所占的字节数; 
布尔类型占1个子节, 字符串类型占4个子节;
声明基本类型时未初始化, 则默认为类型零值;
4, 派生类型
指针类型(Pointer),
数组类型,
结构化类型(struct),
Channel类型(chan),
函数类型(func),
切片类型(slice),
接口类型(interface),
Mapl类型(map)


>>变量
1, 变量声明
1)同一行声明多个变量和赋值
var a, b, c int = 1, 2, 3 或 a, b, c := 1, 2, 3
注: 声明变量时可以省略类型, go语言会自动推断;
注: 全局变量的声明必须使用var, 局部变量可以省略;
像 a := 3 的方式只能用在函数体内作为局部变量;
2)变量可以分组声明
var (
	a int,
	b bool,
	c string = "hello"
)
3)特殊的变量"_"
_变量相当于垃圾桶, 给其赋值相当于丢弃, 如 a, _, b := 1, 2.0, "hello";
2, Go中不存在隐式转换, 类型转换必须是显式的, 如 b := float32(a);
3, 变量的可见性规则
大写字母开头的变量是公有变量, 即其他包可以读取;
小写字母开头的变量是私有变量;


>>常量
1, 常量初始化
const NATION string = "中国" (显式),
const NATION = "CHINA" (隐式, 也叫无类型常量)
常量也可以通过内置函数来定义(只能通过内置函数, 使用自定义函数会报错):
const a, b = len(NATION), reflect.TypeOf(NATION)
2, 特殊常量iota
iota在第一次遇到const时为0, 以后每次加1;
const (
	a = iota  //0
	b = iota * 2  //2
	c = iota  //3
)
注: iota只能被赋值给常量, 不能在其他地方使用;


>>运算符
算术运算符、关系运算符、逻辑运算符、赋值运算符、按位运算符;
注: go语言中只有后置自增自减, 没有前置自增自减;


>>控制语句
1, 条件语句
如判断变量的类型:
func main(){
	var a interface{}
	a = 2
	switch a.(type) {
		case int:
			fmt.Println("a为整型")
		case string:
			fmt.Println("a为字符串类型")
		default:
			fmt.Println("a为其他类型")
	}
}
注: go语言不需要使用break来中断case;
go语言没有elseif;
2, 循环语句
go语言中的循环语句只有一种, 就是for;
1)基本语法
for i:=1; i<=10; i++ {
	fmt.Println("hello")
	time.Sleep(1*time.Second)
}无法循环
2)for { //... }
相当于 for true { //... }
3)遍历
a := []string{"苹果", "香蕉", "例子"}
for key,value := range a {
	fmt.Println(key, value)
}
for _, value := range a {
	fmt.Println(key, value)
}
3, goto, break, continue
1)goto
goto One
fmt.Println("中间代码块")
One:
	fmt.Println("this is One")
2)break用于结束当前循环; continue用于进入循环的下一个计数;


>>引用类型
引用类型的零值为nil;
1, 数组
var a = [3]int{2, 4, 6}
len(a)  //数组的长度
注: 如果只声明一个数组而没有赋值, 则数组元素默认为类型的零值;
2, 切片
1)每个切片都有一个底层数组;
a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
b := a[3:6}  //[4, 5, 6]
c := b[1:cap(b)]  //[5, 6, 7, 8, 9, 10]
len(b)  //长度: 3
cap(b)  //容量: 7
reflect.TypeOf(a)  //[10]int
reflect.TypeOf(b)  //[]int
b := a[min:max:bound]  //第三个参数表示切片容量不超过bound下标的位置
2)内置函数append()
slice = append(slice, 22, 33, 44)
append新增元素可以超过原切片的容量, 会自动更换底层数组;
3)内置函数copy()
var c = []int{0, 0, 0}
copy(c, b)  //c复制b
3, 字典Map
emps := map[string]int{"zhao": 30, "qian": 26, "sun": 28}
a := emps["zhao"]
a, ok := emps["zhao"]  //ok为false表示key不存在
emps["cao"] = 88  //向map中添加键值对, 无则添加, 有则修改
delete(emps, "cao")  //删除键值对, 无key也不会报错
4, 通道Channel
1)Channel用于在不同Goroutine之间传递类型化的数据, 是并发安全的, 而其他数据类型都不是并发安全的;
chan T  //声明
ch1 := make(chan string, 5)  //声明通道类型的变量并为其赋值, 第二个参数表示通道的长度
ch1 <- "value1"  //向通道发送数据
value := <- ch1  //从通道接受数据
value, ok := <- ch1  //ok为false表示通道已关闭
close(ch1)  //关闭通道
注: 向已满通道发送数据, 或从空通道接受数据, 都会引起阻塞;
2)缓冲通道与非缓冲通道
ch := make(chan string, 5)  //缓冲通道
ch := make(chan string, 0)  //非缓冲通道
3)双向通道, 发送通道, 接受通道
ch := make(chan int, 5)  //双向通道
type Receiver <- chan int  //接受通道
var receiver Receiver = make(chan int, 5)
type Sender chan <- int  //发送通道
var sender Sender = make(chan int, 5)
4, 函数
1)函数定义
func fn(a int, b int) int { return a + b }
func fn(a int, b int) (r int) { 
	r = a + b
	return 
}
func fn(a int, b int) (c int, d int){ //返回多个结果
	c = a + b
	d = a - b
	return 
}
2)匿名函数
//将匿名函数赋值给变量
var f1 = func(a int, b int) int {
	return a + b
}
//匿名函数直接调用
var r = func(a int, b int) int {
	return a + b
}(4, 6)
5, 结构体
1)结构体的定义与赋值
type Person struct {
	Name string
	Age int
}
p1 := Person{Name: "zhao", Age: 30}
p2 := Person{"qian", 30}  //顺序相同且完全赋值可省略字段名
p3 := Person{Age: 30}  //省略的字段为零值
2)匿名结构体
p := struct {
	Name string
	Age int
}{"zhao", 30}
3)结构体的方法
func (person *Person) Grow() { //指针方法: 接收者类型是类型的指针
	person.Age++
}
func (person Person) Grow() {  //值方法: 接收者类型是类型本身
	person.Age++
}
p1 := Person{"zhao", 30}
p1.Grow()
注: 匿名结构体不能定义方法
4)结构体的零值并不是nil, 而是其所有字段均为零值, 如 Person{};
6, 接口
1)接口的定义
type Animal interface {
	Grow()
	Move(newAddr string) (oldAddr string)
}
2)实现接口
type Person struct {
	Name string
	Age int
	Address string
}
func (p *Person) Grow() {
	p.Age++
}
func (p *Person) (newAddr string) (oldAddr string) {
	oldAddr = p.Address
	p.Address = newAddr
	return
}
3)空接口
空接口: interface{}, 所以类型都可以看成是空接口的实现;







































