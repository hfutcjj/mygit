>>go的安装及开发工具
1, go语言下载安装后不需要配置环境变量, 以前的gopath模式改成go mod了, 所以代码
可以放在任何位置, 直接终端输入go run(运行) / go build(编译)即可;
cmd输入go version查看go的版本;
go env查看go的环境变量;
2, 下载vscode后安装汉化包扩展以及go语言扩展, 即可进行go语言开发;


>>认识的golang包
fmt, unsafe, reflect, strconv, strings, utf8, sort, 
		


>>Go语言命令行工具
1, go build
将源码文件(.go)编译成可执行文件(.exe);
2, go run
编译并运行源码文件(.go);
3, go install
用于编译并安装代码包或源码文件;
安装代码包会在当前工作区的pkg/<平台相关目录>下生成归档文件;
安装命令源码文件会在当前工作区的bin目录下生成可执行文件;
4, go get
用来动态获取远程代码包;
5, go env
查看go的环境变量;


>>go get 从github下载内容失败的解决方案
修改代理环境变量:
go env -w GOPROXY=https://goproxy.cn,direct


>>go.mod file not found的解决方案
1, 开启go modules功能
在命令行输入: go env -w GO111MODULE=on
初始化Go module
进入项目目录输入: go mod init [xxx]  //xxx代表文件夹名, 如test
2, 直接在项目目录下新建go.mod文件
//go.mod
module test
go 1.18


>>Unicode与UTF-8
Unicode是字符集, 也就是给每个字符一个固定的编号, 字符集有ascii与Unicode;
而UTF-8是编码规则, 就是以某种形式对字符编号进行编码;


>>格式化输出
1, fmt.Printf("%s", s)
常用的格式符如下:
%v: 按值的本来值输出;  //%+v 打印时会增加字段名
%d / %b / %o / %x(X): 整型的十进制 / 二进制 / 八进制 /十六进制;
%c / %s: 字符 / 字符串;
%f / %e: 浮点数 / 用科学计数法表示
%T: 变量的类型;
%p: 指针(十六进制方式显式);
%U: Unicode字符;
2, s := fmt.Sprintf("%s|%s", s1, s2)
格式化拼接字符串;


>>变量
1, 变量声明
1)同一行声明多个变量和赋值
var a, b, c int = 1, 2, 3 或 a, b, c := "zhao", 32, "maths"
注: 声明变量时可以省略类型, go语言会自动推断;
注: 全局变量的声明必须使用var, 局部变量可以省略;
像 a := 3 的方式只能用在函数体内作为局部变量;
2)变量可以分组声明
var (
	a int,
	b bool,
	c string = "hello"
)
3)匿名变量 _
_变量相当于垃圾桶, 给其赋值相当于丢弃, 如 a, _, b := 1, 2.0, "hello";
2, 变量的可见性规则
大写字母开头的变量是公有变量, 即其他包可以读取;
小写字母开头的变量是私有变量;


>>常量
1, 常量初始化
const NATION string = "中国" (显式),
const NATION = "CHINA" (隐式, 也叫无类型常量)
常量也可以通过内置函数来定义(只能通过内置函数, 使用自定义函数会报错):
const a, b = len(NATION), reflect.TypeOf(NATION)
2, 特殊常量iota
iota在第一次遇到const时为0, 以后每次加1;
const (
	a = iota      //0
	b			  //1
	c = iota * 2  //4
	d = iota      //3
)
注: iota只能被赋值给常量, 不能在其他地方使用;
注: const分块声明多个常量时, 如果省略了值则表示和上面一行的值相同, 如
const (
	a = 100
	b        //b也为100
)
注: go语言中变量和常量是严格区分大小写的;


>>两数交换的简写
a, b = b, a


>>数据类型
1, 数值类型
1)整型
int8, int16, int32, int64, uint8, uint16, uint32, uint64
2)浮点类型
float32, float64
浮点数的格式化输出:
%.2f  //保留小数点后2位小数
3)复数类型
complex64, complex128
4)其他
byte(=uint8), int(=int32或int64), uint(=uint32或uint64),
rune(=int32), uintptr(无符号整型, 用于存放一个指针)
注: byte可表示一个ascii字符, 如 
var ch byte = 65 或 var ch byte = '\x41';
rune可表示一个utf-8字符, 如汉字;
2, 布尔类型
bool
注: 与其他语言不同, go语言不允许将其他类型转化为布尔类型;
3, 字符串类型(编码统一为"UTF-8")
string
注: 使用reflect.TypeOf(a)可以得到a的数据类型;
使用unsafe.Sizeof(a)可以得到变量a所占的字节数; 
布尔类型占1个子节, 字符串类型占4个子节;
声明基本类型时未初始化, 则默认为类型零值;
4, 引用类型
引用类型的零值为nil;
指针类型(Pointer),
数组类型,
结构化类型(struct),
Channel类型(chan),
函数类型(func),
切片类型(slice),
接口类型(interface),
Map类型(map)


>>字符串
1, go中的字符串是不可变的byte序列, go语言中没有char类型;
可使用``来定义多行字符串, 里面的内容原样输出, 如转义符失效;
字符串统一使用UTF-8编码, utf8编码: 1个字母占用1个字节, 1个汉字占用3个字节;
2, 字符串的长度
s := "胡c"
len(s)  //4, 字节数
utf8.RuneCountInString(s)  //2, 字符数
3, 遍历每一个字符
ascii字符串遍历直接使用下标, Unicode字符串遍历使用for...range;
1)遍历英文字符串
s := "hello"
for i := 0; i < len(s); i++ {
	fmt.Printf("%c: %d\n", s[i], s[i])
}
2)遍历Unicode字符
s := "赵a钱b孙c"
for _, v := range s {
	fmt.Printf("%c: %d\n", v, v)
}
4, 字符串的不可变性
如果要修改字符串, 需要先将字符串转换为[]byte;
s := "hello world"
bs := []byte(s)  //如果字符串里有汉字, 则使用 []rune
bs[2] = '*';
newS := string(bs)
或者使用 strings.ReplaceAll
ss := strings.ReplaceAll(s, "o", "*")
5, 字符串的常用操作
1)len(s), utf8.RuneCountInString(s)
字符串的长度;
2)strings.Index(s, "o"), strings.LastIndex(s, "o")
子串出现的位置, 没有则返回-1;
3)s[m:n]
取子串;
4)strings.Contains(s, "o")
是否包含子串, 返回true或false;
5)strings.HasPrefix(s, "o"), strings.HasSuffix(s, "o")
前缀/后缀判断;
6)strings.Split(s, "|")
字符串分割, 返回[]string;
7)strings.Join(a []string, "|")
字符连接, 返回字符串;
8)strings.ReplaceAll(s, "o", "*")
替换子串;


>>类型转换
1, go语言中必须进行强制类型转换, 不存在隐式转换;
2, 数值类型之间的转换
一般将小类型转换为大类型, 避免数据丢失;
var a int = 3
var b float64 = 1.2
c := float64(a) + b
3, 字符串和其他类型的转换
1)其他类型 => 字符串
//fmt.Sprintf()
s := fmt.Sprintf("%d, %.2f, %c", 2, 1.2345, 'b')
//strconv.Format***()
分为FormatInt()、FormatUint()、FormatFloat()、FormatBool();
2)字符串 => 其他类型
//strconv.Parse***()
分为ParseInt()、ParseUint()、ParseFloat()、ParseBool();
3)整型与字符串的快速转换
//strconv.Itoa() / strconv.Atoi()


>>运算符
算术运算符、关系运算符、逻辑运算符、赋值运算符、按位运算符;
注: go语言中只有后置自增自减, 没有前置自增自减; 而且++/--只能独立使用, 不能与赋值运算符一起使用, 如
b := a++ //错
注: &&和|| 按短路逻辑执行;


>>控制语句
1, 条件语句
1)if, else, if else
变量的初始化可以放在if语句里面, 如
if sum := calSum(); sum > 100 {
	//...
}
2)switch
switch语句分为表达式switch和类型switch;
switch 中可以包含初始化语句, 如 
switch age := 32, age { 
	case age < 24:
}
case 可以写多个值, 如 case 2, 4, 6, 8, 10:
case 也可以写表达式, 如 
switch {
	case age < 24: 
} 或
switch age := 32; {
	case age < 24:
}
注: go语言中多个case默认不穿透, 即不需要写break, 如果需要穿透, 需要添加fallthrough语句;
2, 循环语句
go语言中的循环语句只有一种, 就是for;
1)基本语法
for i:=1; i<=10; i++ { //... }
for ; i<=10; i++ { //... }
for i<=10 { //... }
for { //... }  相当于 for true { //... }
2)for...range
for...range用来遍历数组、切片、字符串、map及通道(channel);
a := []string{"苹果", "香蕉", "例子"}
for k, v := range a {
	//...
}
for k := range a {  //也可以省略v, 或者将v写成_
	//...
}
3, goto, break, continue
1)goto
goto One
fmt.Println("中间代码块")
One:
	fmt.Println("this is One")
2)break用于结束当前循环; 
continue用于进入循环的下一个计数;
break/continue后跟标签, 可以跳出或跳到最外层循环:
outerLoop:
for i := 1; i <= 9; i++ {
	for j := 1; j <= i; j++ {
		if j == 5 {
			break outerLoop
		}
	}
}
注: 嵌套循环中, break outer, continue outer, goto outer的区别:
break outer 直接结束外层循环;
continue outer 继续执行外层循环, 从当前的i值接着执行;
goto outer 重新执行外层循环(死循环);


>>package
1, package声明必须放在第一行, 名称一般与目录名称一致;
要生成go语言可执行程序, 必须要有main的package包, 且该包下必须有main()函数;
同一个路径下只能存在一个package, 一个package可以拆成多个源文件;
2, 代码包的初始化函数: init();


>>import
1, 导入源码文件所依赖的包;
不得导入源码文件没有用到的包, 否则会报错;
2, 两种形式:
import "package1"
import "package2"
或
import (
	"fmt"
	"test/sub1"
	"test/sub2"
)
3, 如果一个包被多次导入, 只导入一次;
4, 导入包和main包的执行顺序
main包依赖包B, 包B依赖包A:
A中常量初始化 -> A中变量初始化 -> 执行A中init()函数 ->
B中常量初始化 -> B中变量初始化 -> 执行B中init()函数 ->
main中常量初始化 -> main中变量初始化 -> 执行main中init()函数 -> 执行main()函数;
5, 导入的包起别名
import my "test/sub1"
6, 导入的包加_
import _ "test/sub1", 表示仅执行导入包中的init()函数, 而不能调用其中的函数;
常用来注册包里的引擎;
7, 导入的包加.
import . "test/sub1", 调用其中的函数时可以省略包名, 不推荐;
8, 举例
package main
import (
	"fmt"
	"test/sub1"
	my "test/sub2"
)
func init(){
	fmt.Println("main.init()")
}
func main(){
	sub1.A()
	my.B()
	fmt.Println("main.main()")
}


>>模拟枚举
go语言中没有枚举类型, 可以模拟枚举:
type Fruit int
const (
	Apple Fruit = iota
	Orange
	Banana
)
当类型需要显式为字符串时, go语言会自动寻找String()方法进行调用;
func (f Fruit) String() string {
	switch f {
		case Apple:
			return "Apple"
		case Orange:
			return "Orange"
		case Banana:
			return "Banana"
	}
	return "NONE"
}
fmt.Printf("%T, %d, %s", Apple, Apple, Apple)



>>数组
1, 数组定义
数组的长度是数组类型的一部分, 而切片不是;
var a = [3]int{2, 4, 6}
len(a)  //数组的长度
注: 如果只声明一个数组而没有赋值, 则数组元素默认为类型的零值;
a := [3]int{1, 2}  //[1, 2, 0]
a := [...]int{1, 2, 3}  //自动推断数组长度
a := [3]int{1: 5, 2: 8}  //[0, 5, 8]
2, 比较两个数组是否相等
使用 == 或 != 来比较两个数组是否相等, 只能同类型的数组比较;
a := [3]int{1, 2}
b := [...]int{1, 2, 0}
a == b  //true
3, 遍历数组
for k, v := range a {
	//...
}
4, 数组是值类型
a := [3]int{1, 2, 3}
b := a  //数组可以直接赋值
b[1] = 888
a  //{1, 2, 3}
5, 多维数组
a := [2][3]int{{1, 2, 3}, {3, 4, 5}}
a := [2][3]int{1: {3, 4, 5}}
a := [2][3]int{1: {0: 3, 1: 4, 2: 5}}
多维数组的第二维长度可以省略, 系统会自动推断, 第一维长度不可省略, 但可以为...;
a := [...][]int{{1}, {2, 3}}


>>切片
go语言中, 数组是值类型, 而切片是引用类型, 切片的名称相当于一个指针;
1, 声明切片
var strList []string  //strList == nil 为 true
var iList []int
var iList = []int{}  //空切片, iList == nil 为false
a := make([]int, 2, 10)  //动态构造切片, 指定切片类型、大小和容量
注: 使用make来定义切片是重新分配内存区域, 而使用a[m:n]这种操作并不分配内存, 而是将切片指向原来的底层数组或底层切片;
2, 每个切片都有一个底层数组;
a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
b := a[3:6]  //[4, 5, 6]
c := b[1:cap(b)]  //[5, 6, 7, 8, 9, 10]
a[:5]  //从开始位置切
a[3:]  //一直到结束位置
a[:]   //整个切
b[0:0]  //将切片置为空: []
len(b)  //长度: 3
cap(b)  //容量: 7
reflect.TypeOf(a)  //[10]int
reflect.TypeOf(b)  //[]int
b := a[min:max:bound]  //第三个参数表示切片容量不超过bound下标的位置
注: 修改切片的元素会同时修改底层数组
3, 内置函数append
slice = append(slice, 22, 33, 44)
切片不能通过下标扩容, 可以通过append来扩容, 会自动更换底层数组;
a := []int{1, 2}
a = append(a, 5, 6)  //向切片末尾添加元素 [1, 2, 5, 6]
a = append(a, []int{5, 6}...)  //以切片的方式添加 [1, 2, 5, 6]
a = append([]int{5, 6}, a...)  //向切片的开头添加 [5, 6, 1, 2]
a = append(a[:i], append([]int{999}, a[i:]...)...)  //在第i个位置插入999
注: append()函数的第一个参数必须是切片类型;
注: 切片的扩容策略, 如果当前容量不够, 会自动将容量增大一倍, 如
a := make([]int, 6, 6);
a = append(a, 10);
fmt.Println(len(a), cap(a));  //7 12
4, 内置函数copy
var c = []int{0, 0, 0}
copy(c, b)  //c复制b
按照较小个数的那个切片进行复制, 返回实际复制的元素个数;
注: 整体赋值与copy的区别: 
整体赋值是浅复制, 改变一个切片会影响到另一个;
而copy是深复制, 改变一个切片不会影响到另一个;
5, 删除切片中的元素
go语言中没有直接删除元素的方法;
//删除前n个元素
a = a[n:]
//删除后n个元素
a = a[:len(a)-n]
//删除中间index索引的元素
a = append(a[:index], a[index+1:]...)


>>指针
1, 声明指针变量, 默认为nil, 而通过new()得到的指针变量, 其指向一块内存区域, 所以不等于nil;
var p *int  //p == nil
var p = new(int)  //p != nil
2, go语言中的指针不能进行算术运算;


>>Map
1, 创建map
var m map[string]int  //这种声明m为nil, 不能增加key-value
m := make(map[string]int)  //这种声明m不为nil, 可以增加key-value
m := map[string]int{"zhao": 30, "qian": 26, "sun": 28,}
2, 遍历
for k, v := range m {
	fmt.Println(k, v)
}
3, map的基本操作
1)查找
a := m["cao"]  //如果key不存在则返回0
a, ok := m["cao"]  //ok为false表示key不存在
2)新增或修改
m["cao"] = 32  //向map中添加键值对, key不存在则添加, key存在则修改对应value
3)删除
delete(m, "cao")  //删除键值对, 无key也不会报错
4, 给map的key或value排序
先将key或value保存到切片中, 通过sort包给切片排序, 然后遍历切片取值;
5, map与切片的结合
//元素为map类型的切片
s := make([]map[string]string, 3, 3)
s[0] = map[string]string{"username": "zhao", "age": "26",}
s[1] = map[string]string{"username": "qian", "age": 28",}
s  //map[map[age:26 username:zhao], map[age:28 username:qian], map[]]
//value为切片类型的map
m := make(map[string][]string)
m["skill"] = []string{"java", "golang", "js"}
m["hobby"] = []string{"阅读", "音乐", "跑步"}
m  //map[skill:[java golang js] hobby:[阅读 音乐 跑步]]
6, 举例: 统计一个段落中每个单词出现的次数
func (s string) map[string]int {
	m := make(map[string]int)
	bs := strings.Split(s, " ")
	for _, v := range bs {
		m[v]++
	}
	return m
}
注: golang中没有Set数据类型;


>>函数
1, 函数定义
func fn(a int, b int) int { return a + b }
func fn(a, b int) (r int) { //多个参数的类型相同, 可以使用简写形式
	r = a + b
	return 
}
func fn(a, b int) (c int, d int){ //返回多个结果
	c = a + b
	d = a - b
	return 
}
2, 匿名函数
//将匿名函数赋值给变量
var f1 = func(a int, b int) int {
	return a + b
}
//匿名函数直接调用
func(a int, b int) int {
	return a + b
}(4, 6)
注: golang中函数内部不允许再定义另外一个函数, 但可以使用匿名函数的形式, 如
func test() {
	var f = func(a, b int) int {
		//...
	}
	f()
}
3, 闭包
闭包是指返回函数的函数, 内部函数可以使外部函数的变量常驻内存, 避免全局变量的污染;
func f() func() int {
	value := 1
	return func() int {
		value++
		return value
	}
}
fn := f()  
fn()  //2
fn()  //3
4, 可变参数
可变参数变量是一个包含所有参数的切片;
func f(args ...int) int {  //args的类型是 []int
	sum := 0
	for _, v := range args {
		sum += v
	}
	return sum
}
调用:
1)扁平化传递多个参数
fn(1, 2, 3)
2)传递切片, 需要在切片后面添加...
fn([]int{1, 2, 3}...)
注: 传递param表示传递的是param变量本身, 而param...表示将切片内容拆开成扁平化的多个元素;
5, 给函数起类型别名
type calc func(int, int) int
6, 函数可以作为另一个函数的参数或者返回值
//函数作为参数
func calc(x, y int, f func(int, int) int) int {
	return f(x, y)
}
//调用
rs := calc(4, 3, func(a, b int) int {  //实参可以直接用匿名函数的形式, 也可以传入函数名
	return a * b
})


>>defer
1, defer语句在函数结束或程序异常退出时执行, 当有多个defer语句时, 后面的先执行;
defer后面跟函数调用;
//执行结果: start end 2 1
fmt.Print("start")
defer fmt.Print(1)
defer fmt.Print(2)
fmt.Print("end) 
//执行结果: start end 1 2
fmt.Print("start")
defer func(){
	fmt.Print(1)
	fmt.Print(2)
}()
fmt.Print("end")
2, defer f(n) 实参n是立即确定, 而f(n)的执行才是延时确定的;
当有多个defer时, 从上往下即时确定实参n, 然后从下往上延时执行函数;
func f(id string, a, b int) int {
	r := a + b
	fmt.Println(id, a, b, r)
	return r
}
func main() {
	x, y := 1, 2
	defer f("aa", x, f("a", x, y))
}
执行结果: 
a 1 2 3
aa 1 3 4



>>错误处理
go语言没有像类似java语言中的异常处理机制, 而是在函数中返回一个错误接口error, 调用者须对这个返回值是否等于nil进行判断;
1, error接口
type error interface {
	Error() string
}
2, 自定义一个错误
var err = errors.New("this is an error")
//例: 自定义除数为0的错误
var myerr = errors.New("这是除数为零的错误")
func div(a, b int) (int, error) {
	if b == 0 {
		return 0, myerr
	}
	return a / b, nil
}
func main() {
	fmt.Println(div(1, 0))  //0 这是除数为零的错误
}


>>异常处理: 宕机(panic)与恢复(recover)
1, panic抛出一个异常, recover捕获异常并处理; recover()必须跟在defer后面;
如果不通过defer...recover来对异常进行处理, 当发生异常时程序就会崩溃, 不会继续执行;
func f() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("处理f抛出的异常")
		}
	}()
	panic("f抛出一个异常")
}
2, 举例
func f(a, b int) int {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("发生错误", err)
		} else {
			fmt.Println("一切正常", err)
		}
	}()
	return a / b
}
func main() {
	f(2, 1)  //一切正常 <nil>
	f(2, 0)  //发生错误 runtime error: integer divide by zero
}


>>结构体
1, 实例化
结构体的定义只是一种内存布局的描述, 只有当实例化时, 才会真正分配内存;
//基本的实例化形式
type Point struct {  //定义
	X, Y int
}
var p Point  //实例化  {0, 0}
p.X = 2
p.Y = 6
2, 结构体指针
p := new(Point)  //类型: *main.Point
p.X = 2  //指针类型仍然可以像普通类型一样使用.来访问成员
p.Y = 6  //底层自动转换 (*p).Y
p2 := &Point{}  //取地址实例化
p2 := &p1 
注: 取地址实例化是最广泛的一种结构体实例化方式;
3, 初始化
1)使用键值对形式
type People struct {
	name string
	child *People
}
relation := &People{
	name: "爷爷",
	child: &People{
		name: "爸爸",
		child: &People{
			name: "我",
		},
	}
}
注: 结构体成员中只能包含本结构体的指针类型, 非指针类型则报错;
2)使用列表形式
p1 := Point{2, 4}
使用列表形式必须初始化所有字段, 且顺序一致;
4, 匿名结构体
ins := struct {
	字段1 类型1
	字段2 类型2
}
msg := &struct {  //定义部分
	id int 
	data string 
}{  //值初始化部分
	1024, 
	"hello",
}
5, 嵌入结构体
type Person struct {
	Name string
	Age int
}
type Student struct {
	Person
	Major string
}
s1 := Student{
	Person{"zhao", 26},
	"Maths",
}
var s2 Student  //实例化Student也会自动实例化Person: {{"", 0}, ""}
s2.Name = "qian"
s2.Age = 28
s2.Major = "Maths"
fmt.Printf("%T, %v", s1, s1)  //main.Student, {{"zhao", 26}, "Maths"}
6, 模拟构造函数重载
go语言没有提供构造函数相关的机制, 用户根据需求将参数使用函数传递给结构体;
type Cat struct {
	Color string
	Name string
}
func NewCatByName(name string) *Cat {
	return &Cat{
		Name: name
	}
}
func newCatByColor(color string) *Cat {
	return &Cat{
		Color: color
	}
}
7, 方法
go的方法是作用在接收器上的一个函数;
接收器可以是任何类型(除了接口类型), 也就是说任何类型都可以定义方法, 比如基本类型的别名类型、函数类型等;
接收器分为指针类型接收器和非指针类型接收器, 区别在于是否能修改结构体的字段;
8, 为任意类型添加方法
type MyInt int
func (m MyInt) IsZero() bool {
	return m == 0
}
func (m MyInt) Add(other int) int {
	return other + int(m)
}
9, 继承: 内嵌结构体
1)结构体可以包含匿名字段, 即只有字段的类型, 此时类型就可以当名字使用;
Go语言没有继承, 可以通过结构体的内嵌或组合来模拟继承;
type innerS struct {
	in1 int
	in2 int
}
type outerS struct {
	a int
	b float32
	int
	innerS
}
func main() {
	o1 := new(outerS)
	o1.b = 2.1
	o.int = 3
	o.in1 = 6
	o.in2 = 8
	o2 := outerS{1, 2.0, 5, interS{6, 8}}
}
注: 访问内嵌结构体的字段, 可以使用详细的字段进行一层层访问, 也可以直接访问, 如 o.innerS.in1, 或 o.in1;
2)使用内嵌结构体模拟继承
type Walking struct{}
func (w *Walking) Walk(){
	fmt.Println("I can walk")
}
type Flying struct{}
func (f *Flying) Fly(){
	fmt.Println("I can fly")
}
//通过组合来实现继承关系
type Bird struct {
	Walking
	Flying
}
int main() {
	b := new(Bird)
	b.Walk()
	b.Fly()
}


>>接口
1, 如果一个任意类型T的方法集为一个接口类型的方法集的超集, 则称类型T实现了此接口类型;
type Walker interface{
	Walk() error
}
type Person struct {}
func (p Person) Walk() error {
	fmt.Println("Person can walk")
	return nil
}
var walker Walker = Person{}
walker.Walk()
当一个类型实现了接口, 就可以把该类型变量赋值给接口类型的变量;
注: Go语言中实现接口是隐式的, 叫做非侵入式设计; 
2, 可以通过本类型和嵌入的类型来共同实现一个接口, 避免代码冗余;
type Service interface {  //定义接口
	Start()
	Log(string)
}
type Logger struct {}  //Logger实现接口的Log()方法
func (g *Logger) Log(s string) {}
type GameService struct {  //GameService实现接口的Start()方法, 同时通过内嵌Logger类型实现Log()方法
	Logger
}
func (g *GameService) Start() {}
var s Service = new(GameService)
s.Start()
s.Log("hello")
3, nil
nil只能被赋值给指针或者接口;
只有显式地将nil赋值给接口时, 接口才等于nil, 如
var w *Walker = nil
w == nil  //true
如果不是显式的将nil赋值给接口, 那么接口将不等于nil, 如
var p *Person = nil  
var w Walker = p  //*Person实现了Walker接口
p == nil  //false
4, 类型断言
1)x.(T)
var x interface{} = 10
value, ok := x.(int)  //10 true
value, ok := x.(string)  // "" false
2)x.(type)
只能用于switch结构中;
switch x.(type) {
	case int:
		//...
	case string: 
		//...
	default:
		//...
}
5, 接口的嵌套
type Writer interface {
	Write(p []byte) (n int, err error)
}
type Closer interface {
	Close() error
}
type WriteCloser interface {
	Writer
	Closer
}
如果一个类型同时实现了Writer和Closer接口, 则表示该类型实现了WriteCloser接口;


>>sync.Map
线程安全的Map
var m sync.Map  //无须初始化, 直接使用, sync.Map不能使用make()创建
m.Store("zhao", 30)  //保存键值对, 键和值都以interface{}类型保存
m.Load("zhao")  //取值
m.Delete("zhao")  //删除对应的键值对
m.Range(func(k, v interface{}) bool {  //遍历, 使用回调函数
	fmt.Println(k, v)
	return true  //返回true则继续下一次迭代, false则立即结束
})  
注: sync.Map比Map有一些性能损失, 所以在非并发情况下, 应该使用Map;


>>列表List
列表是链表实现, 其中保存的元素类型可以不同;
//初始化列表
var m list.List
或者 m := list.New()
//插入元素
m.PushBack("canon")  //尾部添加
m.PushFront(67)  //头部添加
elem := m.pushBack("fist")  //尾部添加并返回元素指针
m.InsertAfter("high", elem)  //在元素elem之后添加
m.InsertBefore("noon", elem)  //在元素elem之前添加
m.Remove(elem)  //删除elem元素
//遍历列表
for i := m.Front(); i != nil; i = i.Next() {
	fmt.Println(i.Value)
}


>>通过内存缓存来提升性能
1, 普通的斐波那契数列生成
func fibonacci(n int) (res int) {
	if n == 1 || n == 2 {
		res = 1
	} else {
		res = fibonacci(n-1) + fibonacci(n-2)
	}
	return
}
2, 通过内存缓存改进后的斐波那契生成
const LIMIT = 100
var cache [LIMIT]uint64
func fibonacci(n int) (res int) {
	if cache[n] != 0 {  //检查数组中是否已知斐波那契n
		res = cache[n]
		return 
	}
	if n == 1 || n == 2 {
		res = 1
	} else {
		res = fibonacci(n-1) + fibonacci(n-2)
	}
	cache[n] = res  //将生成的斐波那契n保存到数组
	return
}
注: 优化后的性能提升无数倍;


>>json
go语言中json的序列化和反序列化需要通过[]byte类型来中转;
1, json.Marsha1()  //序列化
type Person struct {
	Name string
	Age int `json:"age"`
}
p := Person{"zhao", 30,}
temp, err := json.Marsha1(p)  //temp是[]byte类型
s := string(temp)  //json串
注: `json:"age"`表示序列化json时给字段换一个名字;
`json:""`标签(Tag)的使用有以下几点:
1)FieldName int `json:"myName"`): 表示在json串里使用myName作为键名;
2)FieldName int `json:"myName,omitempty"`: 表示在json串里使用myName作为键名, 如果该字段为空则省略;
3)FieldName int `json:",omitempty"`: 表示使用默认键名, 如果该字段为空则省略;
4)FieldName int `json:"-"`: 表示在json串忽略该字段;
2, json.Unmarsha1()  //反序列化
s := `{"Name": "zhao", "Age": 30}`
ptr := new(Person)
err := json.Unmarsha1([]byte(s), ptr)  //ptr就是指向对象的指针


>>排序
1, 自定义排序
需要自定义类型来实现sort.Interface接口, 需要实现三个方法:
type MyStringList []string
func (m MyStringList) Len() int { 
	return len(m)
}
func (m MyStringList) Less(i, j int) bool {
	return m[i] < m[j]
}
func (m MyStringList) Swap(i, j int) {
	m[i], m[j] = m[j], m[i]
}
names := MyStringList{"java", "go", "python", "js", "c++", "php",}
sort.Sort(names)  //通过sort.Sort()函数来对切片序列进行排序
2, 常见基本类型的快速排序
1)字符串的排序
方式一: 
直接使用sort.Strings(names)对字符串切片进行排序;
names := []string{ //... }
sort.Strings(names)

方式二:
names := sort.StringSlice{"java", "go", "python", "js", "c++", "php",}  //字符串切片
sort.Sort(names)
2)整型的排序
使用sort.IntSlice整型切片然后sort.Sort(), 或者使用sort.Ints()快速排序;
3)浮点数的排序
使用sort.Float64Slice浮点切片然后sort.Sort(), 或者使用sort.Float64s()快速排序;
3, 对结构体切片进行排序
1)自定义排序规则
type Hero struct{
	Name string
	King int
}
type Heros []*Hero 
然后让Heros实现sort.Interface接口;
names := Heros{
	//...
}
sort.Sort(names)
2)快速排序 sort.Slice()
函数原型如下:
func Slice(slice interface{}, less func(i, j int) bool)
使用:
sort.Slice(heros, func(i, j int) bool{
	if heros[i].Kind != heros[j].Kind {
		return heros[i].Kind < heros[j].Kind
	}
	return heros[i].Name < heros[j].Name
})


>>内建方法
1, make与new
用于创建slice、map、chan这三种类型, 返回类型的引用;
1)创建切片
s := make([]int, 3)
s := make([]int, 3, 10)
s[0] = 2
s[1] = 4
s[2] = 6
fmt.Printf("%T, %v", s, s)  //[]int, [2, 4, 6]
注: make切片时必须传入第二个参数指明切片的长度, 可选的第三个参数表示初始容量;
2)创建map
m := make(map[string]int)
m["zhao"] = 26
m["qian"] = 22
m["sun"] = 25
fmt.Printf("%T, %v")  //map[string]int, map[qian:22, sun:25, zhao:26]
3)创建channel
ch := make(chan int)  //没有缓存的chan
ch := make(chan int, 3)  //缓存数量为3的chan
4)new
返回指定类型的指针, 可以给任意类型分配内存;
2, append, copy, delete
append与copy应用于slice, 而delete应用于map;
1)append
s := make([]int, 3)
s = append(s, 1)
s = append(s, 6, 7, 8)  //s: [0, 0, 0, 1, 6, 7, 8]
2)copy
a := []int{1, 2, 3}
b1 := make([]int, 2)
copy(b1, a)  //b1: [1, 2]
b2 := make([]int, 4)
copy(b2, a)  //b2: [1, 2, 3, 0]
3)delete
m := map[string]int{"zhao": 24, "qian": 26, "sun": 22,}
delete(m, "qian")  //m: map[zhao:24, sun:22]
3, panic与recover
相当于抛出异常与捕获异常;
func f1() {  //手动触发panic
	fmt.Println("enter f1")
	panic(errors.New("occur a panic"))
	fmt.Println("quit f2")
}	
func f2() {  //宕机恢复
	if p := recover(); p != nil {
		fmt.Printf("Fatal error: %s\n", p)
	}
}
func main() {
	defer f2()
	fmt.Println("enter main")
	f1()
	fmt.Println("quit main")
}
输出如下:
enter main
enter f1
Fatal error: occur a panic
注: defer f2()一定要放在panic()前面, 否则执行不到recover()程序就崩溃了;
4, len, cap, close
len用于string, array, slice, map, chan这几种类型;
cap用于array, slice, chan这几种类型;
close只用于chan类型;
s := make([]int, 3, 10)  //len(s): 3, cap(s): 10
ch := make(chan int, 4)  //len(ch): 0, cap(ch): 4
defer close(ch)


>>通道Channel
1, Channel用于在不同Goroutine之间传递类型化的数据, 是并发安全的, 而其他数据类型都不是并发安全的;
chan T  //声明
ch1 := make(chan string, 5)  //声明通道类型的变量并为其赋值, 第二个参数表示通道的长度
ch1 <- "value1"  //向通道发送数据
value := <- ch1  //从通道接受数据
value, ok := <- ch1  //ok为false表示通道已关闭
close(ch1)  //关闭通道
注: 向已满通道发送数据, 或从空通道接受数据, 都会引起阻塞;
2, 缓冲通道与非缓冲通道
ch := make(chan string, 5)  //缓冲通道
ch := make(chan string, 0)  //非缓冲通道
3, 双向通道, 发送通道, 接受通道
ch := make(chan int, 5)  //双向通道
type Receiver <- chan int  //接受通道
var receiver Receiver = make(chan int, 5)
type Sender chan <- int  //发送通道
var sender Sender = make(chan int, 5)


>>并发
协程(goroutine) + 协程间通信(channel) + 协程同步(sync.waitgroup)
1, 协程
func main() {
	go f1()
	go f2()
	time.Sleep(time.Second)  //主程序结束前有足够时间让协程执行完毕
}
2, 协程间通信--channel
1)多个协程之间通过channel通信;
2)select
select语句中的case关键字只能后跟通道的发送或者接收操作;
ch1 := make(chan int, 2)
ch2 := make(chan string, 1)
ch1 <- 2
ch1 <- 6
ch2 <- "zhao"
for {
	select {
		case n := <- ch1:
			fmt.Println("ch1: ", n)
		case n := <- ch2:
			fmt.Println("ch2: ", n)
		default:
			fmt.Println("通道里已没有数据")
	}
}
注: 如果当前多个通道有数据, select会随机选择一个通道case执行;
e, ok := <- ch  //如果ch没数据则阻塞, 如果ch已关闭则ok为false;
3, 协程同步
主协程等待其他协程执行完再结束: 系统工具 sync.WaitGroup
Add(delta int)  //添加计数
Done()  //移除一个计数, 等价于Add(-1)
Wait()  //阻塞直到所有任务完成
举例:
var wg sync.WaitGroup
func tast(i int) {
	//defer wg.Done()
	fmt.Println("task...", i)
	//...
	wg.Done()
}
func main() {
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go task(i)
	}
	wg.Wait()
}
4, 举例
1)模拟多个顾客抢购鸡蛋
func main() {
	var wg sync.WaitGroup
	var ch = make(chan int, 10)  
	for i := 1; i <= 10; i++ {  //将10个鸡蛋放入channel
		ch <- i
	}
	for i := 1; i <= 100; i++ {  //100个顾客并发抢购鸡蛋
		wg.Add(1)
		go func(n int) {  //单个抢鸡蛋的协程
			select {
				case egg := <- ch:
					fmt.Printf("第%d个顾客抢到第%d个鸡蛋\n", n, egg)
				default:
					fmt.Printf("当前第%d个顾客, 鸡蛋已抢完\n", n)
			}
			wg.Done()
		}(i)
	}
	wg.Wait()
}
2)生产者-消费者
var chan = make(chan int, 10)
func producer(n int) {  //生产者
	ch <- n
	fmt.Println("生产:", n)
}
func consumer() {  //消费者
	fmt.Println("消费:", <- ch)
}
func main() {
	for i := 1; i <= 10; i++ {
		go producer(i)
		go consumer()
	}
}


>>go modules(go的模块与依赖管理) 






















