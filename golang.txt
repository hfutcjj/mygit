>>Go语言的应用领域
1，服务端开发
2，区块链
3，云计算（CDN ，消息推送，分布式文件系统等）


>>Go语言的优点
1, 属于静态语言, 既有静态语言的执行效率和安全性, 又有动态语言的简单易学和开发效率;
2, 语言层面支持高并发;


>>go的安装及开发工具
1, go语言下载安装后不需要配置环境变量, 以前的gopath模式改成go mod了, 所以代码
可以放在任何位置, 直接终端输入go run(运行) / go build(编译)即可;
cmd输入go version查看go的版本;
go env查看go的环境变量;
2, 下载vscode后安装汉化包扩展以及go语言扩展, 即可进行go语言开发;


>>Go语言命令行工具
1, go env
查看go的环境变量;
2, go build
将源码文件(.go)编译成可执行文件(.exe);
3, go run
编译并运行源码文件(.go);
4, go install
用于编译并安装代码包或源码文件;
安装代码包会在当前工作区的pkg/<平台相关目录>下生成归档文件;
安装命令源码文件会在当前工作区的bin目录下生成可执行文件;
5, go get
用来动态获取远程代码包;


>>package
1, 包的基本概念
1)golang中包的种类: 系统内置包、第三方包、自定义包;
2)package声明必须放在第一行, 名称一般与目录名称一致;
要生成go语言可执行程序, 必须要有main包, 且该包下必须有main()函数;
同一个路径下只能存在一个package, 一个package可以拆成多个源文件;
3)代码包的初始化函数: init();
4)包中以大写字母开头的变量、常量、类型或函数是公有的, 包外可访问, 否则为私有;
2, go mod
go mod是包的管理工具, 使用自定义包时, 必须先生成 go.mod 文件, 步骤为: 
在终端输入: go env -w GO111MODULE=on  //如果已打开则不需要执行
进入项目目录输入: go mod init xxx  //xxx代表文件夹名, 如test
或者, 直接在项目目录下新建go.mod文件
//go.mod
module test
go 1.18
3, 自定义包的目录结构
test 
	utils
		calc.go
		sort.go
	go.mod
	main.go
//main.go
package main
import (
	"fmt"
	"test/utils"  //必须有go.mod才能导入该自定义包
)
4, 使用第三方包
1)go的第三方包查找网址: https://pkg.go.dev
2)下载安装第三方包
go get github.com/shopspring/decimal  //全局
下载后会把第三方包存放到 {gopath}/pkg/mod 目录下, 同时会写到 go.mod 文件中, 同时会生成一个 go.sum 文件;
注: go get 从github下载内容失败的解决方案
修改代理环境变量:
go env -w GOPROXY=https://goproxy.cn,direct
5, 常用的系统内置包
fmt, unsafe, reflect, strconv, strings, utf8, sort, errors, time, encoding/json, 
sync, os, io, bufio, ioutil, net/http, 


>>import
1, 导入源码文件所依赖的包;
不得导入源码文件没有用到的包, 否则会报错;
2, 两种形式:
import "package1"
import "package2"
或
import (
	"fmt"
	"test/sub1"
	"test/sub2"
)
3, 如果一个包被多次导入, 只导入一次;
4, 导入包和main包的执行顺序
main包依赖包B, 包B依赖包A:
A中常量初始化 -> A中变量初始化 -> 执行A中init()函数 ->
B中常量初始化 -> B中变量初始化 -> 执行B中init()函数 ->
main中常量初始化 -> main中变量初始化 -> 执行main中init()函数 -> 执行main()函数;
5, 导入的包起别名
import my "test/sub1"
6, 匿名导入包
import _ "test/sub1", 表示仅执行导入包中的init()函数, 而不能调用其中的函数;
常用来注册包里的引擎;
7, 导入的包加.
import . "test/sub1", 调用其中的函数时可以省略包名, 不推荐;
8, 举例
package main
import (
	"fmt"
	"test/sub1"
	my "test/sub2"
)
func init(){
	fmt.Println("main.init()")
}
func main(){
	sub1.A()
	my.B()
	fmt.Println("main.main()")
}


>>格式化输出
1, fmt.Printf("%s", s)
常用的格式符如下:
%v: 按值的本来值输出;  //%+v 打印时会增加字段名, %#v 打印时会增加类型名和字段名
%d / %b / %o / %x(X): 整型的十进制 / 二进制 / 八进制 /十六进制;
%c / %s: 字符 / 字符串;
%f / %e: 浮点数 / 用科学计数法表示
%T: 变量的类型;
%p: 指针(十六进制方式显示);
%U: Unicode字符;
注: %.2f表示保留小数点后2位的小数;
%02d表示2位整数, 不足2位的前面补0;
2, s := fmt.Sprintf("%s|%s", s1, s2)  //格式化输出到字符串;
fmt.Fprintf(writer, "%s, %d", s, i)  //格式化输出到指定的writer变量


>>接收用户输入
1, fmt.Scan()
扫描用户输入, 以空格或换行间隔;
fmt.Scan(&name, &age, &salary)  //如用户输入: zhao 32 8000
2, fmt.Scanln()
同Scan(), 区别是Scanln()遇到换行则全部结束;
3, fmt.Scanf()
格式化输入;
fmt.Scanf("%s-%d-%f", &name, &age, &salary)  //用户输入: zhao-32-8000
注: 以上三个函数都返回输入成功的数量和错误原因, 使用时需要对错误进行处理;


>>变量
1, 变量声明
1)同一行声明多个变量和赋值
var a, b, c int = 1, 2, 3 或 a, b, c := "zhao", 32, "maths"
注: 声明变量时可以省略类型, go语言会自动推断;
注: 全局变量的声明必须使用var, 局部变量可以省略;
像 a := 3 的方式只能用在函数体内作为局部变量;
2)变量可以分组声明
var (
	name string = "zhao";
	age int = 32;
	likes []string;
)
3)匿名变量 _
_变量相当于垃圾桶, 给其赋值相当于丢弃, 如 a, _, b := 1, 2.0, "hello";
2, 变量的可见性规则
大写字母开头的变量是公有变量, 即其他包可以读取;
小写字母开头的变量是私有变量;
3, go语言中的变量和常量都是严格区分大小写的;
4, 使用reflect.TypeOf(a)可以得到a的数据类型;
使用unsafe.Sizeof(a)可以得到变量a所占的字节数; 
声明基本类型变量时未初始化, 则默认为类型零值;
5, 两数交换的简写
a, b = b, a
6, Unicode与UTF-8
Unicode是字符集, 也就是给每个字符一个固定的编号, 字符集有ascii与Unicode;
而UTF-8是编码规则, 就是以某种形式对字符编号进行编码;


>>常量
1, 常量初始化
const NATION string = "中国" (显式),
const NATION = "CHINA" (隐式, 也叫无类型常量)
常量也可以通过内置函数来定义(只能通过内置函数, 使用自定义函数会报错):
const a = len(NATION)
2, 特殊常量iota
分块声明的多个常量, 如果省略了值则表示和上面一行的值相同; 
如果上面出现了iota, 则下面的值缺省情况下逐步加1;
const (
	a = 20        //20
	b             //20
	c = iota      //2
	d	          //3
	e             //4
	f = iota*3    //15
)


>>基本数据类型
1, 数值类型
1)整型
int8, int16, int32, int64, uint8, uint16, uint32, uint64
2)浮点类型
float32, float64
3)其他
int(=int32或int64), uint(=uint32或uint64), 
byte(=uint8), rune(=int32)
注: byte可表示一个ascii字符, 如 var c byte = 65 或 var c byte = '\x41';
rune可表示一个utf-8字符, 如汉字 var c rune = '佳';
2, 布尔类型
bool
注: 与其他语言不同, go语言不允许将其他类型转化为布尔类型;
3, 字符串类型string (编码统一为"UTF-8")
布尔类型占1个字节, 字符串类型占4个字节;
注: golang中整数默认为int, 浮点数默认为float64;
var a = 12   //int
var b = 1.2  //float64


>>golang中的值类型和引用类型
1, 值类型
golang中的值类型有: 基本数据类型、数组、结构体;
值类型如果没有赋值, 则默认为类型零值: 
var a [3]int  //[0, 0, 0]
var a Person  //{ 0}
2, 引用类型
golang中的引用类型有: 切片、map、chan、函数、接口、指针;
引用类型如果没有赋值, 则默认为nil;
3, 引用类型默认为nil, 不能给nil变量赋值, 必须先用new()或make()函数分配内存后才能赋值;
1)var p *int  //指针
*p = 12 (×)
var p *int = new(int)
*p = 12 (√)
2)var s []int  //切片
s[0] = 3 (×)
var s = make([]int, 5)
s[0] = 3 (√)
3)var m map[string]int  //map
m["zhao"] = 23 (×)
var m = make(map[string]int)
m["zhao"] = 23 (√)
4)var ch chan int  //chan
ch <- 12 (×)
var ch chan int = make(chan int, 3)
ch <- 12 (√)


>>字符串
1, go中的字符串是不可变的byte序列, go语言中没有char类型;
可使用``来定义多行字符串, 里面的内容原样输出, 里面的转义符会失效;
字符串统一使用UTF-8编码, utf8编码: 1个字母占用1个字节, 1个汉字占用3个字节;
2, 字符串的长度
s := "胡c"
len(s)  //4, 字节数
utf8.RuneCountInString(s)  //2, 字符数
3, 遍历每一个字符
ascii字符串遍历直接使用下标, Unicode字符串遍历使用for...range;
1)遍历英文字符串
s := "hello"
for i := 0; i < len(s); i++ {
	fmt.Printf("%c: %d\n", s[i], s[i])
}
2)遍历Unicode字符
s := "赵a钱b孙c"
for _, v := range s {
	fmt.Printf("%c: %d\n", v, v)
}
4, 字符串的不可变性
如果要修改字符串, 需要先将字符串转换为[]byte;
s := "hello world"
bs := []byte(s)  //如果字符串里有汉字, 则使用 []rune
bs[2] = '*';
newS := string(bs)
或者使用 strings.ReplaceAll
ss := strings.ReplaceAll(s, "o", "*")
5, 字符串的常用操作
1)长度: len(s), utf8.RuneCountInString(s)
2)子串: s[m:n]
3)子串的位置: strings.Index(s, "o"), strings.LastIndex(s, "o")
4)是否包含子串: strings.Contains(s, "o")
5)子串的个数: strings.Count(s, "o")
6)子串的替换: strings.ReplaceAll(s, "o", "*")
7)是否包含指定前缀/后缀: strings.HasPrefix(s, "o"), strings.HasSuffix(s, "o")
8)分割(返回[]string): strings.Split(s, "|")
9)连接(返回string): strings.Join(a []string, "|")


>>类型转换
1, go语言中必须进行强制类型转换, 不存在隐式转换;
2, 数值类型之间的转换
一般将小类型转换为大类型, 避免数据丢失;
var a int = 3
var b float64 = 1.2
c := float64(a) + b
3, 字符串和其他类型的转换
1)其他类型 => 字符串
//fmt.Sprintf()
s := fmt.Sprintf("%d, %.2f, %c", 2, 1.2345, 'b')
//strconv.Format***()
分为FormatInt()、FormatUint()、FormatFloat()、FormatBool();
2)字符串 => 其他类型
//strconv.Parse***()
分为ParseInt()、ParseUint()、ParseFloat()、ParseBool();
3)整型与字符串的快速转换
//strconv.Itoa() / strconv.Atoi()


>>运算符
算术运算符、关系运算符、逻辑运算符、赋值运算符、按位运算符;
注: go语言中只有后置自增自减, 没有前置自增自减; 而且++/--只能独立使用, 不能与其他表达式一起使用, 如
b := a++ //错
注: &&和|| 按短路逻辑执行;
注: golang中没有条件运算符;


>>控制语句
1, 条件语句
1)if, else, if else
变量的初始化可以放在if语句里面, 如
if sum := calSum(); sum > 100 {
	//...
}
2)switch
switch语句分为表达式switch和类型switch;
case 可以写多个值, 如 case 2, 4, 6, 8, 10:
case 也可以写表达式, 如 
switch {
	case age < 24: 
} 或
switch age := 32; {
	case age < 24:
}
注: go语言中多个case默认不穿透, 即不需要写break, 如果需要穿透, 需要添加fallthrough语句;
2, 循环语句
go语言中的循环语句只有一种, 就是for;
1)基本语法
for i:=1; i<=10; i++ { //... }
for ; i<=10; i++ { //... }
for i<=10 { //... }
for { //... }  相当于 for true { //... }
2)for...range
for...range用来遍历数组、切片、字符串、map及通道(channel);
a := []string{"苹果", "香蕉", "例子"}
for k, v := range a {
	//...
}
for k := range a {  //也可以省略v, 或者将v写成_
	//...
}
3, goto, break, continue
1)goto
goto One
fmt.Println("中间代码块")
One:
	fmt.Println("this is One")
2)break用于结束当前循环; 
continue用于进入循环的下一个计数;
break/continue后跟标签, 可以跳出或跳到最外层循环:
outerLoop:
for i := 1; i <= 9; i++ {
	for j := 1; j <= i; j++ {
		if j == 5 {
			break outerLoop
		}
	}
}
注: 嵌套循环中, break outer, continue outer, goto outer的区别:
break outer 直接结束外层循环;
continue outer 继续执行外层循环, 从当前的i值接着执行;
goto outer 重新执行外层循环(死循环);


>>数组
1, 数组定义
数组的长度是数组类型的一部分, 而切片不是;
var a = [3]int{2, 4, 6}
len(a)  //数组的长度
注: 如果只声明一个数组而没有赋值, 则数组元素默认为类型的零值;
a := [3]int{1, 2}  //[1, 2, 0]
a := [...]int{1, 2, 3}  //自动推断数组长度
a := [3]int{1: 5, 2: 8}  //[0, 5, 8]
2, 比较两个数组是否相等
使用 == 或 != 来比较两个数组是否相等, 只能同类型的数组比较;
a := [3]int{1, 2}
b := [...]int{1, 2, 0}
a == b  //true
3, 遍历数组
for k, v := range a {
	//...
}
4, 数组是值类型
a := [3]int{1, 2, 3}
b := a  //数组可以直接赋值
b[1] = 888
a  //{1, 2, 3}
5, 多维数组
a := [2][3]int{{1, 2, 3}, {3, 4, 5}}
a := [2][3]int{1: {3, 4, 5}}
a := [2][3]int{1: {0: 3, 1: 4, 2: 5}}
多维数组的第二维长度可以省略, 系统会自动推断, 第一维长度不可省略, 但可以为...;
a := [...][]int{{1, 2, 3}, {4, 5}, {6}}


>>切片
go语言中, 数组是值类型, 而切片是引用类型, 切片的名称相当于一个指针;
1, 声明切片
var strList []string  //strList == nil 为 true
var iList []int
var iList = []int{}  //空切片, iList == nil 为false
a := make([]int, 2, 10)  //动态构造切片, 指定切片类型、大小和容量, 容量可不指定
注: 使用make来定义切片是重新分配内存区域, 而使用a[m:n]这种操作并不分配内存, 而是将切片指向原来的底层数组或底层切片;
2, 每个切片都有一个底层数组
切片的本质就是对底层数组的封装, 它包含三个信息: 底层数组的指针、切片的长度(len)和切片的容量(cap);
a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
b := a[3:6]  //[4, 5, 6]
c := b[1:cap(b)]  //[5, 6, 7, 8, 9, 10]
a[:5]  //从开始位置切
a[3:]  //一直到结束位置
a[:]   //整个切
b[0:0]  //将切片置为空: []
len(b)  //长度: 3
cap(b)  //容量: 7
reflect.TypeOf(a)  //[10]int
reflect.TypeOf(b)  //[]int
b := a[min:max:bound]  //第三个参数表示切片容量不超过bound下标的位置
注: 修改切片的元素会同时修改底层数组
3, 内置函数append
slice = append(slice, 22, 33, 44)
切片不能通过下标扩容, 可以通过append来扩容, 会自动更换底层数组;
a := []int{1, 2}
a = append(a, 5, 6)  //向切片末尾添加元素 [1, 2, 5, 6]
a = append(a, []int{5, 6}...)  //以切片的方式添加 [1, 2, 5, 6]
a = append([]int{5, 6}, a...)  //向切片的开头添加 [5, 6, 1, 2]
a = append(a[:i], append([]int{999}, a[i:]...)...)  //在第i个位置插入999
注: append()函数的第一个参数必须是切片类型;
注: 切片的扩容策略, 如果当前容量不够, 会自动将容量增大一倍, 如
a := make([]int, 6, 6);
a = append(a, 10);
fmt.Println(len(a), cap(a));  //7 12
4, 内置函数copy
var c = []int{0, 0, 0}
copy(c, b)  //c复制b
按照较小个数的那个切片进行复制, 返回实际复制的元素个数;
注: 直接赋值与copy的区别: 
直接赋值是浅复制, 改变一个切片会影响到另一个;
而copy是深复制, 改变一个切片不会影响到另一个;
5, 删除切片中的元素
go语言中没有直接删除元素的方法;
//删除前n个元素
a = a[n:]
//删除后n个元素
a = a[:len(a)-n]
//删除中间index索引的元素
a = append(a[:index], a[index+1:]...)


>>切片的快速排序
1, 基本类型切片的快速排序
sort.Ints(slice)  //整型切片
sort.Strings(slice)  //字符串切片
sort.Float64s(slice)  //浮点型切片
2, 任意类型切片的快速排序
sort.Slice(slice, func(i, j int) bool {
	if slice[i].age != slice[j].age {
		return slice[i].age < slice[j].age
	}
	return slice[i].name < slice[j].name
})
注: 可用于结构体切片的排序, 或基本类型切片的降序排序;
3, 自定义的排序
需要实现接口sort.Interface, 具体百度;


>>指针
1, 普通变量与指针
a := 12
p := &a  //取变量的地址
b := *p  //取指针指向的地址存放的值
2, 声明指针变量, 默认为nil, 而通过new()得到的指针变量, 其指向一块内存区域, 所以不等于nil;
var p *int  //p == nil
var p = new(int)  //p != nil
3, go语言中的指针不能进行算术运算;


>>Map
1, 创建map
var m map[string]int  //这种声明m为nil, 不能增加key-value
m := make(map[string]int)  //这种声明m不为nil, 可以增加key-value
m := map[string]int{"zhao": 30, "qian": 26, "sun": 28,}
2, 遍历
for k, v := range m {
	fmt.Println(k, v)
}
3, map的基本操作
1)查找
a := m["cao"]  //如果key不存在则返回0
a, ok := m["cao"]  //ok为false表示key不存在
2)新增或修改
m["cao"] = 32  //向map中添加键值对, key不存在则添加, key存在则修改对应value
3)删除
delete(m, "cao")  //删除键值对, 无key也不会报错
4, 给map的key或value排序
先将key或value保存到切片中, 通过sort包给切片排序, 然后遍历切片取值;
5, map与切片的结合
//元素为map类型的切片
s := make([]map[string]interface{}, 3)
s[0] = map[string]any{"username": "zhao", "age": 26,}
s[1] = map[string]any{"username": "qian", "age": 28,}
s  //[map[age:26 username:zhao], map[age:28 username:qian], map[]]
//value为切片类型的map
m := make(map[string][]string)
m["skill"] = []string{"java", "golang", "js"}
m["hobby"] = []string{"阅读", "音乐", "跑步"}
m  //map[skill:[java golang js] hobby:[阅读 音乐 跑步]]
6, 举例: 统计一个段落中每个单词出现的次数
func fn(s string) map[string]int {
	m := make(map[string]int)
	bs := strings.Split(s, " ")
	for _, v := range bs {
		m[v]++
	}
	return m
}
注: golang中没有set数据类型;


>>内建方法
1, make与new
make用于创建slice、map、chan这三种类型, 返回类型的引用;
1)创建切片
s := make([]int, 3)
s := make([]int, 3, 10)
s[0] = 2
s[1] = 4
s[2] = 6
fmt.Printf("%T, %v", s, s)  //[]int, [2, 4, 6]
注: make切片时必须传入第二个参数指明切片的长度, 可选的第三个参数表示初始容量;
2)创建map
m := make(map[string]int)
m["zhao"] = 26
m["qian"] = 22
m["sun"] = 25
fmt.Printf("%T, %v")  //map[string]int, map[qian:22, sun:25, zhao:26]
3)创建channel
ch := make(chan int)  //没有缓存的chan
ch := make(chan int, 3)  //缓存数量为3的chan
4)new
返回指定类型的指针, 可以给任意类型分配内存;
2, append, copy, delete
append与copy应用于slice, 而delete应用于map;
1)append
s := make([]int, 3)
s = append(s, 1)
s = append(s, 6, 7, 8)  //s: [0, 0, 0, 1, 6, 7, 8]
2)copy
a := []int{1, 2, 3}
b1 := make([]int, 2)
copy(b1, a)  //b1: [1, 2]
b2 := make([]int, 4)
copy(b2, a)  //b2: [1, 2, 3, 0]
3)delete
m := map[string]int{"zhao": 24, "qian": 26, "sun": 22,}
delete(m, "qian")  //m: map[zhao:24, sun:22]
3, panic与recover
相当于抛出异常与捕获异常;
4, len, cap, close
len用于string, array, slice, map, chan这几种类型;
cap用于array, slice, chan这几种类型;
close只用于chan类型;
s := make([]int, 3, 10)  //len(s): 3, cap(s): 10
ch := make(chan int, 4)  //len(ch): 0, cap(ch): 4
defer close(ch)


>>函数
1, 函数定义
func fn(a int, b int) int { return a + b }
func fn(a, b int) (r int) { //多个参数的类型相同, 可以使用简写形式
	r = a + b
	return 
}
func fn(a, b int) (c int, d int){ //返回多个结果
	c = a + b
	d = a - b
	return 
}
2, 匿名函数
//将匿名函数赋值给变量
var f1 = func(a int, b int) int {
	return a + b
}
//匿名函数直接调用
func(a int, b int) int {
	return a + b
}(4, 6)
注: golang中函数内部不允许再定义另外一个函数, 但可以使用匿名函数的形式, 如
func test() {
	var f = func(a, b int) int {
		//...
	}
	f()
}
3, 闭包
闭包是指返回函数的函数, 内部函数可以使外部函数的变量常驻内存, 避免全局变量的污染;
func f() func() int {
	value := 1
	return func() int {
		value++
		return value
	}
}
fn := f()  
fn()  //2
fn()  //3
4, 可变参数
可变参数变量是一个包含所有参数的切片;
func f(args ...int) int {  //args的类型是 []int
	sum := 0
	for _, v := range args {
		sum += v
	}
	return sum
}
调用:
1)扁平化传递多个参数
fn(1, 2, 3)
2)传递切片, 需要在切片后面添加...
fn([]int{1, 2, 3}...)
注: 传递param表示传递的是param变量本身, 而param...表示将切片内容拆开成扁平化的多个元素;
5, 给函数起类型别名
type calc func(int, int) int
6, 函数可以作为另一个函数的参数或者返回值
//函数作为参数
func calc(x, y int, f func(int, int) int) int {
	return f(x, y)
}
//调用
rs := calc(4, 3, func(a, b int) int {  //实参可以直接用匿名函数的形式, 也可以传入函数名
	return a * b
})


>>defer
1, defer语句在函数结束或程序异常退出时执行, 当有多个defer语句时, 后面的先执行;
defer后面跟函数调用;
//执行结果: start end 2 1
fmt.Print("start")
defer fmt.Print(1)
defer fmt.Print(2)
fmt.Print("end) 
//执行结果: start end 1 2
fmt.Print("start")
defer func(){
	fmt.Print(1)
	fmt.Print(2)
}()
fmt.Print("end")
2, defer f(n) 实参n是立即确定, 而f(n)的执行才是延时确定的;
当有多个defer时, 从上往下即时确定实参n, 然后从下往上延时执行函数;
func f(s string, a, b int) int {
	r := a + b
	fmt.Println(s, a, b, r)
	return r
}
func main() {
	x, y := 1, 2
	defer f("AA", x, f("A", x, y))
	x = 10
	defer f("BB", x, f("B", x, y))
	y = 20
}
执行结果: 
A 1 2 3
B 10 2 12
BB 10 12 22
AA 1 3 4
3, defer的执行时机
golang中的 return x 并不是原子操作, 分为两步: 给x赋值和return操作, 而defer的执行时机就在中间:
给x赋值 -> defer -> return; 


>>golang中的异常处理
1, 返回错误
go语言没有像类似java语言中的异常处理机制, 而是在函数中返回一个错误接口error, 调用者须对这个返回值是否等于nil进行判断;
1)error接口
type error interface {
	Error() string
}
2)自定义一个错误
var err = errors.New("this is an error")
//例: 自定义除数为0的错误
func div(a, b int) (int, error) {
	if b == 0 {
		return 0, errors.New("这是除数为零的错误")
	}
	return a / b, nil
}
func main() {
	fmt.Println(div(1, 0))  //0 这是除数为零的错误
}
2, 抛出异常
1)panic抛出异常, recover捕获异常; 
recover()必须放在defer要执行的函数里面, 才能被执行到;
func main() {
	defer func() {
		if err := recover(); err != nil {
			//...
			fmt.Println("处理异常后结束...")
		}
	}()
	fmt.Println("开始...")
	fn(6, 2)
	//fn(6, 0)
	fmt.Println("正常结束...")
}
func fn(a, b int) int {
	if b == 0 {
		panic("除数不能为0")
	}
	return a / b
}
注: 也可以在fn()函数内对异常进行处理, 要注意的是defer()必须放在panic前面, 否则
执行不到defer()程序就异常退出了;


>>日期时间处理: time包
1, 获取time.Time对象
1)获取当前时间
t := time.Now()  //类型: time.Time
2)时间戳 -> time.Time
u := 1655169518
t := time.Unix(int64(u), 0)  //t: time.Time   //第二个参数表示纳秒的时间戳, 0表示省略
3)日期时间字符串 -> time.Time
s := "1987-07-01 15:30:00"
template := "2006-01-02 15:04:05"  //定义模板与字符串格式匹配
t, err := time.Parse(template, s)
//带时区的时间
loc, _ := time.LoadLocation("Europe/London")
t, _ := time.ParseInLocation(template, s, loc)
2, time.Time对象的格式化输出
1)通过t.Format()
格式: 2006-年, 01-月, 02-日, 03/15-时(12/24小时制), 04-分, 05-秒
s := t.Format("2006-01-02 03:04:05")
2)通过fmt.Printf()
fmt.Printf("%d-%02d-%02d %02d:%02d:%02d", t.Year(), t.Month(), t.Day(), 
	t.Hour(), t.Minute(), t.Second())
注: t.Month()得到的是英文月份, 可通过int(t.Month())将其转换为整数;
3, time.Time对象转换为时间戳
t.Unix()  //单位: 秒
t.UnixMilli()  //单位: 毫秒
4, time包中的一些常量
time.Hour
time.Minute
time.Second
time.Millisecond  //1ms
time.May  //具体月份
5, time.Time的常用方法
//将Time对象增加或减少一段时间
t2 := t1.Add(time.Hour)
t2 := t1.Sub(time.Hour)
//比较两个Time对象的先后
t2.Before(t1)
t2.After(t1)
6, 定时器
使用time.Sleep()
7, time包中与管道相关的函数
1)time.After() //延迟执行
2)time.Tick() //重复执行, 底层是time.Ticker
传入指定的时间间隔, 返回: <-time.Time
//举例: 每2秒执行一次, 10秒后结束
entTime := time.Add(10 * time.Second)
for t := range time.Tick(2 * time.Second) {
	fmt.Println(t)
	if t.After(endTime) {
		break
	}
}
3)time.Ticker结构体
ticker := time.NewTicker(2 * time.Second)
for t := range tikcer.C {
	fmt.Println(t)
	if some-condition {
		ticker.Stop()  //自带停止计时器的方法
		break
	}
}



>>json
go语言中json的序列化和反序列化需要通过[]byte类型来中转;
1, json.Marshal()  
用于将slice, map, struct等类型序列化为[]byte, 再转换为json串;
p := Person{"zhao", 32}
m := map[string]any{"name": "zhao", "age": 32}
b1, err := json.Marshal(p)
b2, err := json.Marshal(m)
fmt.Println(string(b1))  //`{"name":"zhao","age":32}`
fmt.Println(string(b2))  //`{"name":"zhao","age":32}`
2, json.Unmarsha1()  
用于将json串(先转换成[]byte)反序列化为对应的slice, map, struct等类型;
s := `{"Name":"zhao","Age":32}`
var p Person
var m map[string]any
json.Unmarsha1([]byte(s), &p)  //注意第二个参数为指针
json.Unmarsha1([]byte(s), &m)
fmt.Printf("%#v\n", p)  //main.Person{Name:"zhao", Age:32}
fmt.Printf("%#v\n", m)  //map[string]interface {}{"Age":32, "Name":"zhao"}
3, 结构体的字段需要特殊处理的情形(字段标签)
type Person struct {
	Name string
	Age int `json:"age"`
}
注: `json:"age"`表示序列化时给字段取一个别名, 底层是用反射技术来实现的;
注: 结构体序列化时会自动省略以小写字母开头的字段;


>>结构体
重点: 结构体的嵌套;
1, 定义
结构体的定义只是一种内存布局的描述, 只有当实例化时, 才会真正分配内存;
type Person struct {
	name string
	age int
}
2, 初始化
1)最基本的方式
var p1 Person  //此时p1已分配内存, 值为{"", 0}
p1.name = "zhao"
p1.age = 32
2)结构体指针的方式(常用)
p2 := new(Person)  //等价于 p2 := &Person{}
p2.name = "zhao"
p2.age = 32
注: golang中结构体指针可以直接通过.来取字段值, 如p.name, 等价于(*p).name;
注: %T: *main.Person;  %#v: &main.Person{name:"zhao", age:32};
3)键值对的形式
p3 := Person{name: "zhao", age: 32,} 或 
p3 := &Person{name: "zhao", age: 32,}
4)列表的方式
p4 := Person{"zhao", 32,} 或 
p4 := &Person{"zhao", 32,}
注: 使用列表的方式必须初始化所有字段且顺序一致;
3, 结构体是值类型
结构体与数组一样, 是值类型; 而结构体指针与切片、map一样, 是引用类型;
p1 := Person{"zhao", 32,}
p2 := p1
p2.age = 88
p1  //{"zhao", 32}
4, 结构体定义方法
1)接收者为结构体
func (p Person) say() {
	fmt.Printf("name: %s, age: %d\n", p.name, p.age)
}
2)接收者为结构体指针
func (p *Person) grow() {
	p.age++
}
注: 如果需要修改结构体的字段值, 则接收者必须为结构体指针;
注: 可以给自定义类型定义方法, 不能给非本地类型定义方法;
5, 匿名结构体
msg := &struct {  //定义部分
	id int 
	data string 
}{  //值初始化部分
	1024, 
	"hello",
}
6, 结构体的匿名字段
匿名字段就是只有字段类型而没有字段名, 可以使用如 p.string 来取字段值, 
实际使用不推荐, 仅在嵌套结构体中使用;
type Person struct {
	string
	int
}
p := Person{"zhao", 32,}
fmt.Printf("name: %s, age: %d", p.string, p.int)
7, 嵌套匿名结构体--实现继承
//定义结构体以及方法
type Person struct {
	Name string
	Age int
}
func (p Person) say() {
	fmt.Println(p.Name + " is saying")
}
type Student struct {
	Person  //匿名字段
	Major string
}
func (s Student) study() {
	fmt.Println(s.Name + " is studying " + s.Major)
}
//测试用例
s := Student{Person{"zhao", 26}, "Maths",}
p := new(Student)
p.Name = "zhao"
p.Age = 26
p.Major = "maths"
p.say()
p.study()
注: golang中没有继承, 可以使用嵌套结构体来实现继承;
注: 必须嵌套匿名结构体才属于继承, 否则属于普通的结构体嵌套;
8, 可以为任意类型添加方法
type MyInt int
func (m MyInt) IsZero() bool {
	return m == 0
}
func (m MyInt) Add(other int) int {
	return other + int(m)
}


>>接口
重点: 值类型与指针类型结构体实现接口; 类型断言; 空接口;
1, 接口是一组行为规范, 接口只含有一组抽象方法, 由具体的结构体实现这些抽象方法;
type Usber interface {
	start(string)
}
type Phone struct {  //Phone实现Usber接口
	Name string
}
func (p Phone) start(s string) {
	//...
}
func (p Phone) call() {  //Phone的其他方法
	//...
}
//调用
var u Usber = Phone{"Redmi7"}
u.start()
注: u虽然声明为Usber类型, 但实际是Phone类型;
2, 值类型接收者和指针类型接收者实现接口的区别
1)值类型实现接口, 则值类型变量和指针类型变量都可以赋值给接口;
func (p Phone) start() {
	//...
}
var u Usber = Phone{"Redmi7"}  //√
var u Usber = &Phone{"Redmi7"}  //√
2)指针类型实现接口, 则只允许指针类型变量赋值给接口;
func (p *Phone) start() {
	//...
}
var u Usber = &Phone{"Redmi7"}  //√
var u Usber = Phone{"Redmi7"}  //×
3)指针接收者的类型断言
v, ok := u.(*Phone)
fmt.Printf("%T, %v", v, v)  //*main.Phone, &{Redmi7}
3, 类型断言
1)x.(T)  //T为具体类型
用于将接口转换为具体的实现类型;
var x interface{} = "hello"
v, ok := x.(string)  //"hello" true
v, ok := x.(int)  //0 false, 此时程序正常运行, 返回类型零值
v := x.(string)  //"hello"
v := x.(int)     //panic, 此时程序崩溃
var u Usber = Phone{"Redmi7"}
u.start()
if v, ok := u.(Phone); ok {  //调用Phone的其他方法, 需要先转换为具体的Phone类型
	v.call()
}
注: 注意类型断言用两个变量接收和用一个变量接收的区别, 当实际类型与要断言的类型不一致时, 
用一个变量接收时程序会崩溃, 而用两个变量接收时则不会;
2)x.(type)
判断具体类型, 只能用于switch语句;
switch x.(type) {
	case string:
		fmt.Println("x是string类型")
	case int:
		fmt.Println("x是int类型")
	default:
		fmt.Println("x是其他类型")
}
4, 空接口
1)不包含任何方法的接口为空接口, 用 interface{} 或 any 表示, 任何类型都算实现了空接口;
var x interface{} = 12
fmt.Printf("%T, %v\n", x, x)  //int, 12
x = "hello"
fmt.Printf("%T, %v\n", x, x)  //string, hello
2)空接口应用于切片和map, 可使切片和map的value表示任意类型;
s := []interface{}{"zhao", 32, "maths"}
m := map[string]interface{}{"name": "zhao", "age": 32, "hobby": []string{"reading", "running"},}
3)空接口的使用细节
当map的value为空接口类型时, 要注意空接口上不能使用索引和取字段;
m := map[string]interface{}{
	"username": "zhao",
	"age": 32,
	"hobby": []string{"reading", "running"},
	"address": Address{"高新区", "102"},
}
取某个hobby: m["hobby"][1] (错!)
取Address字段: m["hobby"].Name (错!)
应该先使用类型断言将interface{}转换为切片或者结构体类型, 如下:
hobby, _ := m["hobby"].([]string)
hobby[1]  //或 m["hobby"].([]string)[1]
address, _ := m["address"].(Address)
address.Name  //或 m["address"].(Address).Name
5, 接口的嵌套
type IEat interface {
	eat()
}
type IWork interface {
	work()
}
type Creature interface {
	IEat
	IWork
}
结构体实现Creature接口, 需要实现Creature接口中所有嵌套接口的方法;


>>反射
1, 反射指在程序运行时动态获取一个变量的类型信息和值信息;
2, 反射可以实现的功能
1)通过反射可以动态获取变量的类型信息和值信息, 也可以修改变量的值;
//获取变量的类型
fmt.printf("%T", v)
reflect.TypeOf(v)
//获取变量的值
var v interface{} = 5
r := v.(int) + 7
r := reflect.ValueOf(v).Int() + 7
//修改变量的值(变量必须为指针类型)
func fn(v interface{}) {
	reflect.ValueOf(v).Elem().setInt(88)
}
var a = 5
fn(&a)
2)如果是结构体, 通过反射可以获取结构体的字段的信息, 也可以调用结构体的方法;
//...
3, 反射的应用场景
1)将空接口转换为实际类型, 可以使用断言, 也可以使用反射;
2)将结构体序列化为json字符串, 自定义字段标签时, 底层会用到反射;
3)ORM框架的底层会用到反射;


>>文件操作
1, 读取文件
读文件打开文件的方式:
file, err := os.Open("./demo.txt")  //以只读方式打开文件
defer file.Close()
1)方式一: 按字节读取
n, err := file.Read(b)  
读取的内容放到b中, b是[]byte类型, 返回读取的字节数n和err, 如果已到文件末尾, 则err==io.EOF;
循环读取文件内容:
var content []byte
for {
	temp := make([]byte, 100) 
	n, err := file.Read(temp)
	if err == io.EOF {  //读取完毕
		break
	}
	content = append(content, temp...)
}
2)方式二: 按行读取
reader := bufio.NewReader(file)
s, err := reader.ReadString('\n') 
按指定分隔符读取('\n'表示按行), 返回读取到的字符串s和err;
循环读取文件内容:
var content string
reader := bufio.NewReader(file)
for {
	s, err := reader.ReadString('\n')
	content += s
	if err == io.EOF {
		break
	}
}
★3)方式三: 直接读取整个文件
b, err := ioutil.ReadFile("./demo.txt")  //也可以直接用os包
直接一次性读取, 返回[]byte类型的b和err;
这个函数封装好了文件的打开与关闭, 不需要再手动处理;
2, 写入文件
写操作时打开文件的方式:
file, err := os.OpenFile("./demo.txt", os.O_CREATE|os.O_RDWR, 0666)
defer file.Close()
注: 打开模式有: os.O_RDONLY(只读), os.O_WRONLY(只写), os.O_RDWR(读写), 
os.O_CREATE(创建), os.O_APPEND(追加), os.O_TRUNC(清空);
1)方式一: 按字节写
n, err := file.Write(b)  //写入[]byte
n, err := file.WriteString(s)  //写入字符串
2)方式二: 按行写
writer := bufio.NewWriter(file)
n, err := writer.WriteString(s)
writer.Flush()  //刷新缓存才能真正写入
★3)方式三: 一次写入整个文件
ioutil.WriteFile("./demo.txt", []byte(s), 0666)  //也可以直接用os包
3, 复制文件
通过读取源文件再写入目标文件, 就实现了文件的复制;
1)方式一
b, _ := ioutil.ReadFile("./src.png")
ioutil.WriteFile("./dest.png", b, 0666)
2)方式二
f1, _ := os.Open("./src.png")
defer f1.Close()
f2, _ := os.OpenFile("./dest.png", os.O_CREATE|os.O_WRONLY, 0666)
defer f2.Close()
for {
	temp := make([]byte, 100)
	n, err := f1.Read(temp)
	f2.Write(temp[:n])  //[:n]保证最后一次写入的数据完全一致
	if err == io.EOF {
		break
	}
}
4, 文件三种操作方式的对比
1)普通的小文件并且对内容没有太多操作的, 可以采用整体读取, 速度较快;
2)大文件, 或者对文件内容有操作的, 采用分片读取或逐行读取更合适;
5, 目录与文件的创建、删除、重命名
1)创建
os.Mkdir("./a", 0666)  //创建单级目录
os.MidirAll("./a/b/c", 0666)  //创建多级目录
os.Create("./test.txt")  //创建文件
2)删除
os.Remove("./a")  //删除目录或文件
os.RemoveAll("./a/b/c")  //删除多级目录
3)重命名
os.Rename("./src.txt", "./dest.txt")
6, 获取文件的属性信息
os.Stat(fileName) //得到文件信息的结构体


>>协程(goroutine)
1, 基本概念
1)进程(process)、线程(thread)、协程(goroutine)
进程是一个正在执行的程序, 进程是系统进行资源分配和调度的基本单位;
线程是程序执行的最小单元, 一个进程可以包含多个线程;
golang中的协程是用户级线程, golang的一大特色就是语言层面原生支持协程;
golang中的协程占用的内存单元远比C/Java中的线程少, 多协程间的切换调度的开销也远比线程少;
golang在主线程(main)中开启多个协程;
2)并发与并行
同一时间多个线程同时执行, 叫并行, 如多核CPU上的多任务并行执行;
同一时间只有一个线程执行, 多个线程分片轮流执行, 叫并发, 如单核CPU上的多任务并发执行;
2, main主线程与其他线程的同步
有以下三种方式:
1)sync.WaitGroup 可以实现主线程等待协程执行完毕;
Add(1)  //开启新协程时, 将WaitGroup的计数器加1
Done()  //一个协程结束时, 将WaitGroup的计数器减1, 同 Add(-1)
Wait()  //阻塞直到WaitGroup的计数器为0, 用来等待所有协程执行结束
var wg sync.WaitGroup
func main() {
	wg.Add(1)
	go fn()
	//...
	wg.Wait()
	fmt.Println("主线程结束")
}
func fn() {
	defer wg.Done()
	//...
}
*2)使用管道来实现主线程与协程的同步;
3)使用runtime.Gosched()来让主进程让出时间片;
协程中使用runtime.Goexit()来让协程退出;
3, 协程的通信与同步
1)管道
协程之间的通信与同步是通过管道来完成的;
//定义
var ch chan int  //nil
var ch = make(chan int)  //开辟一块内存区域, len: 0, cap: 0
var ch = make(chan int, 5)  //len: 0, cap: 5
len(ch) == 0  //空管道
len(ch) == cap(ch)  //管道已满
注: 管道是引用数据类型;
管道也是线程安全的, 通过读写操作的阻塞等待, 实现协程的通信与同步;
//向管道发送数据
var ch = make(chan int, 3)
ch <- 2
ch <- 3
ch <- 5
close(ch)
注: 任何时候向管道写完数据后一定要记得关闭管道, 否则后续遍历会导致死锁;
向已满管道发送数据, 会引起阻塞;
已关闭的管道, 不能向其发送数据, 可以从其读取数据;
//从管道读取数据
v := <- ch  
v, ok := <- ch  //读取一个已关闭的空管道, 会返回 0 false
//遍历管道
var ch = make(chan int, 10)
for i := 1; i <= 10; i++ {
	ch <- i
}
close(ch)  
for v := range ch {
	fmt.Println(v)
}
2)单向管道
var ch chan<- int  //只写管道(send-only channel)
ch := make(chan<- int, 3)
var ch <-chan int  //只读管道(receive-only channel)
ch := make(<-chan int, 3)
注: 双向管道可以赋值给单向管道, 反之则不可以;
var ch chan<- int = make(chan int, 3)
4, select多路复用
ch1 := make(chan string, 10)
ch2 := make(chan string, 5)
go func() {
	defer close(ch1)
	for i := 0; i < 10; i++ {
		time.Sleep(1 * time.Second)
		ch1 <- fmt.Sprintf("from ch1 %d", i)
	}
}()
go func() {
	defer close(ch2)
	for i := 0; i < 5; i++ {
		time.Sleep(2 * time.Second)
		ch2 <- fmt.Sprintf("from ch2 %d", i)
	}
}()
for ch1 != nil || ch2 != nil {
	select {
	case msg1, ok := <-ch1:
		if !ok { // ch1已关闭
			ch1 = nil
			fmt.Println("ch1 closed")
			continue
		}
		fmt.Println(msg1)
	case msg2, ok := <-ch2:
		if !ok { // ch2已关闭
			ch2 = nil
			fmt.Println("ch2 closed")
			continue
		}
		fmt.Println(msg2)
	}
}
fmt.Println("Done")
如果没有default, 则阻塞等待ch1与ch2的读写, 否则立即执行default;
如果有多个case可执行,则随机选择其中一个;
5, 锁
1)互斥锁: sync.Mutex
互斥锁用于解决并发编程中对共享资源的访问;
互斥锁一般用于并发的协程对共享资源的写操作, 加锁后让协程串行访问共享资源;
var count = 0;
var mutex sync.Mutex
func fn() { //协程的函数
	mutex.Lock()  //对资源加锁, 加锁后同一时间只允许一个协程访问该段资源
	count++
	fmt.Printf("count: %d\n", count)
	mutex.Unlock()  //解锁
}
2)读写锁: sync.RWMutex
var rwMutex sync.RWMutex
rwMutex.Lock() / rwMutex.Unlock()  
rwMutex.RLock() / rwMutex.RUnlock()  
注: Lock与Lock互斥、RLock与Lock互斥、RLock与RLock不互斥;
6, 原子操作
因为count++并不是原子操作, 需要给count++加锁来实行并发, 
可用sync/atomic包里的函数来执行原子操作:
atomic.AddInt32(&count, 1);


>>正则匹配
1, 定义正则
reg, err := regexp.Compile(`[0-9]`)
2, 匹配字符串
r := reg.MatchString("a1b2c3")
3, 查找字符串
r := reg.FindAllString("a1b2c3", n)  //n表示查找的个数, -1表示查找所有
4, 替换字符串
r := reg.ReplaceAllString("a1b2c3", "*")
5, 分割字符串
r := reg.Split("a1b2c3", n)  



//DOS基本操作
1, 目录操作
dir 			 //查看当前目录下的直接子目录和直接子文件
pwd 				//查看当前目录
cd test或..或/   //切换到test目录或上级目录或根目录
mkdir(或md) d1 d2 d3  //创建目录, 多个目录用空格隔开
rmdir(或rd) d1		  //删除空目录
rmdir /s d1  		  //删除非空目录, 会先询问
rmdir /s/q 		      //删除非空目录, 不询问
2, 文件操作
cd > my.txt		//创建空文件
echo hello world > my.txt  //覆盖写, 写内容到文件, 如果文件不存在则先创建
echo hello world >> my.txt //追加写
del my.txt  //删除文件
del *.txt   //删除所有文本文件
del d2/*	//删除d2文件夹里的所有文件
copy my.txt d2  //将my.txt文件拷贝到d2文件夹
move d2\my.txt d3  //移动文件
3, 其他操作
cls  //清屏
exit //退出


//命令行参数
1, os.Args
所有命令行参数组成的数组, 以空格分隔;
go run main.go -u cjj -h uhome
os.Args: ['main.go', '-u', 'cjj', '-h', 'uhome']
2, 使用flag包对命令行进行解析
var (
	user string
	host string
	port int
)
flag.StringVar(&user, "u", "", "")  //第三个参数为默认值, 第四个参数为说明
flag.StringVar(&host, "h", "", "")
flag.IntVar(&port, "port", 3306, "")
flag.Parse()  //*必须调用该方法才能解析生效
fmt.Printf("user: %s, host: %s, port: %d\n", user, host, port)
运行: 
go run main.go -u cjj -h uhome


>>socket编程
1, 分为服务端和客户端, 使用net包;
文件组织结构:
socket_demo 
	server 
		server.go 
	client 
		client.go
	go.mod
运行:
首先启动客户端
cd server
go run server.go
然后在一个或多个终端中启动客户端
cd client
go run client.go
2, 常用函数
Listen(): 服务端监听
Accept(): 服务端接收客户端连接
Dial(): 客户端创建与服务器的连接
3, 服务端流程
1)监听 Listen(TCP)/ListenPacket(UDP)
ln, err := net.Listen("tcp", "127.0.0.1:8888")
defer ln.Close()
2)接收客户端连接 Accept
conn, err := ln.Accept()
defer conn.Close()
3)处理客户端连接
conn.RemoteAddr()  //客户端的地址
conn.Read(b)  //读数据
conn.Write(b)  //写数据
4, 客户端流程
1)连接服务端
conn, err := net.Dial("tcp", "127.0.0.1:8888")
defer conn.Close()
2)进行读写操作
同服务端conn
5, 使用带缓冲的读写
reader := bufio.NewReader(conn)  //conn实现了io.Reader接口
reader.ReadLine()
6, 处理多客户端的连接
for {
	conn, err := ln.Accept()
	go handleConn(conn)
}
func handleConn(conn net.Conn) {
	defer conn.Close()
	fmt.Printf("Recieve a connection from %s....\n, conn.RemoteAddr().String())
	reader := bufio.NewReader(conn)
	for {
		msg, _, err := reader.Readline()
		if err == io.EOF {
			return
		}
		fmt.Printf("Recieve message: %s\n", msg)
	}
}


>>请求与响应
1, http是无状态协议，也就是服务端不保留连接的相关信息;
2, request格式
请求行 + 请求头 + 请求体:
请求行: POST /test/login HTTP/1.1
请求头: request header
请求体: request body  //header和body之间必须有一空行
注: get请求没有请求体;
前端页面请求后端url需要加上工程名, 如 /test/login;
3, response格式
响应行 + 响应头 + 响应体: 
响应行: HTTP/1.1 200 OK
响应头: response header
响应体: response body  //响应头与响应体之间也要有一空行
4, http响应状态码
1XX: 收到请求，正在处理;
2XX: 成功，如 200 OK;
3XX：重定向，表示请求没有成功，需要采取进一步的动作, 如下:
	301-永久重定向;
	302-临时重定向;
	304-Not Modified, 从缓存中取;
4XX：客户端错误，表示客户端提交的请求有错误，如 404 NOT Found;
5XX：服务器错误，如 500;
5, get与post请求方式的区别
get将数据附加在url里显式发送, 而post将数据放在请求体里隐式发送;
get安全性差, 常用于向服务器的查询操作, 而post安全性高, 常用于对服务器的写操作;
get将数据附加到url，所以长度是有限制的，而post对数据长度没有限制;
get数据能保留在浏览器历史中, 可收藏为书签, 而post不可以;
6, http1.0与http1.1的区别
http1.0版本中, 浏览器请求一个带有图片的网页, 会因为下载图片而与服务器之间开启一个新的连接;
而http1.1版本, 允许浏览器在拿到当前请求对应的全部资源后再断开连接, 提高了效率;



>>go操作数据库(database/sql包)
1, 导入database/sql包以及第三方驱动包
import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
)
2, 连接数据库
var (
	Db *sql.DB
	err error
)
func init() {
	Db, err := sql.Open("mysql", "root:123456@tcp(localhost:3306)/test")
	if err != nil {
		panic(err.Error())
	}
}
注: 1)sql.DB结构体内部维护了一个连接池, 能自动创建和释放连接;
2)Open函数只验证参数, 不创建与数据库的连接, 到后面需要时自动创建;
3, 查询操作
sq := "select name, dno from employee where id > ?"
//只查询一条记录
r := Db.QueryRow(sq, 10)  //r: *sql.Row
r.Scan(&name, &dno)
//查询所有记录
r, _ := Db.Query(sq, 10)  //r: *sql.Rows 
for r.Next() {
	r.Scan(&name, &dno)
}
4, 写操作(插入、更新、删除)
sq := "insert into employee(name, dno) values(?, ?)"
r, _ := Db.Exec(sq, "zhao", 1)  //r: sql.Result
r.LastInsertId() //最后插入的ID
r.RowsAffected() //影响的行数
5, 事务
tx, err := Db.Begin()
s1 := "update t1 set balance = balance + ? where id = 1"
s2 := "update t2 set balance = balance - ? where id = 1"
_, err1 := tx.Exec(s1, 1000)
_, err2 := tx.Exec(s2, 1000)
if err1 != nil || err2 != nil {
	tx.Rollback()  //回滚
	return
}
tx.Commit()  //提交


>>go搭建服务器(net/http包)
1, 绑定处理器
1)★方式一: HandleFunc()
http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request){
	w.Write([]byte("***"))
	//fmt.Fprintln(w, "This is ", r.URL.Path)
})
2)方式二: Handle()
type MyHandler struct{}
func (m *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("***"))
}
mt := MyHandler{}
http.Handle("/world", &mt)
2, 定义监听
1)★方式一
http.ListenAndServe("localhost:9090", nil)
2)方式二: 自定义服务器
server := http.Server{
	Addr: ":9090",
	Handler: &MyHandler{},
}
server.ListenAndServe()
3, 要点
1)ListenAndServe的第一个参数表示网络地址, 为""则表示所有网络接口的80端口;
第二个参数是Handler, 为nil就是DefaultServeMux(默认的多路复用器), 
它是一个Handler, 用来接收HTTP请求, 然后将请求转交给其他具体的Handler来处理;
2)Handler是一个接口, 内部定义了一个方法ServeHTTP(), 自定义处理器需要实现Handler接口;
3)HandleFunc是一个适配器, 通过类型转换让我们可以将具有指定签名的函数作为HTTP处理器来使用;


>>处理静态资源
1, http.Handle("/static", http.FileServer(http.Dir(".")))
/static/demo.html, 表示查找 ./static/demo.html;
2, http.Handle("/static", http.FileServer(http.Dir("./www")))
/static/demo.html, 表示查找 ./www/static/demo.html;
3, http.Handle("/static", http.StripPrefix("/static/", http.FileServer(http.Dir("www"))))
/static/demo.html, 表示查找 ./www/demo.html;


>>使用http获取其他url的信息
resp, _ := http.Get("http://www.baidu.com")
var b []byte
b, err := ioutil.ReadAll(resp.Body)
fmt.Println(string(b))
注: 可用于爬取其他网站的信息;


>>处理请求和响应
1, 获取请求信息
1)r.Method 	 //请求方法
2)r.URL	  //请求的url
r.URL.Path: 请求路径, 如 /hello
r.URL.RawQuery: 请求字符串, 如 name=zhao&age=30
3)r.Proto  //http协议, 如 HTTP/1.1
4)r.Header	//请求头
r.Header是 map[string][]string 类型, 可以对其进行遍历:
header := r.Header
for key, value := range header {
	//...
	//value是[]string类型
}
也可以通过如 r.Header.Get("Accept-Encoding") 的形式获取具体请求头的信息;
5)r.Form  
r.Form是 map[string][]string类型, 包括get请求字符串, 和post的表单字段;
在调用r.Form之前, 需要先调用r.ParseForm();
6)r.FormValue() 
直接获取某个具体的请求字段值, 该函数会自动调用r.ParseForm();
2, 响应
1)返回json格式
w.Header().Set("Content-Type", "application/json")
User := User{//...}
json, _ := json.Marshal(user)
w.Write(json)
2)重定向
http.Redirect(w, r, "/login", 301)
3)使用模板引擎
t, _ := template.ParseFiles("hello.html")
t.Execute(w, "zhao")



>>模板引擎
1, 后端给模板传值
t.Execute(w, map[string]interface{
	"username": "zhao",
	"age": 32,
})
2, 模板接收后端传来的值
{{.}}
3, 条件逻辑
{{if .}}
	//...
{{else}}
	//...
{{end}}
4, 循环逻辑
可对后端传来的数组、切片、map、管道等进行遍历;
1)简单循环
{{range .}}  //此处的.为如后端传来的结构体切片
	{{.}}    //此处的.为如切片的每个结构体元素
	{{.username}}  //取每个元素的username字段值
{{end}}
2)取键值对
{{range $k, $v := .}}
	{{$k}} - {{$Sv}}
{{end}}
5, 模板的嵌套
//index1.html
{{template "index2.html"}}
6, 定义模板
//定义模板model
{{define "model"}}  
	//...
	{{template "content"}}  //包含模板content
{{end}}
//定义模板content
{{define "content"}}
	//...
{{end}}
//后端执行模板改为
t.ExecuteTemplate(w, "model", "zhao")
	
	
>>Cookie
cookie是在浏览器端保存用户信息;
1, cookie的运行原理
1)第一次向服务器发送请求时在服务器端创建cookie
2)在服务器端创建的cookie以响应头的方式发送给浏览器
3)以后再发送请求浏览器就会携带该cookie
4)服务器得到cookie之后根据cookie的信息来区分不同的用户
2, 创建与使用cookie
1)定义cookie
ck := http.Cookie{
	Name: "username",
	Value: "cjj",
	MaxAge: 3600,  //过期时间, 单位为秒
}
注: 如果没有设置过期时间, 则cookie默认是会话级别, 即关闭浏览器就失效;
2)设置cookie
w.Header().Set("Set-Cookie", ck1.String())  //第一个cookie使用Set
w.Header().Add("Set-Cookie", ck2.String())	//第二个cookie使用Add添加
或 http.SetCookie(w, &ck)	
3)读取cookie
cookies := r.Header["Cookie"]  //所有cookie
或 cookie := r.Cookie("username")  //得到一个具体的cookie
3, cookie的用途
1)免登录
2)广告推荐
4, cookie的局限
1)浏览器对cookie数量的数量有限制;
2)cookie只能保存字符串的值;
3)cookie不安全;


>>Session
session是在服务器端保存用户信息;
1, session的运行原理
1)第一次向服务器发送请求时创建session, 给他设置一个唯一ID(可以通过uuid生成)
2)将session的ID值作为cookie发送给浏览器
3)以后再发送请求浏览器就会携带该cookie
4)服务器获取cookie并根据它的值找到服务器中对应的session, 也就知道是哪个用户了


>>RPC(远程过程调用)
1, rpc是一种允许客户端调用服务器端函数的技术, jsonrpc是rpc的一种实现,
它使用json作为数据交换格式, 支持通过http或websocket等协议进行通信;
2, 实现步骤
1)定义一个服务, 包含可以被远程调用的方法
type Request struct {
	A, B int
}
type UserService struct {}
func (u *UserService) Add(request *Request, response *int) error {
	*response = request.A + request.B
	return nil
}
注: 一般写在服务端代码里;
注: 服务的方法接收两个参数: 第一个参数为请求结构体变量指针, 用于获取客户端提交的参数; 
第二个参数为响应结构体变量指针, 用于计算结果的返回;
返回值error用于告知客户端错误信息;
2)服务端: 启动一个rpc服务端, 注册服务并监听客户端的请求
func main() {
	userService := new(UserService)
	rpc.Register(userService)  //注册服务
	ln, err := net.Listen("tcp", "127.0.0.1:9000")
	for {
		conn, err := ln.Accept()
		go jsonrpc.ServeConn(conn)  //处理客户端连接
	}
}
3)客户端: 实现一个rpc客户端, 连接到服务器并调用远程方法
type Request struct {
	A, B int
}
func main() 
	client, err := jsonrpc.Dial("tcp", "127.0.0.1:9000")  //连接到服务端
	request := &Request{12, 3}
	var response int
	err := client.Call("UserService.Add", request, &response)  //调用远程方法
	fmt.Printf("Request: %d+%d=%d\n", request.A, request.B, response)
}





-------------------------Gin-----------------------------
>>gin项目搭建
1, 引入gin包
go get -u github.com/gin-gonic/gin 
import "github.com/gin-gonic/gin"
注: -u表示如果包已存在, 则强行更新代码包及依赖;
2, 热更新 refresh
go install github.com/pilu/fresh@latest
运行 refresh
3, 搭建服务
func main() {
	r := gin.Default()  //创建一个默认的路由引擎
	r.GET("/", func(c *gin.Context) {  //接收请求并响应
		c.String(200, "...")
	})
	r.Post("/add", func(c *gin.Context) {
		c.String(200, "...")
	})
	r.Run()  //监听并执行, 默认8080端口, 也可指定
}
4, 请求参数的获取
1)查询参数
http://example.com/user?name=zhao&age=32
name := c.Query("name")
name := c.DefaultQuery("name", "zhao")
2)路径参数
http://example.com/user/zhao/123
//先在路由中定义占位符
r.GET("/user/:name/:age, func(c *gin.Context) {  
	name := c.Param("name")
})
3)表单参数
c.PostForm("name")
c.DefaultPostForm("name", "zhao")
5, 响应的不同类型
可给前端响应不同的数据格式, 如字符串、json、jsonp、xml、html等；
c.String(200, "hello")
c.JSON(200, map[string]interface{}{
	"name": "zhao",
	"age": 20,
})
注: jsonp、xml等与json的写法类似;
c.HTML(200, "index.html", map[string]interface{}{
	"name": "zhao",
	"age": 20,
})
注: 第二个参数是前端模板文件, 第三个参数是传递给前端模板文件的参数;
一般前端模板放在模板文件夹里, 需要配置模板文件夹:
r.loadHTMLGlob("tpl/*")
6, 静态文件配置
r.Static("/static", "./static")  //前者表示路由, 后者表示路径
7, 模板
tpl
	news.html
	goods.html
//main.go
r.loadHTMLGlob("tpl/*")  //配置模板目录
c.html(200, "goods", map[string]any{
	"title": "books",
	"price": 200,
})
//goods.html
<div>title: {{.title}}</div>
<div>price: {{.price}}</div>
8, 路由分组
frontRouter := r.Group("/")
{
	frontRouter.GET("/login", ...)
	frontRouter.GET("/home", ...)
}
adminRouter := r.Group("/admin")
{
	adminRouter.GET("/user", ...)
	adminRouter.GET("/user/add", ...)
}
apiRouter := r.Group("/api")
{
	apiRouter.GET("/user", ...)
	apiRouter.GET("/user/add", ...)
}
9, 中间件
1)中间件的定义
//middleware/middleware.go
func AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.GetHeader("Authorization")
		if token != "secret-token" {
			c.JSON(401, gin.H{"error": "unauthorization})
			c.Abort()
			return
		}
	}
	c.Next()
	//请求完成后执行的其他操作
}
2)全局中间件
r := gin.Default()
r.Use(middleware.AuthMiddleware)
3)分组中间件
adminRouter := r.Group("/admin")
adminRouter.Use(middleware.AuthMiddleware)
//或者 
adminRouter := r.Group("/admin", middleware.AuthMiddleware)
4)路由中间件
r.GET("/login", middleware/AuthMiddleware, func(c *gin.Context) {
	//...
})
10, cookie和session
1)cookie
//设置cookie
c.SetCookie("username", "张三", expireTime, path, domain, bSecure, bHttpOnly)
注: 将过期时间设为一个小于0的数, 就表示删除cookie;
//获取cookie
c.Cookie("username")
//多个二级域名中共享cookie
比如将domain设置为".itying.com", 这样就可以在"a.itying.com"和"b.itying.com"中共享cookie;
c.SetCookie("username", "张三", 3600, "/", ".itying.com", false, true)
2)session
使用第三方包, 查AI;
注: session可以存在服务器本地, 如果是分布式系统, 则可以存在redis数据库中;


>>GROM
1, 下载gorm和mysql包
gorm.io/driver/mysql 
gorm.io/gorm
2, 连接数据库 
//model/db.go
var (
	Db *gorm.DB 
	err error
)
func init() {
	dsn := "root:123456@tcp(127.0.0.1:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
	Db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic(err)
	}
}
3, 建立模型与数据库表对应
//model/Student.go 
type Student struct {
	//当主键不是id时, 需要指定对应的主键
	SId uint `gorm:"primaryKey;column:s_id"`
	SName string 
	SBirth time.Time
}
//Student结构体默认对应数据库中students表, 如果不是则需要自定义表名
func (Stduent) TableName() string {
	return "student"
}
4, 自动创建数据表
model.Db.AutoMigrate(&user)
AutoMigrate()函数会自动在mysql中创建与user对应的表, 如果表已存在, 但字段不一致, 
则会添加不存在的字段, 但不会删除数据库表中多余的字段;
5, 查询
sList := []model.Student{}
model.Db.Find(&sList)
c.JSON(200, gin.H{
	"data": sList,
})
6, 原生查询
复杂查询可以使用原生查询, 例如多表关联的查询, 步骤如下:
type StudentCourseScore struct {
	SName string 
	CName string 
	SScore int 
}	
var rs []StudentCourseScore
sql := `
	select s.s_name, c.c_name, score.s_score 
		from student s 
		left join score on s.s_id = score.s_id 
		left join course c on c.c_id = score.c_id 
`
model.Db.Raw(sql).Scan(&rs)
c.JSON(200, rs)
注: 自定义的结构体需要与sql返回的查询字段--对应, 与SScore对应s_score;
7, 多表关联: 
1)has one
//在结构体中定义关联关系: Student表与Dept表的关联
type Student struct {
	SId uint `gorm:"primaryKey;column:s_id"`
	SName string 
	DId uint 
	Dept Dept `gorm:"foreignKey:DId;references:DId"`
}
//在查询Student表的数据时要通过Preload(Dept)加载Dept表
model.Db.Preload("Dept").Find(&sList)
2)has many
//在结构体中定义关联关系: Dept表与Student表的关联
type Dept struct {
	DId uint `gorm:"primaryKey;column:d_id"`
	DName string 
	Student []Student `gorm:"foreignKey:DId;references:DId"`
}
注: 因为是一对多的关系, 所以Student要定义成[]Student切片类型;
//查询 
model.Db.Preload("Student").Find(&dList)
3)many2many
例如, 将student表与course表通过score这个关联表进行关联;
可以查询每个学生选修的所有课程:
type Student struct {
	SID uint `gorm:"primaryKey;column:s_id"`
	SName string 
	Courses []Course `gorm:"many2many:score;joinForeignKey:SID;joinReferences:CID"`
}
var sList []model.Student 
model.Db.Preload("Courses").Find(&sList)
c.JSON(200, sList)
也可以查询每个课程有哪些学生选修:
type Course struct {
	CID uint `gorm:"primaryKey;column:c_id"`
	CName string 
	Students []Student `gorm:"many2many:score;joinForeignKey:CID;joinReferences:SID"`
}
var cList []model.Course
model.Db.Preload("Students").Find(&cList)



>>配置文件
config
	config.yaml
	config.go
//config.yaml
app:
  name: "MyApp"
  version: "1.0.0"
  debug: true
database:
  host: "localhost"
  port: 3306
  user: "root"
  password: "123456"
  dbname: "test"
  dns: "root:123456@tcp(127.0.0.1:3306)/test?charset=utf8mb4&parseTime=True&loc=Local"
//config.go
type Config struct {
	App      AppConfig
	Database DatabaseConfig
}
type AppConfig struct {
	Name    string
	Version string
	Debug   bool
}
type DatabaseConfig struct {
	Host     string
	Port     int
	User     string
	Password string
	Dbname   string
	Dns      string
}
var GlobalConfig *Config
func init() {
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	viper.AddConfigPath("./config")
	err := viper.ReadInConfig()
	if err != nil {
		fmt.Println("读取yaml文件发生错误: ", err)
		return
	}
	err = viper.Unmarshal(&GlobalConfig)
	if err != nil {
		fmt.Println("解析yaml文件发生错误: ", err)
		return
	}
}





