>>go的安装及开发工具
1, go语言下载安装后不需要配置环境变量, 以前的gopath模式改成go mod了, 所以代码
可以放在任何位置, 直接终端输入go run(运行) / go build(编译)即可;
cmd输入go version查看go的版本;
go env查看go的环境变量;
2, 下载vscode后安装汉化包扩展以及go语言扩展, 即可进行go语言开发;


>>认识的golang包
fmt, unsafe, reflect, strconv, strings, utf8, sort, errors, time, json, 
		


>>Go语言命令行工具
1, go build
将源码文件(.go)编译成可执行文件(.exe);
2, go run
编译并运行源码文件(.go);
3, go install
用于编译并安装代码包或源码文件;
安装代码包会在当前工作区的pkg/<平台相关目录>下生成归档文件;
安装命令源码文件会在当前工作区的bin目录下生成可执行文件;
4, go get
用来动态获取远程代码包;
5, go env
查看go的环境变量;


>>go get 从github下载内容失败的解决方案
修改代理环境变量:
go env -w GOPROXY=https://goproxy.cn,direct


>>go.mod file not found的解决方案
1, 开启go modules功能
在命令行输入: go env -w GO111MODULE=on
初始化Go module
进入项目目录输入: go mod init [xxx]  //xxx代表文件夹名, 如test
2, 直接在项目目录下新建go.mod文件
//go.mod
module test
go 1.18


>>Unicode与UTF-8
Unicode是字符集, 也就是给每个字符一个固定的编号, 字符集有ascii与Unicode;
而UTF-8是编码规则, 就是以某种形式对字符编号进行编码;


>>格式化输出
1, fmt.Printf("%s", s)
常用的格式符如下:
%v: 按值的本来值输出;  //%+v 打印时会增加字段名
%d / %b / %o / %x(X): 整型的十进制 / 二进制 / 八进制 /十六进制;
%c / %s: 字符 / 字符串;
%f / %e: 浮点数 / 用科学计数法表示
%T: 变量的类型;
%p: 指针(十六进制方式显示);
%U: Unicode字符;
注: %.2f表示保留小数点后2位的小数;
%02d表示2位整数, 不足2位的前面补0;
2, s := fmt.Sprintf("%s|%s", s1, s2)
格式化输出到字符串;


>>变量
1, 变量声明
1)同一行声明多个变量和赋值
var a, b, c int = 1, 2, 3 或 a, b, c := "zhao", 32, "maths"
注: 声明变量时可以省略类型, go语言会自动推断;
注: 全局变量的声明必须使用var, 局部变量可以省略;
像 a := 3 的方式只能用在函数体内作为局部变量;
2)变量可以分组声明
var (
	name string = "zhao";
	age int = 32;
	likes []string;
)
3)匿名变量 _
_变量相当于垃圾桶, 给其赋值相当于丢弃, 如 a, _, b := 1, 2.0, "hello";
2, 变量的可见性规则
大写字母开头的变量是公有变量, 即其他包可以读取;
小写字母开头的变量是私有变量;
3, go语言中的变量和常量都是严格区分大小写的;
4, 使用reflect.TypeOf(a)可以得到a的数据类型;
使用unsafe.Sizeof(a)可以得到变量a所占的字节数; 
声明基本类型变量时未初始化, 则默认为类型零值;
5, 两数交换的简写
a, b = b, a


>>常量
1, 常量初始化
const NATION string = "中国" (显式),
const NATION = "CHINA" (隐式, 也叫无类型常量)
常量也可以通过内置函数来定义(只能通过内置函数, 使用自定义函数会报错):
const a = len(NATION)
2, 特殊常量iota
分块声明的多个常量, 如果省略了值则表示和上面一行的值相同; 
如果上面出现了iota, 则下面的值缺省情况下逐步加1;
const (
	a = 20        //20
	b             //20
	c = iota      //2
	d	          //3
	e             //4
	f = iota*3    //15
)


>>基本数据类型
1, 数值类型
1)整型
int8, int16, int32, int64, uint8, uint16, uint32, uint64
2)浮点类型
float32, float64
3)复数类型
complex64, complex128
4)其他
int(=int32或int64), uint(=uint32或uint64), 
byte(=uint8), rune(=int32), 
uintptr(无符号整型, 用于存放一个指针)
注: byte可表示一个ascii字符, 如 var c byte = 65 或 var c byte = '\x41';
rune可表示一个utf-8字符, 如汉字 var c rune = '佳';
2, 布尔类型
bool
注: 与其他语言不同, go语言不允许将其他类型转化为布尔类型;
3, 字符串类型string (编码统一为"UTF-8")
布尔类型占1个子节, 字符串类型占4个子节;


>>引用类型
1, 有以下引用类型
指针、数组、切片、map、函数、结构体、接口、chan;
引用类型的零值为nil;
2, 引用类型默认为nil, 不能给nil变量赋值, 必须先用new()或make()函数分配内存后才能赋值;
1)var p *int  //数组
*p = 12 (×)
var p *int = new(int)
*p = 12 (√)
2)var s []int  //切片
s[0] = 3 (×)
var s = make([]int, 5)
s[0] = 3 (√)
3)var m map[string]int  //map
m["zhao"] = 23 (×)
var m = make(map[string]int)
m["zhao"] = 23 (√)
4)var ch chan int  //chan
ch <- 12 (×)
var ch chan int = make(chan int, 3)
ch <- 12 (√)


>>字符串
1, go中的字符串是不可变的byte序列, go语言中没有char类型;
可使用``来定义多行字符串, 里面的内容原样输出, 里面的转义符会失效;
字符串统一使用UTF-8编码, utf8编码: 1个字母占用1个字节, 1个汉字占用3个字节;
2, 字符串的长度
s := "胡c"
len(s)  //4, 字节数
utf8.RuneCountInString(s)  //2, 字符数
3, 遍历每一个字符
ascii字符串遍历直接使用下标, Unicode字符串遍历使用for...range;
1)遍历英文字符串
s := "hello"
for i := 0; i < len(s); i++ {
	fmt.Printf("%c: %d\n", s[i], s[i])
}
2)遍历Unicode字符
s := "赵a钱b孙c"
for _, v := range s {
	fmt.Printf("%c: %d\n", v, v)
}
4, 字符串的不可变性
如果要修改字符串, 需要先将字符串转换为[]byte;
s := "hello world"
bs := []byte(s)  //如果字符串里有汉字, 则使用 []rune
bs[2] = '*';
newS := string(bs)
或者使用 strings.ReplaceAll
ss := strings.ReplaceAll(s, "o", "*")
5, 字符串的常用操作
1)长度: len(s), utf8.RuneCountInString(s)
2)子串: s[m:n]
3)子串的位置: strings.Index(s, "o"), strings.LastIndex(s, "o")
4)是否包含子串: strings.Contains(s, "o")
5)子串的个数: strings.Count(s, "o")
6)子串的替换: strings.ReplaceAll(s, "o", "*")
7)是否包含指定前缀/后缀: strings.HasPrefix(s, "o"), strings.HasSuffix(s, "o")
8)分割(返回[]string): strings.Split(s, "|")
9)连接(返回string): strings.Join(a []string, "|")


>>类型转换
1, go语言中必须进行强制类型转换, 不存在隐式转换;
2, 数值类型之间的转换
一般将小类型转换为大类型, 避免数据丢失;
var a int = 3
var b float64 = 1.2
c := float64(a) + b
3, 字符串和其他类型的转换
1)其他类型 => 字符串
//fmt.Sprintf()
s := fmt.Sprintf("%d, %.2f, %c", 2, 1.2345, 'b')
//strconv.Format***()
分为FormatInt()、FormatUint()、FormatFloat()、FormatBool();
2)字符串 => 其他类型
//strconv.Parse***()
分为ParseInt()、ParseUint()、ParseFloat()、ParseBool();
3)整型与字符串的快速转换
//strconv.Itoa() / strconv.Atoi()


>>运算符
算术运算符、关系运算符、逻辑运算符、赋值运算符、按位运算符;
注: go语言中只有后置自增自减, 没有前置自增自减; 而且++/--只能独立使用, 不能与其他表达式一起使用, 如
b := a++ //错
注: &&和|| 按短路逻辑执行;


>>控制语句
1, 条件语句
1)if, else, if else
变量的初始化可以放在if语句里面, 如
if sum := calSum(); sum > 100 {
	//...
}
2)switch
switch语句分为表达式switch和类型switch;
switch 中可以包含初始化语句, 如 
switch age := 32, age { 
	case age < 24:
}
case 可以写多个值, 如 case 2, 4, 6, 8, 10:
case 也可以写表达式, 如 
switch {
	case age < 24: 
} 或
switch age := 32; {
	case age < 24:
}
注: go语言中多个case默认不穿透, 即不需要写break, 如果需要穿透, 需要添加fallthrough语句;
2, 循环语句
go语言中的循环语句只有一种, 就是for;
1)基本语法
for i:=1; i<=10; i++ { //... }
for ; i<=10; i++ { //... }
for i<=10 { //... }
for { //... }  相当于 for true { //... }
2)for...range
for...range用来遍历数组、切片、字符串、map及通道(channel);
a := []string{"苹果", "香蕉", "例子"}
for k, v := range a {
	//...
}
for k := range a {  //也可以省略v, 或者将v写成_
	//...
}
3, goto, break, continue
1)goto
goto One
fmt.Println("中间代码块")
One:
	fmt.Println("this is One")
2)break用于结束当前循环; 
continue用于进入循环的下一个计数;
break/continue后跟标签, 可以跳出或跳到最外层循环:
outerLoop:
for i := 1; i <= 9; i++ {
	for j := 1; j <= i; j++ {
		if j == 5 {
			break outerLoop
		}
	}
}
注: 嵌套循环中, break outer, continue outer, goto outer的区别:
break outer 直接结束外层循环;
continue outer 继续执行外层循环, 从当前的i值接着执行;
goto outer 重新执行外层循环(死循环);


>>package
1, package声明必须放在第一行, 名称一般与目录名称一致;
要生成go语言可执行程序, 必须要有main的package包, 且该包下必须有main()函数;
同一个路径下只能存在一个package, 一个package可以拆成多个源文件;
2, 代码包的初始化函数: init();


>>import
1, 导入源码文件所依赖的包;
不得导入源码文件没有用到的包, 否则会报错;
2, 两种形式:
import "package1"
import "package2"
或
import (
	"fmt"
	"test/sub1"
	"test/sub2"
)
3, 如果一个包被多次导入, 只导入一次;
4, 导入包和main包的执行顺序
main包依赖包B, 包B依赖包A:
A中常量初始化 -> A中变量初始化 -> 执行A中init()函数 ->
B中常量初始化 -> B中变量初始化 -> 执行B中init()函数 ->
main中常量初始化 -> main中变量初始化 -> 执行main中init()函数 -> 执行main()函数;
5, 导入的包起别名
import my "test/sub1"
6, 导入的包加_
import _ "test/sub1", 表示仅执行导入包中的init()函数, 而不能调用其中的函数;
常用来注册包里的引擎;
7, 导入的包加.
import . "test/sub1", 调用其中的函数时可以省略包名, 不推荐;
8, 举例
package main
import (
	"fmt"
	"test/sub1"
	my "test/sub2"
)
func init(){
	fmt.Println("main.init()")
}
func main(){
	sub1.A()
	my.B()
	fmt.Println("main.main()")
}


>>数组
1, 数组定义
数组的长度是数组类型的一部分, 而切片不是;
var a = [3]int{2, 4, 6}
len(a)  //数组的长度
注: 如果只声明一个数组而没有赋值, 则数组元素默认为类型的零值;
a := [3]int{1, 2}  //[1, 2, 0]
a := [...]int{1, 2, 3}  //自动推断数组长度
a := [3]int{1: 5, 2: 8}  //[0, 5, 8]
2, 比较两个数组是否相等
使用 == 或 != 来比较两个数组是否相等, 只能同类型的数组比较;
a := [3]int{1, 2}
b := [...]int{1, 2, 0}
a == b  //true
3, 遍历数组
for k, v := range a {
	//...
}
4, 数组是值类型
a := [3]int{1, 2, 3}
b := a  //数组可以直接赋值
b[1] = 888
a  //{1, 2, 3}
5, 多维数组
a := [2][3]int{{1, 2, 3}, {3, 4, 5}}
a := [2][3]int{1: {3, 4, 5}}
a := [2][3]int{1: {0: 3, 1: 4, 2: 5}}
多维数组的第二维长度可以省略, 系统会自动推断, 第一维长度不可省略, 但可以为...;
a := [...][]int{{1}, {2, 3}}


>>切片
go语言中, 数组是值类型, 而切片是引用类型, 切片的名称相当于一个指针;
1, 声明切片
var strList []string  //strList == nil 为 true
var iList []int
var iList = []int{}  //空切片, iList == nil 为false
a := make([]int, 2, 10)  //动态构造切片, 指定切片类型、大小和容量
注: 使用make来定义切片是重新分配内存区域, 而使用a[m:n]这种操作并不分配内存, 而是将切片指向原来的底层数组或底层切片;
2, 每个切片都有一个底层数组;
a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
b := a[3:6]  //[4, 5, 6]
c := b[1:cap(b)]  //[5, 6, 7, 8, 9, 10]
a[:5]  //从开始位置切
a[3:]  //一直到结束位置
a[:]   //整个切
b[0:0]  //将切片置为空: []
len(b)  //长度: 3
cap(b)  //容量: 7
reflect.TypeOf(a)  //[10]int
reflect.TypeOf(b)  //[]int
b := a[min:max:bound]  //第三个参数表示切片容量不超过bound下标的位置
注: 修改切片的元素会同时修改底层数组
3, 内置函数append
slice = append(slice, 22, 33, 44)
切片不能通过下标扩容, 可以通过append来扩容, 会自动更换底层数组;
a := []int{1, 2}
a = append(a, 5, 6)  //向切片末尾添加元素 [1, 2, 5, 6]
a = append(a, []int{5, 6}...)  //以切片的方式添加 [1, 2, 5, 6]
a = append([]int{5, 6}, a...)  //向切片的开头添加 [5, 6, 1, 2]
a = append(a[:i], append([]int{999}, a[i:]...)...)  //在第i个位置插入999
注: append()函数的第一个参数必须是切片类型;
注: 切片的扩容策略, 如果当前容量不够, 会自动将容量增大一倍, 如
a := make([]int, 6, 6);
a = append(a, 10);
fmt.Println(len(a), cap(a));  //7 12
4, 内置函数copy
var c = []int{0, 0, 0}
copy(c, b)  //c复制b
按照较小个数的那个切片进行复制, 返回实际复制的元素个数;
注: 直接赋值与copy的区别: 
直接赋值是浅复制, 改变一个切片会影响到另一个;
而copy是深复制, 改变一个切片不会影响到另一个;
5, 删除切片中的元素
go语言中没有直接删除元素的方法;
//删除前n个元素
a = a[n:]
//删除后n个元素
a = a[:len(a)-n]
//删除中间index索引的元素
a = append(a[:index], a[index+1:]...)


>>指针
1, 普通变量与指针
a := 12
p := &a  //取变量的地址
b := *p  //取指针指向的地址存放的值
2, 声明指针变量, 默认为nil, 而通过new()得到的指针变量, 其指向一块内存区域, 所以不等于nil;
var p *int  //p == nil
var p = new(int)  //p != nil
3, go语言中的指针不能进行算术运算;


>>Map
1, 创建map
var m map[string]int  //这种声明m为nil, 不能增加key-value
m := make(map[string]int)  //这种声明m不为nil, 可以增加key-value
m := map[string]int{"zhao": 30, "qian": 26, "sun": 28,}
2, 遍历
for k, v := range m {
	fmt.Println(k, v)
}
3, map的基本操作
1)查找
a := m["cao"]  //如果key不存在则返回0
a, ok := m["cao"]  //ok为false表示key不存在
2)新增或修改
m["cao"] = 32  //向map中添加键值对, key不存在则添加, key存在则修改对应value
3)删除
delete(m, "cao")  //删除键值对, 无key也不会报错
4, 给map的key或value排序
先将key或value保存到切片中, 通过sort包给切片排序, 然后遍历切片取值;
5, map与切片的结合
//元素为map类型的切片
s := make([]map[string]string, 3, 3)
s[0] = map[string]string{"username": "zhao", "age": "26",}
s[1] = map[string]string{"username": "qian", "age": "28",}
s  //map[map[age:26 username:zhao], map[age:28 username:qian], map[]]
//value为切片类型的map
m := make(map[string][]string)
m["skill"] = []string{"java", "golang", "js"}
m["hobby"] = []string{"阅读", "音乐", "跑步"}
m  //map[skill:[java golang js] hobby:[阅读 音乐 跑步]]
6, 举例: 统计一个段落中每个单词出现的次数
func (s string) map[string]int {
	m := make(map[string]int)
	bs := strings.Split(s, " ")
	for _, v := range bs {
		m[v]++
	}
	return m
}
注: golang中没有set数据类型;


>>函数
1, 函数定义
func fn(a int, b int) int { return a + b }
func fn(a, b int) (r int) { //多个参数的类型相同, 可以使用简写形式
	r = a + b
	return 
}
func fn(a, b int) (c int, d int){ //返回多个结果
	c = a + b
	d = a - b
	return 
}
2, 匿名函数
//将匿名函数赋值给变量
var f1 = func(a int, b int) int {
	return a + b
}
//匿名函数直接调用
func(a int, b int) int {
	return a + b
}(4, 6)
注: golang中函数内部不允许再定义另外一个函数, 但可以使用匿名函数的形式, 如
func test() {
	var f = func(a, b int) int {
		//...
	}
	f()
}
3, 闭包
闭包是指返回函数的函数, 内部函数可以使外部函数的变量常驻内存, 避免全局变量的污染;
func f() func() int {
	value := 1
	return func() int {
		value++
		return value
	}
}
fn := f()  
fn()  //2
fn()  //3
4, 可变参数
可变参数变量是一个包含所有参数的切片;
func f(args ...int) int {  //args的类型是 []int
	sum := 0
	for _, v := range args {
		sum += v
	}
	return sum
}
调用:
1)扁平化传递多个参数
fn(1, 2, 3)
2)传递切片, 需要在切片后面添加...
fn([]int{1, 2, 3}...)
注: 传递param表示传递的是param变量本身, 而param...表示将切片内容拆开成扁平化的多个元素;
5, 给函数起类型别名
type calc func(int, int) int
6, 函数可以作为另一个函数的参数或者返回值
//函数作为参数
func calc(x, y int, f func(int, int) int) int {
	return f(x, y)
}
//调用
rs := calc(4, 3, func(a, b int) int {  //实参可以直接用匿名函数的形式, 也可以传入函数名
	return a * b
})


>>defer
1, defer语句在函数结束或程序异常退出时执行, 当有多个defer语句时, 后面的先执行;
defer后面跟函数调用;
//执行结果: start end 2 1
fmt.Print("start")
defer fmt.Print(1)
defer fmt.Print(2)
fmt.Print("end) 
//执行结果: start end 1 2
fmt.Print("start")
defer func(){
	fmt.Print(1)
	fmt.Print(2)
}()
fmt.Print("end")
2, defer f(n) 实参n是立即确定, 而f(n)的执行才是延时确定的;
当有多个defer时, 从上往下即时确定实参n, 然后从下往上延时执行函数;
func f(id string, a, b int) int {
	r := a + b
	fmt.Println(id, a, b, r)
	return r
}
func main() {
	x, y := 1, 2
	defer f("aa", x, f("a", x, y))
}
执行结果: 
a 1 2 3
aa 1 3 4



>>错误处理
go语言没有像类似java语言中的异常处理机制, 而是在函数中返回一个错误接口error, 调用者须对这个返回值是否等于nil进行判断;
1, error接口
type error interface {
	Error() string
}
2, 自定义一个错误
var err = errors.New("this is an error")
//例: 自定义除数为0的错误
func div(a, b int) (int, error) {
	if b == 0 {
		return 0, errors.New("这是除数为零的错误")
	}
	return a / b, nil
}
func main() {
	fmt.Println(div(1, 0))  //0 这是除数为零的错误
}


>>异常处理: 宕机(panic)与恢复(recover)
1, panic抛出一个异常, recover捕获异常并处理; recover()必须跟在defer后面;
只有加上defer...recover(), 当程序遇到异常时, 才可以继续往下执行;
func f() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("处理f抛出的异常")
		}
	}()
	panic("f抛出一个异常")
}
2, 举例
func f(a, b int) int {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("发生错误", err)
		} else {
			fmt.Println("一切正常", err)
		}
	}()
	return a / b
}
func main() {
	f(2, 1)  //一切正常 <nil>
	f(2, 0)  //发生错误 runtime error: integer divide by zero
}


>>通过内存缓存来提升性能
1, 普通的斐波那契数列生成
func fibonacci(n int) (res int) {
	if n == 1 || n == 2 {
		res = 1
	} else {
		res = fibonacci(n-1) + fibonacci(n-2)
	}
	return
}
2, 通过内存缓存改进后的斐波那契生成
const LIMIT = 100
var cache [LIMIT]uint64
func fibonacci(n int) (res int) {
	if cache[n] != 0 {  //检查数组中是否已知斐波那契n
		res = cache[n]
		return 
	}
	if n == 1 || n == 2 {
		res = 1
	} else {
		res = fibonacci(n-1) + fibonacci(n-2)
	}
	cache[n] = res  //将生成的斐波那契n保存到数组
	return
}
注: 优化后的性能提升无数倍;


>>排序
1, 快速排序
1)基本类型的快速排序
sort.Ints(slice)  //整型切片
sort.Strings(slice)  //字符串切片
sort.Float64s(slice)  //浮点型切片
2)结构体的快速排序
sort.Slice(slice, func(i, j int) bool {
	if slice[i].age != slice[j].age {
		return slice[i].age < slice[j].age
	}
	return slice[i].name < slice[j].name
})
2, 自定义排序
需要自定义类型来实现sort.Interface接口, 需要实现三个方法:
type MyStringList []string
func (m MyStringList) Len() int { 
	return len(m)
}
func (m MyStringList) Less(i, j int) bool {
	return m[i] < m[j]
}
func (m MyStringList) Swap(i, j int) {
	m[i], m[j] = m[j], m[i]
}
names := MyStringList{"java", "go", "python", "js", "c++", "php",}
sort.Sort(names)  //通过sort.Sort()函数来对切片序列进行排序


>>内建方法
1, make与new
make用于创建slice、map、chan这三种类型, 返回类型的引用;
1)创建切片
s := make([]int, 3)
s := make([]int, 3, 10)
s[0] = 2
s[1] = 4
s[2] = 6
fmt.Printf("%T, %v", s, s)  //[]int, [2, 4, 6]
注: make切片时必须传入第二个参数指明切片的长度, 可选的第三个参数表示初始容量;
2)创建map
m := make(map[string]int)
m["zhao"] = 26
m["qian"] = 22
m["sun"] = 25
fmt.Printf("%T, %v")  //map[string]int, map[qian:22, sun:25, zhao:26]
3)创建channel
ch := make(chan int)  //没有缓存的chan
ch := make(chan int, 3)  //缓存数量为3的chan
4)new
返回指定类型的指针, 可以给任意类型分配内存;
2, append, copy, delete
append与copy应用于slice, 而delete应用于map;
1)append
s := make([]int, 3)
s = append(s, 1)
s = append(s, 6, 7, 8)  //s: [0, 0, 0, 1, 6, 7, 8]
2)copy
a := []int{1, 2, 3}
b1 := make([]int, 2)
copy(b1, a)  //b1: [1, 2]
b2 := make([]int, 4)
copy(b2, a)  //b2: [1, 2, 3, 0]
3)delete
m := map[string]int{"zhao": 24, "qian": 26, "sun": 22,}
delete(m, "qian")  //m: map[zhao:24, sun:22]
3, panic与recover
相当于抛出异常与捕获异常;
func f1() {  //手动触发panic
	fmt.Println("enter f1")
	panic(errors.New("occur a panic"))
	fmt.Println("quit f2")
}	
func f2() {  //宕机恢复
	if p := recover(); p != nil {
		fmt.Printf("Fatal error: %s\n", p)
	}
}
func main() {
	defer f2()
	fmt.Println("enter main")
	f1()
	fmt.Println("quit main")
}
输出如下:
enter main
enter f1
Fatal error: occur a panic
注: defer f2()一定要放在panic()前面, 否则执行不到recover()程序就崩溃了;
4, len, cap, close
len用于string, array, slice, map, chan这几种类型;
cap用于array, slice, chan这几种类型;
close只用于chan类型;
s := make([]int, 3, 10)  //len(s): 3, cap(s): 10
ch := make(chan int, 4)  //len(ch): 0, cap(ch): 4
defer close(ch)


>>time包和日期时间函数
1, 当前时间、时间戳、指定字符串之间的转换
1)获取当前Time对象
now := time.Now()  //类型: time.Time
2)获取各个时间字段
now.Year() / now.Month() / now.Day() / now.Hour() / now.Minute() / now.Second();
3)格式化输出
//自定义输出指定格式:
fmt.Printf("%d-%02d-%02d %02d:%02d:%02d", now.Year(), now.Month(), now.Day(), 
	now.Hour(), now.Minute(), now.Second)
//使用Format()
格式: 2006-年, 01-月, 02-日, 03/15-时(12/24小时制), 04-分, 05-秒
s := now.Format("2006-01-02 03:04:05")
4)获取时间戳
now.Unix()  //单位: 秒
now.UnixNano()  //单位: 纳秒(秒/10^9)
5)将时间戳转换为Time对象
utime := 1655169518
t := time.Unix(int64(utime), 0)  //t: time.Time   //第二个参数表示纳秒的时间戳, 0表示省略
6)将指定日期时间字符串转换为Time对象
s := "1987-07-01 15:30:00"
template := "2006-01-02 15:04:05"  //定义模板与字符串格式匹配
t, err := time.ParseInLocation(template, s, time.Local)
2, 时间常量
time.Hour  //1h0m0s
time.Minute  //1m
time.Second  //1s
time.Millisecond //1ms
time.Microsecond  //1µs
time.Nanosecond  //1ns
3, 日期时间的操作函数
1)将Time对象增加或减少一段时间
t2 := t1.Add(time.Hour)
t2 := t1.Sub(time.Hour)
2)比较两个Time对象的先后
t2.Before(t1)
t2.After(t1)
4, 定时器
1)使用time.Sleep()
time.Sleep(3*time.Second)  //睡眠3秒
2)使用time.NewTicker()
ticker := time.NewTicker(3*time.Second)
for v := range ticker.C {	//无限循环, 每隔3秒执行一次
	//...
	if ... {
		ticker.Stop()  //终止定时器
		break
	}
}


>>json
go语言中json的序列化和反序列化需要通过[]byte类型来中转;
1, json.Marsha1()  //序列化
1)序列化slice, map
o := map[string]int{"zhao": 26, "qian": 32, "sun": 28}
if b, err := json.Marsha1(o); err == nil {
	fmt.Println(string(b))
}
2)序列化结构体对象
type Person struct {
	Name string
	Age int `json:"age"`
}
p := Person{"zhao", 30,}
temp, err := json.Marsha1(p)  //temp是[]byte类型
s := string(temp)  //json串
注: `json:"age"`表示序列化时给字段取一个别名;
`json:""`标签(Tag)的使用有以下几点:
1)FieldName int `json:"myName"`: 表示在json串里使用myName作为键名;
2)FieldName int `json:"myName,omitempty"`: 表示在json串里使用myName作为键名, 如果该字段为空则省略;
3)FieldName int `json:",omitempty"`: 表示使用默认键名, 如果该字段为空则省略;
4)FieldName int `json:"-"`: 表示在json串忽略该字段;
2, json.Unmarsha1()  //反序列化
1)反序列化slice, map
s := `{"zhao": 26, "qian": 32, "sun": 28}`
o := make(map[string]int)
json.Unmarshal([]byte(s), &o)
fmt.Printf("%T, %v", o, o)
2)反序列化结构体对象
s := `{"Name": "zhao", "Age": 30}`
ptr := new(Person)
err := json.Unmarsha1([]byte(s), ptr)  //ptr就是指向对象的指针


>>结构体
1, 实例化
结构体的定义只是一种内存布局的描述, 只有当实例化时, 才会真正分配内存;
//基本的实例化形式
type Point struct {  //定义
	X, Y int
}
var p Point  //实例化  {0, 0}
p.X = 2
p.Y = 6
2, 结构体指针
p := new(Point)  //类型: *main.Point
p.X = 2  //指针类型仍然可以像普通类型一样使用.来访问成员
p.Y = 6  //底层自动转换 (*p).Y
p2 := &Point{}  //取地址实例化
p2 := &p1 
注: 取地址实例化是最广泛的一种结构体实例化方式;
3, 初始化
1)使用键值对形式
p1 := Point{x: 2, y: 4}
2)使用列表形式
p1 := Point{2, 4}
使用列表形式必须初始化所有字段, 且顺序一致;
4, 匿名结构体
ins := struct {
	字段1 类型1
	字段2 类型2
}
msg := &struct {  //定义部分
	id int 
	data string 
}{  //值初始化部分
	1024, 
	"hello",
}
5, 嵌入结构体
//定义结构体以及方法
type Person struct {
	Name string
	Age int
}
func (p Person) say() {
	fmt.Println(p.Name + " is saying")
}
type Student struct {
	Person
	Major string
}
func (s Student) study() {
	fmt.Println(s.Name + " is studying " + s.Major)
}
//测试用例
s := Student{
	Person{"zhao", 26},
	"Maths",
}
p := new(Student)
p.Name = "zhao"
p.Age = 26
p.Major = "maths"
p.say()
p.study()
注: golang中没有继承, 可以使用嵌入结构体来实现继承;
6, 方法
go的方法是作用在接收器上的一个函数;
接收器可以是任何类型(除了接口类型), 也就是说任何类型都可以定义方法, 比如基本类型的别名类型、函数类型等;
接收器分为指针类型接收器和非指针类型接收器, 区别在于是否能修改结构体的字段;
7, 可以为任意类型添加方法
type MyInt int
func (m MyInt) IsZero() bool {
	return m == 0
}
func (m MyInt) Add(other int) int {
	return other + int(m)
}


>>接口
1, 如果一个任意类型T的方法集为一个接口类型的方法集的超集, 则称类型T实现了此接口类型;
type Walker interface{
	Walk()
}
type Person struct {}
func (p Person) Walk() {
	fmt.Println("Person can walk")
}
var w Walker = Person{}
w.Walk()
当一个类型实现了接口, 就可以把该类型变量赋值给接口类型的变量;
注: Go语言中实现接口是隐式的, 叫做非侵入式设计; 
2, nil
nil只能被赋值给指针或者接口;
只有显式地将nil赋值给接口时, 接口才等于nil, 如
var w *Walker = nil
w == nil  //true
如果不是显式的将nil赋值给接口, 那么接口将不等于nil, 如
var p *Person = nil  
var w Walker = p  //*Person实现了Walker接口
p == nil  //false
3, 类型断言
1)x.(T)
var x interface{} = 10
v, ok := x.(int)  //10 true
v, ok := x.(string)  // "" false
2)x.(type)
只能用于switch结构中;
switch x.(type) {
	case int:
		//...
	case string: 
		//...
	default:
		//...
}
4, 接口的嵌套
type Writer interface {
	Write(p []byte) (n int, err error)
}
type Closer interface {
	Close() error
}
type WriteCloser interface {
	Writer
	Closer
}
如果一个类型同时实现了Writer和Closer接口, 则表示该类型实现了WriteCloser接口;


>>通道Channel
1, Channel用于在不同Goroutine之间传递类型化的数据, 是并发安全的, 而其他数据类型都不是并发安全的;
chan T  //声明
ch1 := make(chan string, 5)  //声明通道类型的变量并为其赋值, 第二个参数表示通道的长度
ch1 <- "value1"  //向通道发送数据
value := <- ch1  //从通道接受数据
value, ok := <- ch1  //ok为false表示通道已关闭
close(ch1)  //关闭通道
注: 向已满通道发送数据, 或从空通道接受数据, 都会引起阻塞;
2, 缓冲通道与非缓冲通道
ch := make(chan string, 5)  //缓冲通道
ch := make(chan string, 0)  //非缓冲通道
3, 双向通道, 发送通道, 接受通道
ch := make(chan int, 5)  //双向通道
type Receiver <- chan int  //接受通道
var receiver Receiver = make(chan int, 5)
type Sender chan <- int  //发送通道
var sender Sender = make(chan int, 5)


>>并发
协程(goroutine) + 协程间通信(channel) + 协程同步(sync.waitgroup)
1, 协程
func main() {
	go f1()
	go f2()
	time.Sleep(time.Second)  //主程序结束前有足够时间让协程执行完毕
}
2, 协程间通信--channel
1)多个协程之间通过channel通信;
2)select
select语句中的case关键字只能后跟通道的发送或者接收操作;
ch1 := make(chan int, 2)
ch2 := make(chan string, 1)
ch1 <- 2
ch1 <- 6
ch2 <- "zhao"
for {
	select {
		case n := <- ch1:
			fmt.Println("ch1: ", n)
		case n := <- ch2:
			fmt.Println("ch2: ", n)
		default:
			fmt.Println("通道里已没有数据")
	}
}
注: 如果当前多个通道有数据, select会随机选择一个通道case执行;
e, ok := <- ch  //如果ch没数据则阻塞, 如果ch已关闭则ok为false;
3, 协程同步
主协程等待其他协程执行完再结束: 系统工具 sync.WaitGroup
Add(delta int)  //添加计数
Done()  //移除一个计数, 等价于Add(-1)
Wait()  //阻塞直到所有任务完成
举例:
var wg sync.WaitGroup
func tast(i int) {
	//defer wg.Done()
	fmt.Println("task...", i)
	//...
	wg.Done()
}
func main() {
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go task(i)
	}
	wg.Wait()
}
4, 举例
1)模拟多个顾客抢购鸡蛋
func main() {
	var wg sync.WaitGroup
	var ch = make(chan int, 10)  
	for i := 1; i <= 10; i++ {  //将10个鸡蛋放入channel
		ch <- i
	}
	for i := 1; i <= 100; i++ {  //100个顾客并发抢购鸡蛋
		wg.Add(1)
		go func(n int) {  //单个抢鸡蛋的协程
			select {
				case egg := <- ch:
					fmt.Printf("第%d个顾客抢到第%d个鸡蛋\n", n, egg)
				default:
					fmt.Printf("当前第%d个顾客, 鸡蛋已抢完\n", n)
			}
			wg.Done()
		}(i)
	}
	wg.Wait()
}
2)生产者-消费者
var chan = make(chan int, 10)
func producer(n int) {  //生产者
	ch <- n
	fmt.Println("生产:", n)
}
func consumer() {  //消费者
	fmt.Println("消费:", <- ch)
}
func main() {
	for i := 1; i <= 10; i++ {
		go producer(i)
		go consumer()
	}
}















