>>JSON
1, FastJSON
1)对象与json串的转换
//对象转换成json串
String s = JSON.toJSONString(employee);
默认情况下, Date字段会被转换成时间戳, 可以在Employee类的字段前添加注解来对输出进行格式化: 
@JSONField(name="hiredate", format="yyyy-MM-dd")
private Date hdate;
@JSONField(serialize=false) //不对dname序列化
private String dname;
//json串转换成对象
Employee employee = JSON.parseObject(s, Employee.class);
2)对象数组/集合与json串的转换
List<Employee> list = new ArrayList<>();
//对象集合转换成json串
String s = JSON.toJSONString(list);
//json串转换成对象集合
List<Employee> list2 = JSON.parseArray(s, Employee.class);


>>正则表达式
//创建正则表达式对象
Pattern p = Pattern.compile("***"); //参数不需要//
//匹配正则表达式
Matcher m = p.matcher(s);
//查找匹配结果
while(m.find()){
	m.group(0); //原始匹配
	m.group(1)/m.group(2); //子组
}


>>过滤器
1, Filter是Servlet模块下的内置组件, 作用是对URL进行统一的拦截处理;
可以定义多个过滤器，形成过滤链, 请求依次通过过滤链, 响应再以相反的顺序通过过滤链;
开发过滤器的步骤:
1)实现Filter接口;
2)重写doFilter()方法;
public class Demo1 implements Filter {
	@Override
	public void destroy() { ... }
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		System.out.println("过滤器已生效");
		chain.doFilter(request, response); //将请求与响应对象沿着过滤链依次向后处理
	}
	@Override
	public void init(FilterConfig filterConfig) throws ServletException { ... }

}
3)在web.xml中对过滤器进行配置说明拦截url的范围;
<filter>
  <filter-name>myFilter</filter-name>
  <filter-class>com.imooc.test.Demo1</filter-class>
</filter>
<filter-mapping>
  <filter-name>myFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>2
或采用更简洁的注解形式代替配置形式:
@WebFilter(filterName="MyFilter",urlPatterns="/*")
2, 过滤器的生命周期
初始化-Filter.init(): tomcat启动时;
提供服务-Filter.doFilter(): 每次来请求时;
销毁-Filter.destroy(): comcat关闭或重启;
注: Filter也是单例模式，且该实例对象在并发环境中采用多线程提供服务(单例多线程);
3, 详解
1)对请求和响应的字符集进行设置
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
	HttpServletRequest req = (HttpServletRequest)request;
	req.setCharacterEncoding("utf-8");
	HttpServletResponse resp = (HttpServletResponse) response;
	resp.setContentType("text/html;charset=utf-8");
	chain.doFilter(request, response);
}
注: HttpServletRequest是ServletRequest的子接口, 接口只是J2EE的规范，tomcat中具体由RequestFacade类来实现;
HttpServletRequest接口和ServletRequest接口在servlet-api.jar中，属于J2EE的规范包;
RequestFacade类在catalina.jar中，属于tomcat的具体实现包;
2)过滤器参数化
//配置形式参数化
将doFilter()设置的信息通过配置形式或注解形式来进行参数化，需要的时候再动态提取;
<filter>
  <filter-name>Demo1</filter-name>
  <filter-class>com.imooc.test.Demo1</filter-class>
  <init-param>
  	<param-name>encoding</param-name>
  	<param-value>utf-8</param-value>
  </init-param>
</filter>
public class Demo1 implements Filter{
	private String encoding;
	public void init(FilterConfig filterConfig){
		encoding = filterConfig.getInitParameter("encoding");
	}
	public void doFilter(){
		//使用encoding
	}
}
//注解形式参数化
@WebFilter(filterName="Demo1", urlPatterns="/*" 
	initParams={
		@WebInitParam(name="encoding", value="UTF-8"),
		@WebInitParam(name="p1", value="v1"),
		@WebInitParam(name="p2", value="v2")
	})
3)url-pattern
常用写法有以下三种形式: 
/index.jsp  //精准匹配
/serlvet/*  //前缀限定的模糊匹配
*.jsp       //后缀限定的模糊匹配(注意前面没有斜杠/)
注: 斜杠/指映射Web应用根路径, 且只对Servlet生效;
/与/*含义不同，前者指向根路径，后者代表所有;
如果要同时拦截多个url，可以通过添加多个<url-mapping>，其<filter-name>相同;
注解形式:
@WebFilter(filterName="MyFilter", urlPatterns="/servlet/*")  //指定单个url
@WebFilter(filterName="MyFilter", urlPatterns={"/", "/servlet/*", "*.jsp"}) //指定多个url
4)过滤链
请求->过滤器1->过滤器2->服务器servlet->响应->过滤器2->过滤器1->客户端；
每一个过滤器应具有单独的职能;
过滤器的执行顺序以<filter-mapping>为准;
调用chain.doFilter()将请求向后传递;
chain.doFilter()之前的语句在请求发往服务器的时候处理，chain.doFilter()之后的语句在响应
回传给客户端的时候处理;
如果不调用chain.doFilter()方法, 请求到达该过滤器后就不再往后传递，直接原地返回;
如果多个过滤器都按照注解形式配置, 执行的先后顺序是根据过滤器类名的字母顺序决定, 不推荐;
4, 举例: 多端设备自动适配
目录
WebContent
	desktop
		index.html
	mobile
		index.html
	WEB-INFO
		web.xml
//MyFilter.java
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain){
	HttpServletRequest req = (HttpServletRequest)request;
	HttpServletResponse resp = (HttpServletResponse)response;
	String uri = req.getRequestURI();
	if(uri.startsWith("/desktop") || uri.startsWith("/mobile")){  //将请求向后传递
		chain.foFilter(request, response);
	}else{
		String userAgent = req.getHeader("user-agent").toLowerCase();
		String targetURI = "";
		if(userAgent.indexOf("android") > -1 || userAgent.indexOf("iphone") > -1){
			targetURI = "/mobile" + uri;
			resp.sendRedirect(targetURI);  //将请求返回，进行响应重定向
		}else{
			targetURI = "/desktop" + uri;
			resp.sendRedirect(targetURI);
		}
	}
}



>>监听器
1, Listener是Servlet模块下的内置组件, 作用是对web应用对象的行为进行监控, 
通过Listener监听自动触发指定的功能代码;
三种监听对象: 
ServletContext(application) - 对全局ServletContext及其属性进行监听;
HttpSession(session) - 对用户会话及其属性操作进行监听;
ServletRequest(request) - 对请求及其属性操作进行监听;
2, 开发监听器的步骤
1)实现XxxListener接口，实现接口中对应的方法;
2)在web.xml中配置<listener>使监听器生效， 或使用注解形式配置;
3, 六种常用监听接口
内置对象监听接口(监听对象的创建与销毁):
ServletContextListener;
HttpSessionListener;
ServletRequestListner;
属性监听接口:
ServletContextAttributeListener;
HttpSessionAttributeListener;
ServletRequestAttributeListner;
4, 代码实现
@WebListener  //注解形式配置
public class MyListener implements HttpSessionListener, HttpSessionAttributeListener{
	@Override
	public void sessionCreated(HttpSessionEvent se){
		sysout("HttpSession创建, SessionId: " + se.getSession().getId());
	}
	@Override
	public void sessionDestroy(HttpSessionEvent se){
		sysout("HttpSession销毁");
	}
	@Override
	public void attributeAdded(HttpSessionBindingEvent event){
		sysout("新增session属性: " + event.getName() + "->" + event.getValue());
	}
	@Override
	public void attributeRemoved(HttpSessionBindingEvent event) { ... }
	@Override
	public void attributeReplaced(HttpSessionBindingEvent event) { ... }
}
5, 应用场景
1)流量分析统计
2)静态数据预加载


>>FreeMarker模板引擎
1, 模板引擎
模板+数据->模板引擎->展现结果
主流模板引擎: JSP, FreeMarker, Beetl;
freemarker文件以.ftl命名
2, JSP与FreeMarker的区别
JSP是官方标准，执行方式是编译型，执行效率高，开发效率低，扩展能力弱，数据提取用JSTL+EL;
FreeMarker不是官方标准，需要引入jar包，执行方式为解释型，执行效率低，开发效率高，扩展能力强，数据提取用内置标签;
3, 需要引入freemarker.jar包，eclipse会提示安装ftl编辑器，用于智能提示，不装也可以;
//主java文件: main()
//1，加载模板
Configuration config = new Configuration(Configuration.VERSION_2_3_28);  //创建核心配置对象
config.setClassForTemplateLoading(FreeMarkerSample.class, "");  //设置加载的目录
Template t = config.getTemplate("sample.ftl");  //得到模板对象
//2，创建数据
Map<String, Object> data = new HashMap<>();
data.put("site", "百度");
data.put("url", "http://www.baidu.com");
data.put("date", new Date());
data.put("number", 1234567.7654321);
data.put("leader", new Person("zhao", 40));
//3，产生输出
t.process(data, new OutputStreamWriter(System.out));
//模板文件: sample.ftl
${site}-${url}
4, ftl取值
${属性名}  //直接取值
${属性名!默认值}  //使用默认值，如${author!"张三"}
${属性名?string}  //格式化输出，如
	${date?string("yyyy-MM-dd HH:mm:ss SSS")},
	${number?string("0.00")},
	${leader.name}
string用于三目运算符:
${(words?index_of("o") != -1)?string("是", "不是")}
5, 条件判断
1)if
data.put("state", 1);
<#if state == 1>状态；正在使用
<#elseif state == 2>状态：闲置
<#else>状态：无效状态
</#if>
??代表判断对象是否为空，如果为空则不输出，如
<#if computer.user??>
用户：${computer.user}
</#if>
注: 在标签外引用变量用${}，在标签内直接使用变量名;
2)switch
<#switch state>
	<#case 1>正在使用<#break>
	<#case 2>闲置<#break>
	<#default>无效状态
</#switch>
6, 循环
1)列表
<#list datas as v>
	${v_index}-${v}
</#list>
注: 迭代变量_index代表索引;
2)Map
<#list datas?keys as k>
	${k}:${datas[k]}
</#list>
7, freemarker的内建函数
${words?length}  //长度
${words?index_of("o")}  //第一次出现的索引
${words?replace("o", "*")}  //全部替换
${words?upper_case/lower_case}  //大小写转换
${n?round/floor/ceiling} //四舍五入/向下取整/向上取整
${list?size}  //集合元素的个数
${list?first/last}  //集合的第一个元素/最后一个元素
${list?reverse}  //集合反转
${list?sort}  //集合排序
${list?sort_by("age")}  //集合元素按年龄排序
如 
<#list list?sort_by("age") as c>
	${c.name}-${c.age}
</#list>
8, freemarker与servlet整合
步骤:
1)新建Dynamic工程, 将freemarker.jar包放入WEB-INF/lib目录, 在WEB-INF目录下新建ftl文件夹,
以后的ftl文件都放在WEB-INF/ftl文件夹下;
2)配置web.xml
<servlet>
	<servlet-name>freemarker</servlet-name>
	<servlet-class>freemarker.ext.servlet.FreemarkerServlet</servlet-class>
	<init-param>
		<param-name>TemplatePath</param-name>
		<param-value>/WEB-INF/ftl</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>freemarker</servlet-name>
	<url-pattern>*.ftl</url-pattern>
</servlet-mapping>
3)写servlet与ftl文件
//ListServlet.java
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	List<Employee> list = new ArrayList<>();
	list.add(new Employee(1001, "张三", 32));
	list.add(new Employee(1002, "李四", 38));
	request.setAttribute("list", list);
	request.getRequestDispatcher("employee.ftl").forward(request, response);
}
//employee.ftl
<#list list as v>
<tr>
	<td>${v_index + 1}</td>
	<td>${v.empno?string("0")}</td>
	<td>${v.ename}</td>
	<td>${v.eage}</td>
</tr>
</#list>