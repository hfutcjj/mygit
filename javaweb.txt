>>外网的jar包网页打不开的解决方案
通过阿里云的文件仓库下载: maven.aliyun.com

>>XML 可扩展标记语言
>>XML文档语法规则
1, 基础
1)xml与html
xml没有预定义标签, html存在大量预定义标签;
xml重在保存与传输数据, html用于显示信息;
2)xml的用途
java程序的配置描述文件;
用于保存程序产生的数据;
网络间的数据传输;
3)xml文档结构
第一行必须是xml声明, 有且只有一个根节点;
<?xml version="1.0" encoding="UTF-8" ?>
4)处理特殊字符
//使用字符实体
&lt;(<), &gt;(>), $amp;(&), &apos;('), &quot;(");
//使用CDATA标签
CDATA指的是不应由XML解析器进行解析的文本数据, 原义输出;
<![CDATA[
	...
]]>
>>XML语义约束
1, 语义约束一: DTD
1)规定XML文档中允许和不允许出现哪些元素;
2)语义约束的两种定义方式: DTD 和 XML Schema;
3)DTD
文档类型定义, 文件扩展名为.dtd;
<!ELEMENTS hr (employee)> //hr节点下只允许出现一个employee子节点
注: employee后面添加+, *, ?分别表示允许出现1~n次, 0~n次, 0~1次节点
<!ELEMENTS employee (name,age,salary,department)> //employee节点下必须包含以下四个节点，且按顺序出现
<!ELEMENTS name (#PCDATA)> //name标签体只能是文本, #PCDATA表示文本
<!ATTLIST employee number CDATA ""> 节点中的属性声明 number-属性名 CDATA-类型 ""-默认值
4)举例
//hr.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hr SYSTEM "hr.dtd"> //引入dtd文件, hr-根节点, SYSTEM-本地
<!-- 人力资源管理系统 -->
<hr>
	<employee no="101">
		<name>张三</name>
		<age>31</age>
		<salary>4000</salary>
		<department>
			<dname>会计部</dname>
			<address>XX大厦B103</address>
		</department>
	<employee>
	<employee> 
		//同上(省略) 
	</employee>
</hr>
//hr.dtd
<?xml version="1.0" encoding="UTF-8" ?>
<!ELEMENT hr (employee+)>
<!ELEMENT employee (name,age,salary,department)>
<!ATTLIST employee no CDATA "">
<!ELEMENT name (#PCDATA)>
<!ELEMENT age (#PCDATA)>
<!ELEMENT salary (#PCDATA)>
<!ELEMENT department (dname,address)>
<!ELEMENT dname (#PCDATA)>
<!ELEMENT address (#PCDATA>
2, 语义约束二: SML schema
1)XML schema是W3C标准, 提供了数据类型、格式限定、数据范围等特性, 使用很广泛;
2)举例
//hr.xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- 人力资源管理系统 -->
<hr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="hr.xsd">
...(省略)
//hr.xsd
<?xml version="1.0" encoding="UTF-8" ?>
<schema xmlns="http://www.w3.org/2001/SMLSchema">
<element name="hr">
	<complexType>
		<sequence>
			<element name="employee" minOccurs="1" maxOccurs="999">
				<complexType>
					<sequence>
						<element name="name" type="string"></element>
						<element name="age" type="integer"></element>
						<element name="salary" type="integer"></element>
						<element name="department">
							<complexType>
								<sequence>
									<element name="dname" type="string"></element>
									<element name="address" type="string"></element>
								</sequence>
							</complexType>
						</element>
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>
</element>
>> XML文档解析
1, java利用DOM4j来解析XML文档, DOM4j中的SAXReader类是读取XML文件的核心类, 用于将XML解析
后以"树"的形式保存在内存中;
DOM4j需要下载, 然后将DOM4j引入到java工程，方法:
在工程下建立文件夹lib，将DOM4j复制到lib下，然后右键DOM4j, 点击Build Path即可;
2, 举例，使用DOM4j读取hr.xml表中的员工信息
String file = "E:/java/workspace/test/src/hr.xml";
SAXReader reader = new SAXReader();
Document document = reader.read(file); //将xml文件解析成DOM树
Element root = document.getRootElement(); //获取xml文件的根节点
List<Element> employees = root.elements("employee"); //获取指定元素的集合
for(Element v : employees){
	sysout(v.element("name").getText() + "  " +  //element()获取一个子元素, getText()-获取文本值
		v.element("age").getText() + "  " +
		v.element("salary").getText() + "  " + 
		v.element("department").element("dname").getText() + "  " + 
		v.element("department").element("address").getText() + "  " + 
		v.attribute("no").getText());  //attribute()获取属性节点
}
3, 举例, 给hr.xml表增加一条员工信息
Element employee = root.addElement("employee");
employee.addAttribute("no", "103");
employee.addElement("name").setText("赵六");
employee.addElement("age").setText("25");
employee.addElement("salary").setText("3600");
Element department = employee.addElement("department");
department.addElement("dname").setText("人事部");
department.addElement("address").setText("XX大厦B106");
Writer writer = new OutputStreamWriter(new OutputStreamFile(file), "UTF-8");
document.write(writer);
writer.close();
3, XPath路径表达式
1)XPath是XML文档中查找数据的语言;
XPath查询比较方便和高效，建议优先使用XPath来查询xml的数据;
2)基本语法
/hr/employee  //hr下的employee子元素
//employee  //所有employee元素
//employee[salary<3000]  //工资小于3000的employee元素
//employee[name='张三']  //名字叫张三的employee元素
//employee[@no=3304]  //no属性等于3304的employee元素
//employee[1]  //第一个employee元素
//employee[last()]  //最后一个employee元素
//employee[position<6]  //前5个employee元素
//employee[3] | employee[8]  //第3个和第8个employee元素
3)举例
public void xpath(String xpathExp){
	String file = "E:/java/workspace/test/src/hr.xml";
	SAXReader reader = new SAXReader();
	Document document = reader.read(file);
	List<Node> nodes = document.selectNodes(xpathExp);
	for(Node node : nodes){
		Element emp = (Element)node;
		sysout(emp.attribute("no").getText());
		sysout(emp.element("name").getText());
	}
}
new Demo().xpath("//employee[1]");



>>Servlet
>>apache tomcat
1, 免费开源的web应用服务器程序;
2, J2EE与tomcat
J2EE是一组技术规范与指南, 具体实现由软件厂商决定;
tomcat是J2EE WEB(Servlet与JSP)标准的实现者;
3, Servlet是服务器小程序，用于动态生成web内容;
4, 安装
安装J2EE的eclipse, tomcat, 配置tomcat, 然后把tomcat整合到eclipse中;
tomcat的默认端口号是8080;
>>开发Servlet程序的步骤
1, 新建Dynamic Web Project工程;
2, 在工程下建包和类，类继承HttpServlet，并重写service()方法;
//目录结构
hello
	src
		com.imooc.servlet
			FirstServlet.class
//FirstServlet类
protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
	String name = req.getParameter("name");
	String html = "<h1 style='color: red;'>Hello " + name + "</h1>";
	System.out.println("返回给浏览器的数据为: " + html);
	PrintWriter out = resp.getWriter(); //固定写法
	out.println(html);
}
注: service()方法是统一对所有请求进行处理;
专门处理get请求, 重写doGet()方法, 专门处理post请求，重写doPost()方法;
3，配置WEB-INF/web.xml, 绑定URL
在</web-app>上面添加
<!-- 声明Servlet -->
  <servlet>
  	<!-- Servlet的别名 -->
  	<servlet-name>first</servlet-name>
  	<servlet-class>com.imooc.servlet.FirstServlet</servlet-class>
  </servlet>
  <!-- 将Servlet与URL绑定 -->
  <servlet-mapping>
  	<servlet-name>first</servlet-name>
  	<url-pattern>/hi</url-pattern>
  </servlet-mapping>
4, 点击tomcat的debug，在url中输入 http://localhost:8080/hello/hi?name=bing;
>>java web的工程结构
1, eclipse中可以任意定义工作目录，发布后工程会自动存放到tomcat/webapps/目录下;
2, 目录结构
tomcat/webaps              //tomcat应用根目录
	hello                  //工程
		META-INF           
			MENIFEST.MF
		WEB-INF             //web应用的安全目录，应用存放配置文件
			classes        //编译后的class文件
			lib            //三方jar包
			web.xml       //核心部署配置文件
		index.html        //默认首页
访问默认主页: http://localhost:8080/hello
>>Servlet生命周期
1, 加载-web.xml
2, 创建-构造函数
3, 初始化-init()
4, 提供服务-service()
5, 销毁-destroy()
注: Servlet是单例模式, 在Tomcat的整个全局环境中，Servlet实例对象只创建一次;
>>注解简化web.xml配置
直接在自定义的Servlet类上面添加注解:
@WebServlet("/anno")
通配符的使用: @WebServlet("/employee/*")，可用来获得每个员工的信息,
String url = request.getRequestUrl();
String id = url.substring(url.lastIndexOf("/")+1);
>>启动时加载Servlet
1, web.xml使用<load-on-startup>来设置自动加载;
<load-on-startup>0~9999</load-on-startup> //越小越优先
启动时加载常用于系统的预处理, 如创建数据库、数据的导入等;
2, 步骤
1)在自定义的Servlet类中重写init()方法, 方法体内进行预处理的操作;
2)web.xml文件中添加
<servlet>
	<servlet-name>create</servlet-name>
	<servlet-class>com.imooc.servlet.CreateServlet</servlet-class>
	<load-on-startup>0</load-on-startup>
</servlet>
也可以通过注解来简化配置:
@WebServlet(urlPatterns="/unused",loadOnStartup=2)


>>JSP(java server page)
1, 执行过程
Tomcat: jsp页面 (转译)-> Servlet源代码 (编译)-> Servlet字节码 (执行)-> html页面;
jsp的底层就是Servlet;
2, jsp的基本语法
1)JSP代码块
用于在JSP中嵌入java代码, 如 <% java代码; %>;
2)JSP声明构造块
用于声明变量或方法, 如 <%! 声明语句; %>;
3)JSP输出指令
用于在JSP页面显示java代码执行结果, 如 <%= java代码 %>;
4)JSP处理指令
用于提供JSP执行过程中的辅助信息, 如 <%@ jsp指令 %>;
常用的处理指令:
<%@ page %>: 定义当前jsp页面全局设置;
<%@ include %>: 将其他jsp页面与当前jsp页面合并;
<%@ taglib %>: 引入jsp标签库;
举例:
<%@ page contentType="text/html; charset="utf-8" pageEncoding="utf-8" import="java.util.*, java.io" %>
<%@ include file="include/header.jsp" %>



>>请求与响应
1, http是无状态协议，也就是服务端不保留连接的相关信息；
2, request
请求行 + 请求头 + 请求体;
POST /login HTTP/1.1
request header
//header和body之间必须有一空行
request body
注: get请求没有请求体;
3, response
相应行 + 响应头 + 响应体;
HTTP/1.1 200 OK
response header
response body
4, http响应状态码
1XX: 收到请求，正在处理;
2XX: 成功，如 200 OK；
3XX：重定向，表示请求没有成功，需要采取进一步的动作；
4XX：客户端错误，表示客户端提交的请求有错误，如 404 NOT Found;
5XX：服务器错误，如 500;
5, 获取请求头与设置响应头
String userAgent = request.getHeader("User-Agent"); 
response.setHeader("Content-Type", "text/html;charset=utf-8");
//等价于response.setContentType("text/html;charset=utf-8");
6, ContentType
ContentType决定浏览器采用何种方式对响应体进行处理;
text/plain: 纯文本
text/html: html代码
text/xml: xml代码
application/x-msdownload: 需要下载的资源
image/jepg, image/gif, image/...: 图片
7, 请求转发与响应重定向
1)请求转发就是在多个Servlet(JSP)之间跳转, 页面跳转有两种方式: 
请求转发: request.getRequestDispatcher().forward();
响应重定向: response.sendRedirect();
2)举例
假设在工程myServlet下有两个Servlet类, 
@WebServlet("/direct/check")
public class Check extends HttpServlet{
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		System.out.println("用户登录成功");
		//请求转发
		request.getRequestDispatcher("/direct/index").forward(request, response);
		//响应重定向
		response.sendRedirect("/myServlet/direct/index");
	}
}
@WebServlet("/direct/index")
public class Index extends HttpServlet {
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		response.getWriter().println("This is index page");
	}
}
注: 请求转发与响应重定向的参数不同, 响应重定向的参数需要加上工程名;
servlet跳转到jsp页面:
request.getRequestDispatcher("/success.jsp").forward(request, response);
3)两者的区别
请求转发是在Servlet内部完成的, 浏览器只发送一次请求，所以地址栏的url不变;
响应重定向是重新发送一次请求，所以地址栏的url会改变;
8, 请求允许创建自定义属性
request.setAttribute(属性名，属性值);
Object attr = request.getAttribute(属性名);
可通过请求转发, 将第一个servlet中的信息携带到第二个servlet中;
注: 因为请求转发是同一个请求，所以可以携带信息，而响应重定向是两次不同的请求，所以不能这么做;
9, Cookie与Session
1)Cookie
一般在第一次登录时设置Cookie或Session;
如果不设置Cookie的有效期，则默认在关闭浏览器时Cookie失效;
//设置Cookie
Cookie ck = new Cookie("user", "bing");
ck.setMaxAge(n); //设置Cookie的有效期为n秒
response.setCookie(ck);  
//获取Cookie
Cookie[] cks = request.getCookies();
for(Cookie ck : cks){
	ck.getName(); //cookie名
	ck.getValue(); //cookie值
2)Session
Session保存在服务器，通过浏览器Cookie的SessionId值提取用户数据;
SessionId是与浏览器窗口绑定的，如果重新打开浏览器窗口，那么SessionId就会改变, 
之前的Session值就获取不到了;
session在tomcat服务器上默认保存30分钟，30分钟后，session就会被销毁;
//设置Session
HttpSession session = request.getSession();
session.setAttribute("name", "zhao");
//获取Session
HttpSession session = request.getSession();
String name = (String)session.getAttribute("name");
10, ServletContext对象
Servlet上下文对象, 是Web应用全局对象, 一个Web应用只会创建一个Servlet对象;
只要tomcat不关闭，这个对象就一直存在;
//设置ServletContext
ServletContext context = request.getServletContext();
context.setAttribute("title", "this is imooc page");
//取得ServletContext
String title = (String)context.getAttribute("title");
11, 中文乱码问题
1)请求的乱码
tomcat的默认字符集是西欧字符集ISO-8859-1, 是不支持中文字符的;
对于post请求, 将请求体中的字符集转换成utf-8, 在doPost()的第一行加入如下代码
request.setCharacterEncoding("utf-8");
对于get请求, tomcat8.0以上的版本默认发送的就是utf-8的格式，因此无需转换，
对于tomcat8.0以前的版本，需要修改配置文件;
2)响应的乱码
response.setContentType("text/html;charset=utf-8");
12, web.xml的常用配置
1)修改web应用默认页面
<welcome-file>index.html</welcome-file>
2)Servlet通配符映射
@WebServlet("/employee/*")
3)设置全局参数
<context-param>
  <param-name>title</param-name>
  <param-value>imooc page</param-value>
</context-param>
ServletContext context = req.getServletContext();
String title = (String)context.getInitParameter("title");
context.setAttribute("title", title);
注: 把参数写在配置文件里，只要重启tomcat就能生效，如果写在程序里，下次修改参数后需要重新编译程序，
很麻烦;
4)设置404，500等状态码默认页面
<error-page>
  <error-code>404</error-code>
  <location>/error/404.html</location>
</error-page>
<error-page>
  <error-code>500</error-code>
  <location>/error/500.html</location>
</error-page>
//新建错误页面存放目录
WebContent
	error         
		404.html
		500.jsp
//500.jsp
<%@ page contentType="text/html;charset=utf-8" isErrorPage="true" %>
<body>
	<p>服务器内部错误, 错误信息如下: </p>
	<%
		out.println(exception.getClass().getSimpleName() + ": " + exception.getMessage());
	%>
</body>
13, 九大内置对象
1)request       //请求对象-HttpServletRequest
2)response      //响应对象-HttpServletResponse
3)session		//用户会话-HttpSession
4)application	//应用全局对象-ServletContext	
5)out			//输出对象-PrintWriter
6)page          //当前页面对象-this
7)pageContext	//页面上下文对象-PageContext
8)config		//应用配置对象-ServletConfig
9)exception		//应用异常对象-Throwable
注: exception对象只能用在错误页面中, 需要在页面的page指令下增加"isErrorPage"属性;
14, java web应用打包与发布
1)java web应用采用war包进行发布, 发布路径为: {tomcat-home}/webapps
打包: File-Export-Web-WARfile-e:\myServlet.war, 点击startup.bat打开tomcat即可在浏览器中访问;
2)修改默认端口号与浏览器访问路径
//tomcat/conf/server.xml
<Connector connectionTimeout="20000" port="80" protocol="HTTP/1.1" redirectPort="8443"/>
<Context docBase="E:\Java\apache-tomcat-8.5.70\webapps\myServlet" path="/" .../></Host>


>>JSTL与EL表达式
1, EL (表达式语言)
用于简化JSP的输出, 语法: ${作用域.属性名.子属性};
1)作用域对象
pageScope; //从当前页面取值
requestScope; //从当前请求中取值
sessionScope; //从当前会话中取值
applicationScope; //从当前应用获取全局属性值
如果省略作用域对象, EL则按作用域从小到大依次尝试获取;
举例:
${student} //执行对象的toString()方法
${request.student.age}
${emp.salary+300}
2)输出url的参数
EL内置param对象来进行url参数的输出, 语法: ${param.参数名};
url: localhost:8080/info?teacher=zhao
${param.teacher}
2, JSTL (JSP标准标签库)
1)下载标签库定义包与实现包这两个包: taglibs-standard-spec-1.2.5.jar与taglibs-standard-impl-1.2.5.jar;
把这两个包放到/WEB-INF/lib下就可以了, 仅对当前工程有效(推荐);
也可以放在tomcat/lib目录下，对所有工程有效;
2)JSTL按功能划分为五类标签库
核心标签库-core
格式化输出标签库-fmt
SQL操作标签库-sql
XML操作标签库-xml
函数标签库-functions
前两种常用，后面三种基本不用了，有更好的替代方案;
引入JSTL核心库: <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
引入JSTL输出标签库库: <%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
3)core判断标签
<c:if>-单分支判断;
<c:if test="${score >= 60 }">
	<h2 style="color: green">恭喜，你通过测试</h2>
</c:if>
<c:choose>, <c:when>, <c:otherwise>-多分支判断;
<c:choose>
	<c:when test="${grade == 'A' }">
		<h2>你很优秀</h2>
	</c:when>
	<c:when test="${grade == 'B' }">
		<h2>不错哟</h2>
	</c:when>
	<c:otherwise>
		<h2>一切随缘吧</h2>
	</c:otherwise>
</c:choose>
4)core遍历集合
<c:forEach>-遍历集合中的每个对象
<c:forEach items="${persons}" var="p" varStatus="idx">
	第${idx.index + 1}位 <br>
	姓名: ${p.name} 年龄: ${p.age}
</c:forEach>
5)<c:out>
request.setAttribute("val", null);
request.setAttribute("html", "<a href='index.html'>index</a>"); 
<c:out value="${val}" default="无"></c:out>
<c:out value="${html}" escapeXml="true"></c:out>  //原样输出
6)fmt格式化标签库-日期
<fmt:formatDate value="" pattern="">
request.setAttribute("now", new java.util.Date());
<fmt:formatDate value="${now}" pattern="yyyy年MM月dd日 HH时mm分ss秒sss毫秒" />
7)fmt格式化标签库-数字
<fmt:formatNumber value="" pattern="">
request.setAttribute("amt", 1987654.326);
￥<fmt:formatNumber value="${amt}" pattern="0,000.00" />元


>>JSON




