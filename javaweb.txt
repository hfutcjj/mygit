>>外网的jar包网页打不开的解决方案
通过阿里云的文件仓库下载: maven.aliyun.com

>>XML 可扩展标记语言
>>XML文档语法规则
1, 基础
1)xml与html
xml没有预定义标签, html存在大量预定义标签;
xml重在保存与传输数据, html用于显示信息;
2)xml的用途
java程序的配置描述文件;
用于保存程序产生的数据;
网络间的数据传输;
3)xml文档结构
第一行必须是xml声明, 有且只有一个根节点;
<?xml version="1.0" encoding="UTF-8" ?>
4)处理特殊字符
//使用字符实体
&lt;(<), &gt;(>), $amp;(&), &apos;('), &quot;(");
//使用CDATA标签
CDATA指的是不应由XML解析器进行解析的文本数据, 原义输出;
<![CDATA[
	...
]]>
>>XML语义约束
1, 语义约束一: DTD
1)规定XML文档中允许和不允许出现哪些元素;
2)语义约束的两种定义方式: DTD 和 XML Schema;
3)DTD
文档类型定义, 文件扩展名为.dtd;
<!ELEMENTS hr (employee)> //hr节点下只允许出现一个employee子节点
注: employee后面添加+, *, ?分别表示允许出现1~n次, 0~n次, 0~1次节点
<!ELEMENTS employee (name,age,salary,department)> //employee节点下必须包含以下四个节点，且按顺序出现
<!ELEMENTS name (#PCDATA)> //name标签体只能是文本, #PCDATA表示文本
<!ATTLIST employee number CDATA ""> 节点中的属性声明 number-属性名 CDATA-类型 ""-默认值
4)举例
//hr.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hr SYSTEM "hr.dtd"> //引入dtd文件, hr-根节点, SYSTEM-本地
<!-- 人力资源管理系统 -->
<hr>
	<employee no="101">
		<name>张三</name>
		<age>31</age>
		<salary>4000</salary>
		<department>
			<dname>会计部</dname>
			<address>XX大厦B103</address>
		</department>
	<employee>
	<employee> 
		//同上(省略) 
	</employee>
</hr>
//hr.dtd
<?xml version="1.0" encoding="UTF-8" ?>
<!ELEMENT hr (employee+)>
<!ELEMENT employee (name,age,salary,department)>
<!ATTLIST employee no CDATA "">
<!ELEMENT name (#PCDATA)>
<!ELEMENT age (#PCDATA)>
<!ELEMENT salary (#PCDATA)>
<!ELEMENT department (dname,address)>
<!ELEMENT dname (#PCDATA)>
<!ELEMENT address (#PCDATA>
2, 语义约束二: SML schema
1)XML schema是W3C标准, 提供了数据类型、格式限定、数据范围等特性, 使用很广泛;
2)举例
//hr.xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- 人力资源管理系统 -->
<hr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="hr.xsd">
...(省略)
//hr.xsd
<?xml version="1.0" encoding="UTF-8" ?>
<schema xmlns="http://www.w3.org/2001/SMLSchema">
<element name="hr">
	<complexType>
		<sequence>
			<element name="employee" minOccurs="1" maxOccurs="999">
				<complexType>
					<sequence>
						<element name="name" type="string"></element>
						<element name="age" type="integer"></element>
						<element name="salary" type="integer"></element>
						<element name="department">
							<complexType>
								<sequence>
									<element name="dname" type="string"></element>
									<element name="address" type="string"></element>
								</sequence>
							</complexType>
						</element>
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>
</element>
>> XML文档解析
1, java利用DOM4j来解析XML文档, DOM4j中的SAXReader类是读取XML文件的核心类, 用于将XML解析
后以"树"的形式保存在内存中;
DOM4j需要下载, 然后将DOM4j引入到java工程，方法:
在工程下建立文件夹lib，将DOM4j复制到lib下，然后右键DOM4j, 点击Build Path即可;
2, 举例，使用DOM4j读取hr.xml表中的员工信息
String file = "E:/java/workspace/test/src/hr.xml";
SAXReader reader = new SAXReader();
Document document = reader.read(file); //将xml文件解析成DOM树
Element root = document.getRootElement(); //获取xml文件的根节点
List<Element> employees = root.elements("employee"); //获取指定元素的集合
for(Element v : employees){
	sysout(v.element("name").getText() + "  " +  //element()获取一个子元素, getText()-获取文本值
		v.element("age").getText() + "  " +
		v.element("salary").getText() + "  " + 
		v.element("department").element("dname").getText() + "  " + 
		v.element("department").element("address").getText() + "  " + 
		v.attribute("no").getText());  //attribute()获取属性节点
}
3, 举例, 给hr.xml表增加一条员工信息
Element employee = root.addElement("employee");
employee.addAttribute("no", "103");
employee.addElement("name").setText("赵六");
employee.addElement("age").setText("25");
employee.addElement("salary").setText("3600");
Element department = employee.addElement("department");
department.addElement("dname").setText("人事部");
department.addElement("address").setText("XX大厦B106");
Writer writer = new OutputStreamWriter(new OutputStreamFile(file), "UTF-8");
document.write(writer);
writer.close();
3, XPath路径表达式
1)XPath是XML文档中查找数据的语言;
XPath查询比较方便和高效，建议优先使用XPath来查询xml的数据;
2)基本语法
/hr/employee  //hr下的employee子元素
//employee  //所有employee元素
//employee[salary<3000]  //工资小于3000的employee元素
//employee[name='张三']  //名字叫张三的employee元素
//employee[@no=3304]  //no属性等于3304的employee元素
//employee[1]  //第一个employee元素
//employee[last()]  //最后一个employee元素
//employee[position<6]  //前5个employee元素
//employee[3] | employee[8]  //第3个和第8个employee元素
3)举例
public void xpath(String xpathExp){
	String file = "E:/java/workspace/test/src/hr.xml";
	SAXReader reader = new SAXReader();
	Document document = reader.read(file);
	List<Node> nodes = document.selectNodes(xpathExp);
	for(Node node : nodes){
		Element emp = (Element)node;
		sysout(emp.attribute("no").getText());
		sysout(emp.element("name").getText());
	}
}
new Demo().xpath("//employee[1]");



>>Servlet
>>apache tomcat
1, 免费开源的web应用服务器程序;
2, J2EE与tomcat
J2EE是一组技术规范与指南, 具体实现由软件厂商决定;
tomcat是J2EE WEB(Servlet与JSP)标准的实现者;
3, Servlet是服务器小程序，用于动态生成web内容;
4, 安装
安装J2EE的eclipse, tomcat, 配置tomcat, 然后把tomcat整合到eclipse中;
tomcat的默认端口号是8080;
>>开发Servlet程序的步骤
1, 新建Dynamic Web Project工程;
2, 在工程下建包和类，类继承HttpServlet，并重写service()方法;
//目录结构
hello
	src
		com.imooc.servlet
			FirstServlet.class
//FirstServlet类
protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
	String name = req.getParameter("name");
	String html = "<h1 style='color: red;'>Hello " + name + "</h1>";
	System.out.println("返回给浏览器的数据为: " + html);
	PrintWriter out = resp.getWriter(); //固定写法
	out.println(html);
}
注: service()方法是统一对所有请求进行处理;
专门处理get请求, 重写doGet()方法, 专门处理post请求，重写doPost()方法;
3，配置WEB-INF/web.xml, 绑定URL
在</web-app>上面添加
<!-- 声明Servlet -->
  <servlet>
  	<!-- Servlet的别名 -->
  	<servlet-name>first</servlet-name>
  	<servlet-class>com.imooc.servlet.FirstServlet</servlet-class>
  </servlet>
  <!-- 将Servlet与URL绑定 -->
  <servlet-mapping>
  	<servlet-name>first</servlet-name>
  	<url-pattern>/hi</url-pattern>
  </servlet-mapping>
4, 点击tomcat的debug，在url中输入 http://localhost:8080/hello/hi?name=bing;
>>java web的工程结构
1, eclipse中可以任意定义工作目录，发布后工程会自动存放到tomcat/webapps/目录下;
2, 目录结构
tomcat/webaps              //tomcat应用根目录
	hello                  //工程
		META-INF           
			MENIFEST.MF
		WEB-INF             //web应用的安全目录，应用存放配置文件
			classes        //编译后的class文件
			lib            //三方jar包
			web.xml       //核心部署配置文件
		index.html        //默认首页
访问默认主页: http://localhost:8080/hello
>>Servlet生命周期
1, 加载-web.xml
2, 创建-构造函数
3, 初始化-init()
4, 提供服务-service()
5, 销毁-destroy()
注: Servlet是单例模式, 在Tomcat的整个全局环境中，Servlet实例对象只创建一次;
>>注解简化web.xml配置
直接在自定义的Servlet类上面添加注解:
@WebServlet("/anno")
>>启动时加载Servlet
1, web.xml使用<load-on-startup>来设置自动加载;
<load-on-startup>0~9999</load-on-startup> //越小越优先
启动时加载常用于系统的预处理, 如创建数据库、数据的导入等;
2, 步骤
1)在自定义的Servlet类中重写init()方法, 方法体内进行预处理的操作;
2)web.xml文件中添加
<servlet>
	<servlet-name>create</servlet-name>
	<servlet-class>com.imooc.servlet.CreateServlet</servlet-class>
	<load-on-startup>0</load-on-startup>
</servlet>
也可以通过注解来简化配置:
@WebServlet(urlPatterns="/unused",loadOnStartup=2)


>>JSP(java server page)
1, 执行过程
Tomcat: jsp页面 (转译)-> Servlet源代码 (编译)-> Servlet字节码 (执行)-> html页面;
jsp的底层就是Servlet;
2, jsp的基本语法
1)JSP代码块
用于在JSP中嵌入java代码, 如 <% java代码; %>;
2)JSP声明构造块
用于声明变量或方法, 如 <%! 声明语句; %>;
3)JSP输出指令
用于在JSP页面显示java代码执行结果, 如 <%= java代码 %>;
4)JSP处理指令
用于提供JSP执行过程中的辅助信息, 如 <%@ jsp指令 %>;
常用的处理指令:
<%@ page %>: 定义当前jsp页面全局设置;
<%@ include %>: 将其他jsp页面与当前jsp页面合并;
<%@ taglib %>: 引入jsp标签库;
举例:
<%@ page contentType="text/html; charset="utf-8" pageEncoding="utf-8" import="java.util.*, java.io" %>
<%@ include file="include/header.jsp" %>



>>请求与响应
1, http是无状态协议，也就是服务端不保留连接的相关信息；
2, request
请求行 + 请求头 + 请求体;
POST /login.php HTTP/1.1
request header
//header和body之间必须有一空行
request body
注: get请求没有请求体;
3, response
相应行 + 响应头 + 响应体;
HTTP/1.1 200 OK
response header
response body
4, http响应状态码
1XX: 收到请求，正在处理;
2XX: 成功，如 200 OK；
3XX：重定向，表示请求没有成功，需要采取进一步的动作；
4XX：客户端错误，表示客户端提交的请求有错误，如 404 NOT Found;
5XX：服务器错误，如 500;
5, 获取请求头与设置响应头
String userAgent = request.getHeader("User-Agent"); 
response.setContentType("text/html;charset=utf-8");
6, ContentType
ContentType决定浏览器采用何种方式对响应体进行处理;
text/plain: 纯文本
text/html: html代码
text/xml: xml代码
application/x-msdownload: 需要下载的资源
image/jepg, image/gif, image/...: 图片
7, 请求转发与响应重定向
1)就是在多个Servlet(JSP)之间跳转, 有两种方式: 
请求转发: request.getRequestDispatcher().forward();
响应重定向: response.sendRedirect();
2)举例
假设在工程myServlet下有两个Servlet类, 
@WebServlet("/direct/check")
public class Check extends HttpServlet{
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		System.out.println("用户登录成功");
		//请求转发
		request.getRequestDispatcher("/direct/index").forward(request, response);
		//响应重定向
		response.sendRedirect("/myServlet/direct/index");
	}
}
@WebServlet("/direct/index")
public class Index extends HttpServlet {
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		response.getWriter().println("This is index page");
	}
}
注: 请求转发与响应重定向的参数不同, 响应重定向的参数需要加上工程名;
3)两者的区别
请求转发是在Servlet内部完成的, 浏览器只发送一次请求，所以地址栏的url不变;
响应重定向是重新发送一次请求，所以地址栏的url会改变;
8, 请求允许创建自定义属性
request.setAttribute(属性名，属性值);
Object attr = request.getAttribute(属性名);
可通过请求转发, 将第一个servlet中的信息携带到第二个servlet中;
注: 因为请求转发是同一个请求，所以可以携带信息，而响应重定向是两次不同的请求，所以不能这么做;
9, Cookie与Session
1)Cookie
一般在第一次登录时设置Cookie或Session;
如果不设置Cookie的有效期，则默认在关闭浏览器时Cookie失效;
//设置Cookie
Cookie ck = new Cookie("user", "bing");
ck.setMaxAge(n); //设置Cookie的有效期为n秒
response.setCookie(ck);  
//获取Cookie
Cookie[] cks = request.getCookies();
for(Cookie ck : cks){
	ck.getName(); //cookie名
	ck.getValue(); //cookie值
2)Session
Session保存在服务器，通过浏览器Cookie的SessionId值提取用户数据;
SessionId是与浏览器窗口绑定的，如果重新打开浏览器窗口，那么SessionId就会改变, 
之前的Session值就获取不到了;
//设置Session
HttpSession session = request.getSession();
session.setAttribute("name", "zhao");
//获取Session
HttpSession session = request.getSession();
String name = (String)session.getAttribute("name");









