10, ServletContext对象
Servlet上下文对象, 是Web应用全局对象, 一个Web应用只会创建一个Servlet对象;
只要tomcat不关闭，这个对象就一直存在;
//设置ServletContext
ServletContext context = request.getServletContext();
context.setAttribute("title", "this is imooc page");
//取得ServletContext
String title = (String)context.getAttribute("title");
12, web.xml的常用配置
1)修改web应用默认页面
<welcome-file>index.html</welcome-file>
2)Servlet通配符映射
@WebServlet("/employee/*")
3)设置全局参数
<context-param>
  <param-name>title</param-name>
  <param-value>imooc page</param-value>
</context-param>
ServletContext context = req.getServletContext();
String title = (String)context.getInitParameter("title");
context.setAttribute("title", title);
注: 把参数写在配置文件里，只要重启tomcat就能生效，如果写在程序里，下次修改参数后需要重新编译程序，
很麻烦;
4)设置404，500等状态码默认页面
<error-page>
  <error-code>404</error-code>
  <location>/error/404.html</location>
</error-page>
<error-page>
  <error-code>500</error-code>
  <location>/error/500.html</location>
</error-page>
//新建错误页面存放目录
WebContent
	error         
		404.html
		500.jsp
//500.jsp
<%@ page contentType="text/html;charset=utf-8" isErrorPage="true" %>
<body>
	<p>服务器内部错误, 错误信息如下: </p>
	<%
		out.println(exception.getClass().getSimpleName() + ": " + exception.getMessage());
	%>
</body>
13, 九大内置对象
1)request       //请求对象-HttpServletRequest
2)response      //响应对象-HttpServletResponse
3)session		//用户会话-HttpSession
4)application	//应用全局对象-ServletContext	
5)out			//输出对象-PrintWriter
6)page          //当前页面对象-this
7)pageContext	//页面上下文对象-PageContext
8)config		//应用配置对象-ServletConfig
9)exception		//应用异常对象-Throwable
注: exception对象只能用在错误页面中, 需要在页面的page指令下增加"isErrorPage"属性;
14, java web应用打包与发布
1)java web应用采用war包进行发布, 发布路径为: {tomcat-home}/webapps
打包: File-Export-Web-WARfile-e:\myServlet.war, 点击startup.bat打开tomcat即可在浏览器中访问;
2)修改默认端口号与浏览器访问路径
//tomcat/conf/server.xml
<Connector connectionTimeout="20000" port="80" protocol="HTTP/1.1" redirectPort="8443"/>
<Context docBase="E:\Java\apache-tomcat-8.5.70\webapps\myServlet" path="/" .../></Host>


>>JSTL与EL表达式
1, EL (表达式语言)
用于简化JSP的输出, 语法: ${作用域.属性名.子属性};
1)作用域对象
pageScope; //从当前页面取值
requestScope; //从当前请求中取值
sessionScope; //从当前会话中取值
applicationScope; //从当前应用获取全局属性值
如果省略作用域对象, EL则按作用域从小到大依次尝试获取;
举例:
${student} //执行对象的toString()方法
${request.student.age}
${emp.salary+300}
2)输出url的参数
EL内置param对象来进行url参数的输出, 语法: ${param.参数名};
url: localhost:8080/info?teacher=zhao
${param.teacher}
2, JSTL (JSP标准标签库)
1)下载标签库定义包与实现包这两个包: taglibs-standard-spec-1.2.5.jar与taglibs-standard-impl-1.2.5.jar;
把这两个包放到/WEB-INF/lib下就可以了, 仅对当前工程有效(推荐);
也可以放在tomcat/lib目录下，对所有工程有效;
2)JSTL按功能划分为五类标签库
核心标签库-core
格式化输出标签库-fmt
SQL操作标签库-sql
XML操作标签库-xml
函数标签库-functions
前两种常用，后面三种基本不用了，有更好的替代方案;
引入JSTL核心库: <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
引入JSTL输出标签库库: <%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
3)core判断标签
<c:if>-单分支判断;
<c:if test="${score >= 60 }">
	<h2 style="color: green">恭喜，你通过测试</h2>
</c:if>
<c:choose>, <c:when>, <c:otherwise>-多分支判断;
<c:choose>
	<c:when test="${grade == 'A' }">
		<h2>你很优秀</h2>
	</c:when>
	<c:when test="${grade == 'B' }">
		<h2>不错哟</h2>
	</c:when>
	<c:otherwise>
		<h2>一切随缘吧</h2>
	</c:otherwise>
</c:choose>
4)core遍历集合
<c:forEach>-遍历集合中的每个对象
<c:forEach items="${persons}" var="p" varStatus="idx">
	第${idx.index + 1}位 <br>
	姓名: ${p.name} 年龄: ${p.age}
</c:forEach>
5)<c:out>
request.setAttribute("val", null);
request.setAttribute("html", "<a href='index.html'>index</a>"); 
<c:out value="${val}" default="无"></c:out>
<c:out value="${html}" escapeXml="true"></c:out>  //原样输出
6)fmt格式化标签库-日期
<fmt:formatDate value="" pattern="">
request.setAttribute("now", new java.util.Date());
<fmt:formatDate value="${now}" pattern="yyyy年MM月dd日 HH时mm分ss秒sss毫秒" />
7)fmt格式化标签库-数字
<fmt:formatNumber value="" pattern="">
request.setAttribute("amt", 1987654.326);
￥<fmt:formatNumber value="${amt}" pattern="0,000.00" />元


>>JSON
1, FastJSON
1)对象与json串的转换
//对象转换成json串
String s = JSON.toJSONString(employee);
默认情况下, Date字段会被转换成时间戳, 可以在Employee类的字段前添加注解来对输出进行格式化: 
@JSONField(name="hiredate", format="yyyy-MM-dd")
private Date hdate;
@JSONField(serialize=false) //不对dname序列化
private String dname;
//json串转换成对象
Employee employee = JSON.parseObject(s, Employee.class);
2)对象数组/集合与json串的转换
List<Employee> list = new ArrayList<>();
//对象集合转换成json串
String s = JSON.toJSONString(list);
//json串转换成对象集合
List<Employee> list2 = JSON.parseArray(s, Employee.class);


>>JavaBean
符合下列规范的类，就是一个JavaBean;
1)具有一个公有的无参构造函数;
2)所有属性都是private;
3)具有公有的getter/setter方法对私有属性进行读写;
4)这个类时可序列化的;


>>跨域
1, 什么是跨域
http://www.abc.com:8080/scripts/jquery.js
协议: http
子域名: www
主域名: abc.com
端口号: 8080
请求资源路径: scripts/jquery
当协议、子域名、主域名、端口号中任意一个不相同时，都算跨域；
注: js同源策略的限制，js不能跨域调用;
2, 处理跨域的方法
1)js不能跨域，但后端可以跨域处理
比如在北京服务器的后台(www.beijing.com/proxy.php)来调用上海服务器
(www.shanghai.com/sevice.php)的服务，然后再把响应结果返回给前端；
2)通过JSONP的方式，但JSONP只适用于GET请求；
3)在服务器端添加两个头文件：
header('Access-Control-Allow-Origin:*');
header('Access-Control-Allow-Methods:POST,GET');


>>正则表达式
//创建正则表达式对象
Pattern p = Pattern.compile("***"); //参数不需要//
//匹配正则表达式
Matcher m = p.matcher(s);
//查找匹配结果
while(m.find()){
	m.group(0); //原始匹配
	m.group(1)/m.group(2); //子组
}


>>过滤器
1, Filter是Servlet模块下的内置组件, 作用是对URL进行统一的拦截处理;
可以定义多个过滤器，形成过滤链, 请求依次通过过滤链, 响应再以相反的顺序通过过滤链;
开发过滤器的步骤:
1)实现Filter接口;
2)重写doFilter()方法;
public class Demo1 implements Filter {
	@Override
	public void destroy() { ... }
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		System.out.println("过滤器已生效");
		chain.doFilter(request, response); //将请求与响应对象沿着过滤链依次向后处理
	}
	@Override
	public void init(FilterConfig filterConfig) throws ServletException { ... }

}
3)在web.xml中对过滤器进行配置说明拦截url的范围;
<filter>
  <filter-name>myFilter</filter-name>
  <filter-class>com.imooc.test.Demo1</filter-class>
</filter>
<filter-mapping>
  <filter-name>myFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>2
或采用更简洁的注解形式代替配置形式:
@WebFilter(filterName="MyFilter",urlPatterns="/*")
2, 过滤器的生命周期
初始化-Filter.init(): tomcat启动时;
提供服务-Filter.doFilter(): 每次来请求时;
销毁-Filter.destroy(): comcat关闭或重启;
注: Filter也是单例模式，且该实例对象在并发环境中采用多线程提供服务(单例多线程);
3, 详解
1)对请求和响应的字符集进行设置
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
	HttpServletRequest req = (HttpServletRequest)request;
	req.setCharacterEncoding("utf-8");
	HttpServletResponse resp = (HttpServletResponse) response;
	resp.setContentType("text/html;charset=utf-8");
	chain.doFilter(request, response);
}
注: HttpServletRequest是ServletRequest的子接口, 接口只是J2EE的规范，tomcat中具体由RequestFacade类来实现;
HttpServletRequest接口和ServletRequest接口在servlet-api.jar中，属于J2EE的规范包;
RequestFacade类在catalina.jar中，属于tomcat的具体实现包;
2)过滤器参数化
//配置形式参数化
将doFilter()设置的信息通过配置形式或注解形式来进行参数化，需要的时候再动态提取;
<filter>
  <filter-name>Demo1</filter-name>
  <filter-class>com.imooc.test.Demo1</filter-class>
  <init-param>
  	<param-name>encoding</param-name>
  	<param-value>utf-8</param-value>
  </init-param>
</filter>
public class Demo1 implements Filter{
	private String encoding;
	public void init(FilterConfig filterConfig){
		encoding = filterConfig.getInitParameter("encoding");
	}
	public void doFilter(){
		//使用encoding
	}
}
//注解形式参数化
@WebFilter(filterName="Demo1", urlPatterns="/*" 
	initParams={
		@WebInitParam(name="encoding", value="UTF-8"),
		@WebInitParam(name="p1", value="v1"),
		@WebInitParam(name="p2", value="v2")
	})
3)url-pattern
常用写法有以下三种形式: 
/index.jsp  //精准匹配
/serlvet/*  //前缀限定的模糊匹配
*.jsp       //后缀限定的模糊匹配(注意前面没有斜杠/)
注: 斜杠/指映射Web应用根路径, 且只对Servlet生效;
/与/*含义不同，前者指向根路径，后者代表所有;
如果要同时拦截多个url，可以通过添加多个<url-mapping>，其<filter-name>相同;
注解形式:
@WebFilter(filterName="MyFilter", urlPatterns="/servlet/*")  //指定单个url
@WebFilter(filterName="MyFilter", urlPatterns={"/", "/servlet/*", "*.jsp"}) //指定多个url
4)过滤链
请求->过滤器1->过滤器2->服务器servlet->响应->过滤器2->过滤器1->客户端；
每一个过滤器应具有单独的职能;
过滤器的执行顺序以<filter-mapping>为准;
调用chain.doFilter()将请求向后传递;
chain.doFilter()之前的语句在请求发往服务器的时候处理，chain.doFilter()之后的语句在响应
回传给客户端的时候处理;
如果不调用chain.doFilter()方法, 请求到达该过滤器后就不再往后传递，直接原地返回;
如果多个过滤器都按照注解形式配置, 执行的先后顺序是根据过滤器类名的字母顺序决定, 不推荐;
4, 举例: 多端设备自动适配
目录
WebContent
	desktop
		index.html
	mobile
		index.html
	WEB-INFO
		web.xml
//MyFilter.java
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain){
	HttpServletRequest req = (HttpServletRequest)request;
	HttpServletResponse resp = (HttpServletResponse)response;
	String uri = req.getRequestURI();
	if(uri.startsWith("/desktop") || uri.startsWith("/mobile")){  //将请求向后传递
		chain.foFilter(request, response);
	}else{
		String userAgent = req.getHeader("user-agent").toLowerCase();
		String targetURI = "";
		if(userAgent.indexOf("android") > -1 || userAgent.indexOf("iphone") > -1){
			targetURI = "/mobile" + uri;
			resp.sendRedirect(targetURI);  //将请求返回，进行响应重定向
		}else{
			targetURI = "/desktop" + uri;
			resp.sendRedirect(targetURI);
		}
	}
}



>>监听器
1, Listener是Servlet模块下的内置组件, 作用是对web应用对象的行为进行监控, 
通过Listener监听自动触发指定的功能代码;
三种监听对象: 
ServletContext(application) - 对全局ServletContext及其属性进行监听;
HttpSession(session) - 对用户会话及其属性操作进行监听;
ServletRequest(request) - 对请求及其属性操作进行监听;
2, 开发监听器的步骤
1)实现XxxListener接口，实现接口中对应的方法;
2)在web.xml中配置<listener>使监听器生效， 或使用注解形式配置;
3, 六种常用监听接口
内置对象监听接口(监听对象的创建与销毁):
ServletContextListener;
HttpSessionListener;
ServletRequestListner;
属性监听接口:
ServletContextAttributeListener;
HttpSessionAttributeListener;
ServletRequestAttributeListner;
4, 代码实现
@WebListener  //注解形式配置
public class MyListener implements HttpSessionListener, HttpSessionAttributeListener{
	@Override
	public void sessionCreated(HttpSessionEvent se){
		sysout("HttpSession创建, SessionId: " + se.getSession().getId());
	}
	@Override
	public void sessionDestroy(HttpSessionEvent se){
		sysout("HttpSession销毁");
	}
	@Override
	public void attributeAdded(HttpSessionBindingEvent event){
		sysout("新增session属性: " + event.getName() + "->" + event.getValue());
	}
	@Override
	public void attributeRemoved(HttpSessionBindingEvent event) { ... }
	@Override
	public void attributeReplaced(HttpSessionBindingEvent event) { ... }
}
5, 应用场景
1)流量分析统计
2)静态数据预加载


>>FreeMarker模板引擎
1, 模板引擎
模板+数据->模板引擎->展现结果
主流模板引擎: JSP, FreeMarker, Beetl;
freemarker文件以.ftl命名
2, JSP与FreeMarker的区别
JSP是官方标准，执行方式是编译型，执行效率高，开发效率低，扩展能力弱，数据提取用JSTL+EL;
FreeMarker不是官方标准，需要引入jar包，执行方式为解释型，执行效率低，开发效率高，扩展能力强，数据提取用内置标签;
3, 需要引入freemarker.jar包，eclipse会提示安装ftl编辑器，用于智能提示，不装也可以;
//主java文件: main()
//1，加载模板
Configuration config = new Configuration(Configuration.VERSION_2_3_28);  //创建核心配置对象
config.setClassForTemplateLoading(FreeMarkerSample.class, "");  //设置加载的目录
Template t = config.getTemplate("sample.ftl");  //得到模板对象
//2，创建数据
Map<String, Object> data = new HashMap<>();
data.put("site", "百度");
data.put("url", "http://www.baidu.com");
data.put("date", new Date());
data.put("number", 1234567.7654321);
data.put("leader", new Person("zhao", 40));
//3，产生输出
t.process(data, new OutputStreamWriter(System.out));
//模板文件: sample.ftl
${site}-${url}
4, ftl取值
${属性名}  //直接取值
${属性名!默认值}  //使用默认值，如${author!"张三"}
${属性名?string}  //格式化输出，如
	${date?string("yyyy-MM-dd HH:mm:ss SSS")},
	${number?string("0.00")},
	${leader.name}
string用于三目运算符:
${(words?index_of("o") != -1)?string("是", "不是")}
5, 条件判断
1)if
data.put("state", 1);
<#if state == 1>状态；正在使用
<#elseif state == 2>状态：闲置
<#else>状态：无效状态
</#if>
??代表判断对象是否为空，如果为空则不输出，如
<#if computer.user??>
用户：${computer.user}
</#if>
注: 在标签外引用变量用${}，在标签内直接使用变量名;
2)switch
<#switch state>
	<#case 1>正在使用<#break>
	<#case 2>闲置<#break>
	<#default>无效状态
</#switch>
6, 循环
1)列表
<#list datas as v>
	${v_index}-${v}
</#list>
注: 迭代变量_index代表索引;
2)Map
<#list datas?keys as k>
	${k}:${datas[k]}
</#list>
7, freemarker的内建函数
${words?length}  //长度
${words?index_of("o")}  //第一次出现的索引
${words?replace("o", "*")}  //全部替换
${words?upper_case/lower_case}  //大小写转换
${n?round/floor/ceiling} //四舍五入/向下取整/向上取整
${list?size}  //集合元素的个数
${list?first/last}  //集合的第一个元素/最后一个元素
${list?reverse}  //集合反转
${list?sort}  //集合排序
${list?sort_by("age")}  //集合元素按年龄排序
如 
<#list list?sort_by("age") as c>
	${c.name}-${c.age}
</#list>
8, freemarker与servlet整合
步骤:
1)新建Dynamic工程, 将freemarker.jar包放入WEB-INF/lib目录, 在WEB-INF目录下新建ftl文件夹,
以后的ftl文件都放在WEB-INF/ftl文件夹下;
2)配置web.xml
<servlet>
	<servlet-name>freemarker</servlet-name>
	<servlet-class>freemarker.ext.servlet.FreemarkerServlet</servlet-class>
	<init-param>
		<param-name>TemplatePath</param-name>
		<param-value>/WEB-INF/ftl</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>freemarker</servlet-name>
	<url-pattern>*.ftl</url-pattern>
</servlet-mapping>
3)写servlet与ftl文件
//ListServlet.java
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	List<Employee> list = new ArrayList<>();
	list.add(new Employee(1001, "张三", 32));
	list.add(new Employee(1002, "李四", 38));
	request.setAttribute("list", list);
	request.getRequestDispatcher("employee.ftl").forward(request, response);
}
//employee.ftl
<#list list as v>
<tr>
	<td>${v_index + 1}</td>
	<td>${v.empno?string("0")}</td>
	<td>${v.ename}</td>
	<td>${v.eage}</td>
</tr>
</#list>